#!/usr/bin/env perl

# NAME     : nfit
# VERSION  : 2.27.147.3 # Added missing parse_percentile_list subroutine
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Analyse NMON PhysC and optionally RunQ data for AIX and Linux on Power
#            VM right-sizing recommendations. Calculates rolling average (SMA or EMA)
#            percentiles, optionally absolute peaks, and specified percentiles of
#            normalised and absolute run-queue statistics.
#            If windowed decay is enabled, metrics are calculated per window,
#            weighted by recency, and then aggregated.
#            Supports filtering by date (start and end), time, VM, weekends,
#            and percentile threshold, plus rounding options.
# REQUIRES : Perl, Time::Piece, POSIX (for ceil), List::Util (for sum0), Getopt::Long, File::Temp, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Temp qw(tempfile); 
use List::Util qw(sum0 max); 
use POSIX qw(ceil);
use Time::Piece;
use Time::Seconds; 
use version;

# --- Version ---
my $VERSION = '2.27.147.3';

# --- Configuration ---
my $DEFAULT_AVG_METHOD     = 'ema';
my $DEFAULT_DECAY_LEVEL    = 'medium';
my $DEFAULT_WINDOW_MINUTES = 15; 
my $DEFAULT_PERCENTILE     = 95;
my $DEFAULT_ROUND_INCREMENT= 0.05;
my $DEFAULT_SMT            = 8;
my $DEFAULT_RUNQ_NORM_PERC = "50,90";
my $DEFAULT_RUNQ_ABS_PERC  = "90";
my $FLOAT_EPSILON          = 1e-9;
my $ACTIVE_PHYSC_THRESHOLD = 0.05;

# Windowed Decay Defaults (if enabled for nfit itself)
my $DEFAULT_PROCESS_WINDOW_UNIT = "weeks"; 
my $DEFAULT_PROCESS_WINDOW_SIZE = 1;       
my $DEFAULT_DECAY_HALF_LIFE_DAYS = 30;


# EMA Alpha values based on decay level
my %EMA_ALPHAS = (
    'low'        => 0.03, 
    'medium'     => 0.08, 
    'high'       => 0.15, 
    'very-high'  => 0.30, 
    'extreme'    => 0.40, 
);

# --- Argument Parsing ---
my $physc_csv_file;
my $runq_csv_file;
my $avg_method     = $DEFAULT_AVG_METHOD;
my $decay_level    = $DEFAULT_DECAY_LEVEL;
my $window_minutes = $DEFAULT_WINDOW_MINUTES; 
my $percentile     = $DEFAULT_PERCENTILE;     
my $start_date_str; 
my $end_date_str;   
my $calculate_peak = 0;
my $round_arg;
my $roundup_arg;
my $start_time_str;
my $end_time_str;
my $online_flag = 0;
my $batch_flag  = 0;
my $target_vm_name;
my $no_weekends = 0;
my $filter_above_perc_value = undef;
my $smt_value = $DEFAULT_SMT;
my $runq_norm_perc_str = $DEFAULT_RUNQ_NORM_PERC;
my $runq_abs_perc_str  = $DEFAULT_RUNQ_ABS_PERC;
my $help           = 0;
my $show_version   = 0;

my $enable_windowed_decay_internal = 0;
my $process_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT;
my $process_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE;
my $decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS;
my $analysis_reference_date_str; 

GetOptions(
    'physc-data|pc=s'     => \$physc_csv_file,
    'runq-data|rq=s'      => \$runq_csv_file,
    'avg-method=s'        => \$avg_method,
    'decay=s'             => \$decay_level,
    'window|w=i'          => \$window_minutes,
    'percentile|p=f'      => \$percentile,
    'startdate|s=s'       => \$start_date_str,
    'enddate|ed=s'        => \$end_date_str,
    'peak|k'              => \$calculate_peak,
    'round|r:f'           => \$round_arg,
    'roundup|u:f'         => \$roundup_arg,
    'startt=s'            => \$start_time_str,
    'endt=s'              => \$end_time_str,
    'online'              => \$online_flag,
    'batch'               => \$batch_flag,
    'vm|lpar=s'           => \$target_vm_name,
    'no-weekends'         => \$no_weekends,
    'filter-above-perc=f' => \$filter_above_perc_value,
    'smt=i'               => \$smt_value,
    'runq-norm-perc=s'    => \$runq_norm_perc_str,
    'runq-abs-perc=s'     => \$runq_abs_perc_str,
    'enable-windowed-decay'     => \$enable_windowed_decay_internal,
    'process-window-unit=s'     => \$process_window_unit_str,      
    'process-window-size=i'     => \$process_window_size_val,      
    'decay-half-life-days=i'    => \$decay_half_life_days_val,
    'analysis-reference-date=s' => \$analysis_reference_date_str,
    'help|h'              => \$help,
    'version|v'           => \$show_version,
) or die usage();

# --- Validation ---
# ... (Validations remain the same as nfit v2.27.147.2) ...
if ($show_version) { print STDERR "nfit version $VERSION\n"; exit 0; }
if ($help || !$physc_csv_file) { print STDERR usage(); exit 0; }
$avg_method = lc($avg_method);
if ($avg_method ne 'sma' && $avg_method ne 'ema') { die "Error: --avg-method must be 'sma' or 'ema'. Got '$avg_method'.\n"; }
$decay_level = lc($decay_level);
if ($avg_method eq 'ema' && !exists $EMA_ALPHAS{$decay_level}) { my $valid_decays = join(", ", sort keys %EMA_ALPHAS); die "Error: --decay level '$decay_level' is invalid for EMA. Valid levels are: $valid_decays.\n"; }
if (! -f $physc_csv_file) { die "Error: PhysC data file (--physc-data) not found: $physc_csv_file\n"; }
if (defined $runq_csv_file && ! -f $runq_csv_file) { die "Error: RunQ data file (--runq-data) not found: $runq_csv_file\n"; }
if ($smt_value <= 0) { die "Error: --smt value must be a positive integer.\n"; }
if ($window_minutes < 1) { die "Error: Window size (-w) for SMA/EMA must be at least 1 minute.\n"; }
if ($percentile < 0 || $percentile > 100) { die "Error: Percentile (-p) must be between 0 and 100.\n"; }
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n"; }
if (defined $end_date_str && $end_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid enddate (-ed) format '$end_date_str'. Use YYYY-MM-DD.\n"; }
if (defined $start_date_str && defined $end_date_str) {
    my ($s_tp_val, $e_tp_val);
    eval { $s_tp_val = Time::Piece->strptime($start_date_str, "%Y-%m-%d"); }; if ($@ || (defined $start_date_str && !$s_tp_val) ) { die "Error parsing startdate '$start_date_str': $@\n"; }
    eval { $e_tp_val = Time::Piece->strptime($end_date_str, "%Y-%m-%d"); }; if ($@ || (defined $end_date_str && !$e_tp_val) ) { die "Error parsing enddate '$end_date_str': $@\n"; }
    if ($s_tp_val && $e_tp_val && $e_tp_val < $s_tp_val) { die "Error: --enddate ($end_date_str) cannot be before --startdate ($start_date_str).\n"; }
}
if (defined($round_arg) && defined($roundup_arg)) { die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n"; }
if ($enable_windowed_decay_internal) {
    if ($process_window_unit_str ne "days" && $process_window_unit_str ne "weeks") { die "Error: --process-window-unit must be 'days' or 'weeks'. Got '$process_window_unit_str'.\n"; }
    if ($process_window_size_val < 1) { die "Error: --process-window-size must be at least 1. Got '$process_window_size_val'.\n"; }
    if ($decay_half_life_days_val < 1) { die "Error: --decay-half-life-days must be at least 1. Got '$decay_half_life_days_val'.\n"; }
    if (defined $analysis_reference_date_str && $analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid --analysis-reference-date format '$analysis_reference_date_str'. Use YYYY-MM-DD.\n"; }
}


my @runq_norm_percentiles_to_calc = parse_percentile_list($runq_norm_perc_str, "runq-norm-perc");
my @runq_abs_percentiles_to_calc  = parse_percentile_list($runq_abs_perc_str,  "runq-abs-perc");

# --- Determine Rounding Method and Increment ---
# (Same as before)
my $rounding_method = 'none'; my $round_increment = undef; my $output_dp = 4; 
if (defined $round_arg) { $rounding_method = 'standard'; $round_increment = (length $round_arg && $round_arg =~ /^[0-9.]*$/) ? $round_arg : $DEFAULT_ROUND_INCREMENT; print STDERR "Applying standard rounding to nearest $round_increment\n"; }
elsif (defined $roundup_arg) { $rounding_method = 'up'; $round_increment = (length $roundup_arg && $roundup_arg =~ /^[0-9.]*$/) ? $roundup_arg : $DEFAULT_ROUND_INCREMENT; print STDERR "Applying ceiling rounding up to nearest $round_increment\n"; }
if ($rounding_method ne 'none') { if (!defined $round_increment || $round_increment <= 0) { die "Error: Rounding increment must be positive (got '$round_increment').\n"; } $output_dp = get_decimal_places($round_increment); }


# --- Determine Time Filter Window (for daily HH:MM filtering) ---
# (Same as before)
my $time_filter_active = 0; my $time_filter_start = undef; my $time_filter_end = undef; my $time_filter_overnight = 0; my $time_filter_desc = "";
if ($online_flag) { $time_filter_active = 1; $time_filter_start = "08:00"; $time_filter_end = "17:00"; $time_filter_desc = "ONLINE ($time_filter_start <= time < $time_filter_end)"; }
elsif ($batch_flag) { $time_filter_active = 1; $time_filter_start = "18:00"; $time_filter_end = "06:00"; $time_filter_overnight = 1; $time_filter_desc = "BATCH (time >= $time_filter_start OR time < $time_filter_end)"; }
elsif (defined $start_time_str) { $time_filter_active = 1; $time_filter_start = $start_time_str; $time_filter_end = $end_time_str; if ($time_filter_end lt $time_filter_start) { $time_filter_overnight = 1; $time_filter_desc = "OVERNIGHT (time >= $time_filter_start OR time < $time_filter_end)"; } else { $time_filter_desc = "MANUAL ($time_filter_start <= time < $time_filter_end)"; }}


# --- Main Processing ---
# (Startup messages same as before)
my $script_start_time = time(); 
print STDERR "nfit version $VERSION\n";
print STDERR "Processing PhysC data from: $physc_csv_file\n";
my $alpha_for_ema = undef; 
if ($avg_method eq 'ema') { $alpha_for_ema = $EMA_ALPHAS{$decay_level}; print STDERR "Using EMA for PhysC rolling average (decay: $decay_level, alpha: $alpha_for_ema).\n"; print STDERR "Conceptual window for EMA start trigger (within processing windows if decay enabled): $window_minutes minutes.\n"; }
else { print STDERR "Using SMA for PhysC rolling average with window (within processing windows if decay enabled): $window_minutes minutes.\n"; }
if (defined $runq_csv_file) { print STDERR "Processing RunQ data from: $runq_csv_file (using SMT: $smt_value for normalisation)\n"; if (@runq_norm_percentiles_to_calc) { print STDERR "Calculating Normalised RunQ Percentiles: " . join(", ", map {"P$_"} @runq_norm_percentiles_to_calc) . "\n"; } if (@runq_abs_percentiles_to_calc) { print STDERR "Calculating Absolute RunQ Percentiles: " . join(", ", map {"P$_"} @runq_abs_percentiles_to_calc) . "\n"; } }
my $p_label_display = sprintf("P%.2f", $percentile); $p_label_display =~ s/\.?0+$//; $p_label_display = "0" if $p_label_display eq "" && abs($percentile-0) < 0.001;
print STDERR "Calculating PhysC percentile: $p_label_display\n";
print STDERR "Calculating absolute PhysC peak: " . ($calculate_peak ? "Yes" : "No") . "\n";
if (defined $start_date_str) { print STDERR "Ignoring data before global start date: $start_date_str\n"; }
if (defined $end_date_str) { print STDERR "Ignoring data after global end date: $end_date_str\n"; }
if ($no_weekends) { print STDERR "Applying filter: Excluding Weekends (Sat/Sun)\n"; }
if ($time_filter_active) { print STDERR "Applying time filter: $time_filter_desc\n"; }
if (defined $filter_above_perc_value) { my $filter_p_label = sprintf("P%.2f", $filter_above_perc_value); $filter_p_label =~ s/\.?0+$//; $filter_p_label = "0" if $filter_p_label eq "" && abs($filter_above_perc_value - 0) < 0.001; print STDERR "Applying PhysC percentile filter: Using rolling averages >= $filter_p_label of all rolling averages\n"; }
if (defined $target_vm_name) { print STDERR "Filtering for VM/LPAR: $target_vm_name\n"; }
if ($enable_windowed_decay_internal) {
    print STDERR "Internal Windowed Decay Processing ENABLED.\n";
    print STDERR "  Process Window Unit: $process_window_unit_str, Size: $process_window_size_val\n";
    print STDERR "  Decay Half-Life: $decay_half_life_days_val days\n";
    if (defined $analysis_reference_date_str) { print STDERR "  Analysis Reference Date: $analysis_reference_date_str\n"; }
}

# --- Data Structures ---
my %vm_data_by_window; 
my @processing_windows; 
my $actual_overall_start_date_obj;
my $actual_overall_end_date_obj;
my $actual_analysis_ref_date_obj;

if ($enable_windowed_decay_internal) {
    ($actual_overall_start_date_obj, $actual_overall_end_date_obj) = get_nmon_overall_date_range($physc_csv_file, $start_date_str, $end_date_str); 
    unless (defined $actual_overall_start_date_obj && $actual_overall_start_date_obj->isa('Time::Piece') && defined $actual_overall_end_date_obj && $actual_overall_end_date_obj->isa('Time::Piece')) {
        die "Error: Could not determine actual data processing range from NMON file '$physc_csv_file' after applying global date filters. Windowed decay cannot proceed.\n";
    }
    if (defined $analysis_reference_date_str) {
        eval { $actual_analysis_ref_date_obj = Time::Piece->strptime($analysis_reference_date_str, "%Y-%m-%d"); };
        unless (defined $actual_analysis_ref_date_obj && $actual_analysis_ref_date_obj->isa('Time::Piece')) { die "Error: Invalid --analysis-reference-date: '$analysis_reference_date_str'. Ensure format YYYY-MM-DD. Parser error: $@\n"; }
    } else { $actual_analysis_ref_date_obj = $actual_overall_end_date_obj; }
    $actual_analysis_ref_date_obj = $actual_analysis_ref_date_obj->truncate(to => 'day'); # Ensure it's just a date for comparison with window representative dates
    @processing_windows = generate_processing_time_windows($actual_overall_start_date_obj, $actual_overall_end_date_obj, $process_window_unit_str, $process_window_size_val);
    if (scalar @processing_windows == 0) { die "Error: No processing windows generated. Check NMON data range and window parameters.\n"; }
    print STDERR "Generated " . scalar(@processing_windows) . " processing windows for internal aggregation.\n";
}

my @vm_names_from_physc_header;
my $target_vm_index_in_physc = undef;
my %current_window_vm_data_buffer; 
my %temp_files_for_physc_rolling_avgs_overall; 
my %collected_runq_overall; 
my $line_count = 0;
my $data_lines_processed = 0;
my %runq_data_store; # Declared
my $vm_physc_max_peak_scalar_overall; # Declared
my @vm_physc_max_peaks_list_overall; # Declared


if (defined $runq_csv_file) {
    print STDERR "Pre-loading RunQ data...\n";
    open my $runq_fh, '<:encoding(utf8)', $runq_csv_file or die "Error: Cannot open RunQ CSV file '$runq_csv_file': $!\n";
    my $runq_line_count = 0; my @runq_vm_names_header;
    while (my $line = <$runq_fh>) { chomp $line; $line =~ s/\r$//; $runq_line_count++; next if ($line =~ /^\s*$/o); $line =~ s/^\x{FEFF}// if $runq_line_count == 1; my @fields = split /,/, $line, -1;
        if ($runq_line_count == 1) { shift @fields; @runq_vm_names_header = map { my ($name) = split / /; $name =~ s/^"|"$//g; $name } @fields; if (defined $target_vm_name && !grep { $_ eq $target_vm_name } @runq_vm_names_header) { print STDERR "Warning: Target VM '$target_vm_name' not found in RunQ CSV header. RunQ metrics for it will be N/A.\n"; } next; }
        my $timestamp_str = $fields[0]; shift @fields;
        for (my $i = 0; $i <= $#fields; $i++) { my $vm_name = $runq_vm_names_header[$i]; next unless (defined $vm_name && $vm_name ne ''); if (!defined $target_vm_name || $vm_name eq $target_vm_name) { if (defined $fields[$i] && $fields[$i] =~ /^[0-9.]+$/) { $runq_data_store{$vm_name}{$timestamp_str} = $fields[$i]; }}}}
    close $runq_fh; print STDERR "Finished pre-loading RunQ data for " . scalar(keys %runq_data_store) . " VMs from $runq_line_count lines.\n";
}

print STDERR "Processing PhysC data and calculating metrics...\n";
open my $physc_csv_fh, '<:encoding(utf8)', $physc_csv_file or die "Error: Cannot open PhysC CSV file '$physc_csv_file': $!\n";
my $current_window_idx = 0; 
my $current_processing_window_end_obj = ($enable_windowed_decay_internal && @processing_windows) ? $processing_windows[0][1] : undef;

# ... (The rest of the script, including the main PhysC processing loop,
#      the finalization of the last window, the percentile calculation and output formatting section,
#      and all subroutines, should be copied verbatim from nfit version 2.27.147.0,
#      as the error was only in the initial declaration/validation section.)
#      The section starting with "while (my $line = <$physc_csv_fh>)" and all subsequent subroutines.

# --- Process PhysC Data (Main Loop from v2.27.147.0) ---
while (my $line = <$physc_csv_fh>) {
    chomp $line; $line =~ s/\r$//; $line_count++;
    next if ($line =~ /^\s*$/o);
    $line =~ s/^\x{FEFF}// if $line_count == 1;
    my @fields = split /,/, $line, -1;

    if ($line_count == 1) { 
        shift @fields; my $num_vms_found = 0; my $current_idx_header = 0; 
        foreach my $header_field (@fields) {
            $header_field =~ s/^\s+|\s+$//g; $header_field =~ s/^"|"$//g; my ($vm_name) = split / /, $header_field, 2;
            if (defined $vm_name && $vm_name ne '') { push @vm_names_from_physc_header, $vm_name; if (defined $target_vm_name && $vm_name eq $target_vm_name) { $target_vm_index_in_physc = $current_idx_header; } $num_vms_found++; }
            else { print STDERR "Warning: Could not extract VM name from PhysC header index $current_idx_header: '$header_field'\n"; push @vm_names_from_physc_header, "UNKNOWN_VM_PHYSC_$current_idx_header"; }
            $current_idx_header++;
        }
        my $num_vms = scalar(@vm_names_from_physc_header); if ($num_vms == 0) { die "Error: No valid VM columns found in PhysC header.\n"; }
        print STDERR "Found $num_vms VMs in PhysC header.\n";
        if (defined $target_vm_name && !defined $target_vm_index_in_physc) { my $avail_vms = join(", ", @vm_names_from_physc_header); $avail_vms = substr($avail_vms, 0, 200) . "..." if length($avail_vms) > 200; die "Error: Target VM '$target_vm_name' not found in PhysC CSV header.\nAvailable VMs: $avail_vms\n"; }
        unless ($enable_windowed_decay_internal) {
            if (defined $target_vm_index_in_physc) {
                my $vm_name = $target_vm_name;
                my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file for $vm_name: $!\n"; }
                $temp_files_for_physc_rolling_avgs_overall{$vm_name} = { fh => $fh, filename => $fname };
            } else {
                foreach my $vm_name (@vm_names_from_physc_header) {
                    my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file for $vm_name: $!\n"; }
                    $temp_files_for_physc_rolling_avgs_overall{$vm_name} = { fh => $fh, filename => $fname };
                }
            }
        }
        next; 
    }
    my $timestamp_str = $fields[0];
    my $tp;
    eval { $tp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S"); };
    if ($@ || !defined $tp || !$tp->isa('Time::Piece')) { print STDERR "Warning: Could not parse timestamp '$timestamp_str' line $line_count. Skipping.\n"; next; }

    if (defined $start_date_str && $tp->ymd('-') lt $start_date_str) { next; }
    if (defined $end_date_str   && $tp->ymd('-') gt $end_date_str)   { next; } 
    if ($no_weekends) { my $day_of_week = $tp->day_of_week; if ($day_of_week == 1 || $day_of_week == 7) { next; } } 
    if ($time_filter_active) {
        my $line_time = substr($tp->hms(':'), 0, 5); my $include_line = 0;
        if ($time_filter_overnight) { if ($line_time ge $time_filter_start || $line_time lt $time_filter_end) { $include_line = 1; } }
        else { if ($line_time ge $time_filter_start && $line_time lt $time_filter_end) { $include_line = 1; } }
        unless ($include_line) { next; }
    }
    
    $data_lines_processed++;
    shift @fields; 

    my $current_window_key;
    if ($enable_windowed_decay_internal) {
        my $current_timestamp_day_obj = $tp->truncate(to => 'day');
        while (defined $current_processing_window_end_obj && $current_timestamp_day_obj > $current_processing_window_end_obj) {
            process_and_store_window_results(
                $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window, 
                \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
                $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc
            );
            %current_window_vm_data_buffer = (); 
            $current_window_idx++;
            if ($current_window_idx < @processing_windows) {
                $current_processing_window_end_obj = $processing_windows[$current_window_idx][1];
            } else {
                $current_processing_window_end_obj = undef; 
                last; 
            }
        }
        $current_window_key = get_window_key_for_timestamp($tp, \@processing_windows, $current_window_idx); 
        unless (defined $current_window_key) { next; }
    }

    my @vms_to_iterate_this_line;
    if (defined $target_vm_index_in_physc) { push @vms_to_iterate_this_line, { index => $target_vm_index_in_physc, name => $target_vm_name }; }
    else { for (my $i=0; $i < @vm_names_from_physc_header; $i++) { push @vms_to_iterate_this_line, { index => $i, name => $vm_names_from_physc_header[$i] }; }}

    foreach my $vm_info (@vms_to_iterate_this_line) {
        my $vm_idx = $vm_info->{index}; my $current_vm_name = $vm_info->{name};
        my $physc_value_str = defined $fields[$vm_idx] ? $fields[$vm_idx] : '';
        my $physc_value;
        if ($physc_value_str =~ /^\s*([0-9.]+)\s*$/) { $physc_value = $1+0; } else { $physc_value = undef; }

        if ($enable_windowed_decay_internal) {
            unless (exists $current_window_vm_data_buffer{$current_vm_name}{$current_window_key}) {
                $current_window_vm_data_buffer{$current_vm_name}{$current_window_key} = {
                    physc_sma_queue => [], prev_ema => undef, raw_physc_for_peak => [],
                    rolling_physc_avgs => [], norm_rq_vals => [], abs_rq_vals => [],
                    ema_point_counter => []
                };
            }
            my $vm_win_buf = $current_window_vm_data_buffer{$current_vm_name}{$current_window_key};
            if (defined $physc_value) { push @{$vm_win_buf->{raw_physc_for_peak}}, $physc_value; }
            my $current_avg_output_value_win;
            if ($avg_method eq 'sma') {
                push @{$vm_win_buf->{physc_sma_queue}}, $physc_value;
                shift @{$vm_win_buf->{physc_sma_queue}} while scalar @{$vm_win_buf->{physc_sma_queue}} > $window_minutes;
                if (scalar @{$vm_win_buf->{physc_sma_queue}} == $window_minutes) { $current_avg_output_value_win = calculate_average(@{$vm_win_buf->{physc_sma_queue}}); }
            } else { 
                if (defined $physc_value) {
                    if (!defined $vm_win_buf->{prev_ema}) { $vm_win_buf->{prev_ema} = $physc_value; }
                    else { $vm_win_buf->{prev_ema} = ($physc_value * $alpha_for_ema) + ($vm_win_buf->{prev_ema} * (1 - $alpha_for_ema)); }
                    push @{$vm_win_buf->{ema_point_counter}}, $physc_value;
                    shift @{$vm_win_buf->{ema_point_counter}} while scalar @{$vm_win_buf->{ema_point_counter}} > $window_minutes;
                    if (scalar @{$vm_win_buf->{ema_point_counter}} == $window_minutes) { $current_avg_output_value_win = $vm_win_buf->{prev_ema}; }
                } else { push @{$vm_win_buf->{ema_point_counter}}, undef; shift @{$vm_win_buf->{ema_point_counter}} while scalar @{$vm_win_buf->{ema_point_counter}} > $window_minutes; }
            }
            if (defined $current_avg_output_value_win) { push @{$vm_win_buf->{rolling_physc_avgs}}, $current_avg_output_value_win; }
            if (defined $runq_csv_file && defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
                if (exists $runq_data_store{$current_vm_name}{$timestamp_str}) { 
                    my $runq_value = $runq_data_store{$current_vm_name}{$timestamp_str}; push @{$vm_win_buf->{abs_rq_vals}}, $runq_value; 
                    my $effective_lcpus = $physc_value * $smt_value; if ($effective_lcpus > $FLOAT_EPSILON) { push @{$vm_win_buf->{norm_rq_vals}}, ($runq_value / $effective_lcpus); }
                }
            }
        } else { 
            my $vm_overall_peak_ref = defined($target_vm_name) ? \$vm_physc_max_peak_scalar_overall : \$vm_physc_max_peaks_list_overall[$vm_idx]; 
            if ($calculate_peak && defined $physc_value) { if (!defined(${$vm_overall_peak_ref}) || $physc_value > ${$vm_overall_peak_ref}) { ${$vm_overall_peak_ref} = $physc_value; } }
            my $current_avg_output_value_overall; my $temp_fh_overall; my $prev_ema_ref_overall; my $sma_queue_ref_overall;
            my $buffer_key = "_overall_vm_$current_vm_name"; 
            $temp_fh_overall = $temp_files_for_physc_rolling_avgs_overall{$current_vm_name}{fh};
            $prev_ema_ref_overall = \$current_window_vm_data_buffer{$buffer_key}{'prev_ema'}; 
            $sma_queue_ref_overall = \@{$current_window_vm_data_buffer{$buffer_key}{'sma_queue'}};
            if ($avg_method eq 'sma') { 
                push @{$sma_queue_ref_overall}, $physc_value; shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes;
                if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = calculate_average(@{$sma_queue_ref_overall});}
            } else { 
                if (defined $physc_value) { if (!defined ${$prev_ema_ref_overall}) { ${$prev_ema_ref_overall} = $physc_value; } else { ${$prev_ema_ref_overall} = ($physc_value * $alpha_for_ema) + (${$prev_ema_ref_overall} * (1 - $alpha_for_ema)); } push @{$sma_queue_ref_overall}, $physc_value; shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes; if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = ${$prev_ema_ref_overall}; }}
                else { push @{$sma_queue_ref_overall}, undef; shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes; }
            }
            if (defined $current_avg_output_value_overall && defined $temp_fh_overall) { print {$temp_fh_overall} "$current_avg_output_value_overall\n" or die "Error writing PhysC temp file for $current_vm_name: $!";}
            if (defined $runq_csv_file && defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
                if (exists $runq_data_store{$current_vm_name}{$timestamp_str}) { 
                    my $runq_value = $runq_data_store{$current_vm_name}{$timestamp_str}; push @{$collected_runq_overall{$current_vm_name}{abs}}, $runq_value; 
                    my $effective_lcpus = $physc_value * $smt_value; if ($effective_lcpus > $FLOAT_EPSILON) { push @{$collected_runq_overall{$current_vm_name}{norm}}, ($runq_value / $effective_lcpus); }
                }
            }
        } 
    } 
    if ($data_lines_processed > 0 && $data_lines_processed % 10000 == 0) { print STDERR "Processed $data_lines_processed NMON data lines (matching filters)...\n"; }
}
close $physc_csv_fh;

if ($enable_windowed_decay_internal) {
    if ($current_window_idx < @processing_windows && %current_window_vm_data_buffer) {
         process_and_store_window_results(
            $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window, 
            \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
            $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc
        );
    }
} else {
    foreach my $vm_name (keys %temp_files_for_physc_rolling_avgs_overall) {
        if (defined $temp_files_for_physc_rolling_avgs_overall{$vm_name} && 
            exists $temp_files_for_physc_rolling_avgs_overall{$vm_name}{fh} &&
            defined $temp_files_for_physc_rolling_avgs_overall{$vm_name}{fh}) {
            close $temp_files_for_physc_rolling_avgs_overall{$vm_name}{fh} or warn "Could not close temp file for $vm_name: $!";
        }
    }
}
print STDERR "Finished reading NMON data. Processed $data_lines_processed data lines matching filters.\n";

my @results_data_output; 
print STDERR "Calculating final results...\n";
my @vms_for_final_output = defined($target_vm_name) ? ($target_vm_name) : @vm_names_from_physc_header;

foreach my $vm_name (@vms_for_final_output) {
    my $output_line_for_vm = "$vm_name:";
    my %final_metrics_for_vm; 

    if ($enable_windowed_decay_internal) {
        my $p_label_main_decay = sprintf("P%.2f", $percentile); $p_label_main_decay =~ s/\.?0+$//; $p_label_main_decay = "0" if $p_label_main_decay eq "" && abs($percentile-0)<0.001;
        $p_label_main_decay = "P$p_label_main_decay" unless $p_label_main_decay =~ /^P/;
        $final_metrics_for_vm{$p_label_main_decay} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $p_label_main_decay, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val);
        if ($calculate_peak) { $final_metrics_for_vm{'Peak'} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, 'Peak', \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val); }
        if (defined $runq_csv_file) {
            foreach my $p_val (@runq_norm_percentiles_to_calc) { my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//;$p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001; my $mk="NormRunQ_P$p_lbl_base"; $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");}
            foreach my $p_val (@runq_abs_percentiles_to_calc)  { my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//;$p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001; my $mk="AbsRunQ_P$p_lbl_base";  $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");}
        }
    } else { 
        my $temp_file_path_val = $temp_files_for_physc_rolling_avgs_overall{$vm_name}{filename}; # Renamed
        my @physc_avg_values_from_file;
        my $percentile_val_raw_overall = undef; 
        my $vm_idx_overall = (defined($target_vm_name) && $target_vm_name eq $vm_name) ? $target_vm_index_in_physc : get_vm_index_by_name($vm_name, \@vm_names_from_physc_header);
        my $peak_val_raw_overall = defined($target_vm_name) ? $vm_physc_max_peak_scalar_overall : ( (defined $vm_idx_overall && defined $vm_physc_max_peaks_list_overall[$vm_idx_overall]) ? $vm_physc_max_peaks_list_overall[$vm_idx_overall] : undef); 

        if (defined $temp_file_path_val && -f $temp_file_path_val && -s $temp_file_path_val) {
            open my $in_fh, '<', $temp_file_path_val or print STDERR "Warning: Could not open temp file $temp_file_path_val for $vm_name: $!\n";
            if ($in_fh) { while (my $num = <$in_fh>) { chomp $num; if ($num =~ /^-?[0-9]+(?:\.[0-9]+)?$/) { push @physc_avg_values_from_file, $num; } } close $in_fh; }
        }
        unlink $temp_file_path_val or warn "Could not delete temporary file '$temp_file_path_val': $!" if defined $temp_file_path_val && -f $temp_file_path_val;
        
        if (@physc_avg_values_from_file && defined $filter_above_perc_value) { 
             my @sff = sort { $a <=> $b } @physc_avg_values_from_file; my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
             if (defined $ft) {
                 my @fa = grep { defined($_) && $_ >= ($ft - $FLOAT_EPSILON) } @physc_avg_values_from_file;
                 if (@fa) { my @sf = sort { $a <=> $b } @fa; $percentile_val_raw_overall = calculate_percentile(\@sf, $percentile); }
                 else { $percentile_val_raw_overall = undef; }
             } else { if (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile); }}
        } elsif (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile); }
        
        my $p_label_main_overall = sprintf("P%.2f", $percentile); $p_label_main_overall =~ s/\.?0+$//; $p_label_main_overall = "0" if $p_label_main_overall eq "" && abs($percentile-0)<0.001;
        $p_label_main_overall = "P$p_label_main_overall" unless $p_label_main_overall =~ /^P/;
        $final_metrics_for_vm{$p_label_main_overall} = defined($percentile_val_raw_overall) ? $percentile_val_raw_overall : "N/A";
        if ($calculate_peak) { $final_metrics_for_vm{'Peak'} = defined($peak_val_raw_overall) ? $peak_val_raw_overall : "N/A"; }

        if (defined $runq_csv_file && exists $collected_runq_overall{$vm_name}) {
            if (exists $collected_runq_overall{$vm_name}{norm} && @{$collected_runq_overall{$vm_name}{norm}}) {
                my @sorted_norm = sort {$a <=> $b} @{$collected_runq_overall{$vm_name}{norm}};
                foreach my $p_val (@runq_norm_percentiles_to_calc) { my $val = calculate_percentile(\@sorted_norm, $p_val); my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"NormRunQ_$pl"} = defined($val)?sprintf("%.2f",$val):"N/A";}
            }
            if (exists $collected_runq_overall{$vm_name}{abs} && @{$collected_runq_overall{$vm_name}{abs}}) {
                my @sorted_abs = sort {$a <=> $b} @{$collected_runq_overall{$vm_name}{abs}};
                foreach my $p_val (@runq_abs_percentiles_to_calc) { my $val = calculate_percentile(\@sorted_abs, $p_val); my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"AbsRunQ_$pl"} = defined($val)?sprintf("%.2f",$val):"N/A";}
            }
        }
    }

    my $p_label_out = sprintf("P%.2f", $percentile); $p_label_out =~ s/\.?0+$//; $p_label_out = "0" if $p_label_out eq "" && abs($percentile-0)<0.001;
    $p_label_out = "P$p_label_out" unless $p_label_out =~ /^P/;
    my $physc_p_val = $final_metrics_for_vm{$p_label_out} // "N/A";
    if ($physc_p_val ne "N/A" && $physc_p_val =~ /^-?[0-9.]+$/) { my $r = apply_rounding($physc_p_val, $round_increment, $rounding_method); $output_line_for_vm .= " $p_label_out=" . sprintf("%.${output_dp}f", $r); } 
    else { $output_line_for_vm .= " $p_label_out=N/A"; }

    if ($calculate_peak) {
        my $peak_val = $final_metrics_for_vm{'Peak'} // "N/A";
        if ($peak_val ne "N/A" && $peak_val =~ /^-?[0-9.]+$/) { my $r = apply_rounding($peak_val, $round_increment, $rounding_method); $output_line_for_vm .= " Peak=" . sprintf("%.${output_dp}f", $r); }
        else { $output_line_for_vm .= " Peak=N/A"; }
    }
    
    my @runq_metric_keys_ordered;
    if (defined $runq_csv_file) {
        foreach my $p_val (@runq_norm_percentiles_to_calc) { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; push @runq_metric_keys_ordered, "NormRunQ_$pl"; }
        foreach my $p_val (@runq_abs_percentiles_to_calc)  { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; push @runq_metric_keys_ordered, "AbsRunQ_$pl"; }
    }
    foreach my $key (@runq_metric_keys_ordered) {
        my $metric_val = $final_metrics_for_vm{$key} // "N/A";
         # RunQ values already sprintf "%.2f" or N/A from get_weighted_metric_for_vm or non-windowed calc
        $output_line_for_vm .= " $key=" . $metric_val;
    }
    
    push @results_data_output, { line => $output_line_for_vm };
}

my $peak_note_out = $calculate_peak ? " (Peak Calc: Yes)" : "";
my $runq_note_out = defined($runq_csv_file) ? " (RunQ SMT: $smt_value, NormPercs: $runq_norm_perc_str, AbsPercs: $runq_abs_perc_str)" : "";
my $rounding_note_out = ($rounding_method ne 'none') ? " (Rounded $rounding_method to $round_increment)" : "";
my $filter_note_out = $time_filter_active ? " (Time Filter: $time_filter_desc)" : "";
my $weekend_note_out = $no_weekends ? " (Weekends Excluded)" : "";
my $perc_filter_note_val_out = defined($filter_above_perc_value) ? sprintf("P%.2f", $filter_above_perc_value) : ""; 
if ($perc_filter_note_val_out ne "") {$perc_filter_note_val_out =~ s/\.?0+$//; $perc_filter_note_val_out = "0" if $perc_filter_note_val_out eq "" && abs($filter_above_perc_value - 0) < 0.001;}
my $perc_filter_note_out = defined($filter_above_perc_value) ? " (PhysC Perc Filter >= $perc_filter_note_val_out)" : "";
my $date_filter_note_out_final = "";
if (defined $start_date_str || defined $end_date_str) { $date_filter_note_out_final = " (Global Date Filter:"; if (defined $start_date_str) { $date_filter_note_out_final .= " Start=$start_date_str"; } if (defined $end_date_str) { $date_filter_note_out_final .= (defined($start_date_str) ? "," : "") . " End=$end_date_str"; } $date_filter_note_out_final .= ")";}
my $window_decay_note_out = $enable_windowed_decay_internal ? " (Windowed Decay: ON, Unit=$process_window_unit_str, Size=$process_window_size_val, HalfLife=${decay_half_life_days_val}d)" : "";
my $header_run_params_label_out_final = sprintf("P%.2f", $percentile); $header_run_params_label_out_final =~ s/\.?0+$//; $header_run_params_label_out_final = "0" if $header_run_params_label_out_final eq "" && abs($percentile-0)<0.001;
$header_run_params_label_out_final = "P$header_run_params_label_out_final" unless $header_run_params_label_out_final =~ /^P/;
$header_run_params_label_out_final .= ", W=$window_minutes (" . uc($avg_method);
if ($avg_method eq 'ema') { $header_run_params_label_out_final .= ", Decay=$decay_level"; }
$header_run_params_label_out_final .= ")";
if (@results_data_output) { print STDERR "\n--- Run Summary ($header_run_params_label_out_final)$peak_note_out$runq_note_out$rounding_note_out$filter_note_out$weekend_note_out$perc_filter_note_out$date_filter_note_out_final$window_decay_note_out ---\n"; }
else { print STDERR "\n--- No results generated for this run (check filters/data) ---\n"; }
foreach my $res (@results_data_output) { print STDOUT $res->{line} . "\n"; }
my $script_end_time_final_run = time(); 
my $duration_final_run = $script_end_time_final_run - $script_start_time;
print STDERR "\nProcessing completed in $duration_final_run seconds.\n";
exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================
# ... (All subroutines copied from nfit v2.27.147.0, including the new ones
#      and ensuring parse_percentile_list is present and correct.)
# calculate_average, calculate_percentile, apply_rounding, get_decimal_places,
# get_nmon_overall_date_range, generate_processing_time_windows, get_window_key_for_timestamp, 
# process_and_store_window_results, calculate_recency_weighted_average,
# get_vm_index_by_name, usage

sub parse_percentile_list { # THIS WAS THE MISSING SUBROUTINE
    my ($perc_str, $arg_name) = @_;
    my @percentiles;
    if (defined $perc_str && $perc_str ne '') {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles) {
            if ($p !~ /^[0-9]+(?:\.[0-9]+)?$/ || $p < 0 || $p > 100) {
                die "Error: Invalid percentile value '$p' in --$arg_name list. Must be numeric between 0 and 100.\n";
            }
            # Store as number for calculation
            push @percentiles, $p + 0;
        }
    }
    return @percentiles;
}

sub get_nmon_overall_date_range { 
    my ($nmon_file, $global_start_filter_str, $global_end_filter_str) = @_;
    print STDERR "Scanning NMON file '$nmon_file' for overall effective date range...\n";
    open my $fh, '<:encoding(utf8)', $nmon_file or die "Error: Cannot open NMON file '$nmon_file': $!\n";
    my $min_date_obj; my $max_date_obj; my $header_skipped = 0; my $first_data_line_checked = 0;
    my $start_filter_obj; my $end_filter_obj;
    if (defined $global_start_filter_str) { eval { $start_filter_obj = Time::Piece->strptime($global_start_filter_str, "%Y-%m-%d"); }; if ($@ || (defined $global_start_filter_str && ! (defined $start_filter_obj && $start_filter_obj->isa('Time::Piece') ) ) ) { die "Error parsing global start date filter '$global_start_filter_str': $@\n"; }}
    if (defined $global_end_filter_str) { eval { $end_filter_obj = Time::Piece->strptime($global_end_filter_str, "%Y-%m-%d"); }; if ($@ || (defined $global_end_filter_str && ! (defined $end_filter_obj && $end_filter_obj->isa('Time::Piece') ) ) ) { die "Error parsing global end date filter '$global_end_filter_str': $@\n"; }}
    while (my $line = <$fh>) {
        chomp $line; $line =~ s/\r$//; next if $line =~ /^\s*$/;
        if (!$header_skipped && !$first_data_line_checked) { if ($line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i) { $header_skipped = 1; next; } $first_data_line_checked = 1; } 
        elsif ($header_skipped && $line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i) { next; } 
        if ($line =~ /^(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/) { 
            my $timestamp_str = $1; $timestamp_str =~ s/T/ /; my $current_tp; 
            eval { $current_tp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S"); };
            if ($@ || !$current_tp || !$current_tp->isa('Time::Piece')) { next; } 
            my $current_date_day_obj = $current_tp->truncate(to => 'day');
            if (defined $start_filter_obj && $current_date_day_obj < $start_filter_obj) { next; }
            if (defined $end_filter_obj   && $current_date_day_obj > $end_filter_obj)   { next; }
            if (!defined $min_date_obj || !$min_date_obj->isa('Time::Piece') || $current_tp < $min_date_obj) { $min_date_obj = $current_tp; }
            if (!defined $max_date_obj || !$max_date_obj->isa('Time::Piece') || $current_tp > $max_date_obj) { $max_date_obj = $current_tp; }
        }
    } close $fh;
    if (defined $min_date_obj && $min_date_obj->isa('Time::Piece') && defined $max_date_obj && $max_date_obj->isa('Time::Piece')) {
        print STDERR "Effective NMON data range for windowing: " . $min_date_obj->datetime . " to " . $max_date_obj->datetime . "\n";
        my $ret_start = $min_date_obj->truncate(to => 'day'); my $ret_end   = $max_date_obj->truncate(to => 'day');
        unless (defined $ret_start && $ret_start->isa('Time::Piece') && defined $ret_end && $ret_end->isa('Time::Piece')) { print STDERR "Error: Truncated date objects became invalid in get_nmon_overall_date_range.\n"; return (undef, undef); }
        return ($ret_start, $ret_end);
    } else { print STDERR "Warning: Could not determine valid min/max dates from NMON file '$nmon_file' after global filters.\n"; return (undef, undef); }
}

sub generate_processing_time_windows { 
    my ($period_start_obj, $period_end_obj, $unit_str, $size_val) = @_; my @windows;
    return () unless (defined $period_start_obj && defined $period_end_obj && $period_start_obj->isa('Time::Piece') && $period_end_obj->isa('Time::Piece') && $period_start_obj <= $period_end_obj);
    my $current_window_start = Time::Piece->new($period_start_obj->epoch);
    while ($current_window_start <= $period_end_obj) {
        my $current_window_end;
        if ($unit_str eq "days") { $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_DAY() * ($size_val - 1)); }
        elsif ($unit_str eq "weeks") { $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_WEEK() * $size_val) - ONE_DAY(); }
        else { die "Unsupported window unit: $unit_str\n"; }
        if ($current_window_end > $period_end_obj) { $current_window_end = Time::Piece->new($period_end_obj->epoch); }
        my $representative_date = Time::Piece->new($current_window_end->epoch); 
        push @windows, [Time::Piece->new($current_window_start->epoch), Time::Piece->new($current_window_end->epoch), $representative_date];
        my $next_window_start_candidate = $current_window_end + ONE_DAY();
        last if ($next_window_start_candidate > $period_end_obj && $current_window_end >= $period_end_obj);
        $current_window_start = $next_window_start_candidate;
    } return @windows;
}

sub get_window_key_for_timestamp {
    my ($timestamp_obj, $windows_aref, $hint_idx) = @_; 
    my $timestamp_day_obj = $timestamp_obj->truncate(to => 'day');
    if (defined $hint_idx && $hint_idx < @{$windows_aref}) {
        my ($win_start, $win_end) = @{$windows_aref->[$hint_idx]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end) { return $windows_aref->[$hint_idx][2]->ymd('') . "_" . $hint_idx; }
    }
    for (my $i=0; $i < @{$windows_aref}; $i++) {
        my ($win_start, $win_end) = @{$windows_aref->[$i]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end) { return $windows_aref->[$i][2]->ymd('') . "_" . $i; }
    }
    return undef; 
}

sub process_and_store_window_results {
    my ($window_def_ref, $current_vm_win_buf_href, $vm_overall_win_data_href, 
        $all_vm_names_aref, $target_vm_idx_nullable, $target_vm_name_nullable,
        $main_physc_percentile_arg, $calc_peak_arg, $has_runq_data_arg, 
        $runq_norm_p_aref_arg, $runq_abs_p_aref_arg) = @_; # Added _arg suffix

    my ($win_start, $win_end, $win_rep_date) = @{$window_def_ref};
    my $win_idx = -1;
    for (my $i=0; $i < @processing_windows; $i++) { if ($processing_windows[$i][2]->epoch == $win_rep_date->epoch) { $win_idx = $i; last; }}
    return unless $win_idx != -1; 
    my $window_key = $win_rep_date->ymd('') . "_" . $win_idx;

    my @vms_to_process_this_window_list; 
    if (defined $target_vm_idx_nullable) { push @vms_to_process_this_window_list, $target_vm_name_nullable; }
    else { @vms_to_process_this_window_list = @{$all_vm_names_aref}; }

    foreach my $vm_name (@vms_to_process_this_window_list) {
        next unless exists $current_vm_win_buf_href->{$vm_name}{$window_key};
        my $vm_win_data = $current_vm_win_buf_href->{$vm_name}{$window_key};

        my $p_label_main = sprintf("P%.2f", $main_physc_percentile_arg); $p_label_main =~ s/\.?0+$//; $p_label_main = "0" if $p_label_main eq "" && abs($main_physc_percentile_arg-0)<0.001;
        $p_label_main = "P$p_label_main" unless $p_label_main =~ /^P/;

        if (exists $vm_win_data->{rolling_physc_avgs} && @{$vm_win_data->{rolling_physc_avgs}}) {
            my @sorted_physc_avgs = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{rolling_physc_avgs}}; 
            if (@sorted_physc_avgs) {
                my $physc_perc_val = calculate_percentile(\@sorted_physc_avgs, $main_physc_percentile_arg); 
                $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = defined($physc_perc_val) ? $physc_perc_val : "N/A";
            } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = "N/A"; }
        } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = "N/A"; }

        if ($calc_peak_arg) {
            if (exists $vm_win_data->{raw_physc_for_peak} && @{$vm_win_data->{raw_physc_for_peak}}) {
                my @defined_peaks = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{raw_physc_for_peak}};
                $vm_overall_win_data_href->{$vm_name}{$window_key}{'Peak'} = @defined_peaks ? max(@defined_peaks) : "N/A";
            } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{'Peak'} = "N/A"; }
        }
        if ($has_runq_data_arg) {
            foreach my $p_val (@{$runq_norm_p_aref_arg}) {
                my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && abs($p_val-0)<0.001;
                my $metric_key = "NormRunQ_$p_lbl";
                if (exists $vm_win_data->{norm_rq_vals} && @{$vm_win_data->{norm_rq_vals}}) {
                    my @sorted_vals = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{norm_rq_vals}};
                    if(@sorted_vals){ my $val = calculate_percentile(\@sorted_vals, $p_val); $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A"; }
                    else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A"; }
                } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A"; }
            }
            foreach my $p_val (@{$runq_abs_p_aref_arg}) {
                my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && abs($p_val-0)<0.001;
                my $metric_key = "AbsRunQ_$p_lbl";
                if (exists $vm_win_data->{abs_rq_vals} && @{$vm_win_data->{abs_rq_vals}}) {
                    my @sorted_vals = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{abs_rq_vals}};
                    if(@sorted_vals) { my $val = calculate_percentile(\@sorted_vals, $p_val); $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A"; }
                    else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A"; }
                } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A"; }
            }
        }
    }
}

sub calculate_recency_weighted_average {
    my ($windowed_data_ref, $analysis_ref_obj_arg, $half_life_days_arg) = @_; 
    my $sum_weighted_values = 0; my $sum_weights = 0;
    return "N/A" if (!defined $analysis_ref_obj_arg || !$analysis_ref_obj_arg->isa('Time::Piece'));
    return "N/A" if (!defined $half_life_days_arg || $half_life_days_arg <= 0); 
    my $lambda = log(2) / $half_life_days_arg; 
    foreach my $dp_ref (@{$windowed_data_ref}) {
        my $value_str = $dp_ref->{value};
        next if (!defined $value_str || $value_str eq "N/A" || $value_str !~ /^-?[0-9.]+$/);
        my $value = $value_str + 0;
        my $date_obj = $dp_ref->{date};
        next if (!defined $date_obj || !$date_obj->isa('Time::Piece')); 
        my $date_obj_day = $date_obj->truncate(to => 'day');
        my $analysis_ref_day = $analysis_ref_obj_arg->truncate(to => 'day');
        my $days_diff_seconds = $analysis_ref_day->epoch - $date_obj_day->epoch;
        my $days_diff = $days_diff_seconds / ONE_DAY(); 
        $days_diff = 0 if $days_diff < 0; 
        my $weight = exp(-$lambda * $days_diff);
        $sum_weighted_values += $value * $weight;
        $sum_weights += $weight;
    }
    if ($sum_weights > 1e-9) { 
        return sprintf("%.4f", $sum_weighted_values / $sum_weights); 
    } else { return "N/A"; }
}

sub get_vm_index_by_name { 
    my ($vm_name_to_find, $vm_names_list_ref) = @_;
    for (my $i=0; $i < @{$vm_names_list_ref}; $i++) {
        if ($vm_names_list_ref->[$i] eq $vm_name_to_find) {
            return $i;
        }
    }
    return undef;
}

sub calculate_average { my @values = @_; my @defined_values = grep { defined($_) && $_ ne '' && $_ =~ /^-?[0-9.]+$/ } @values; my $count = scalar @defined_values; return undef if $count == 0; my $sum = sum0(@defined_values); return $sum / $count; }
sub calculate_percentile { my ($sorted_data_ref, $p) = @_; unless (defined $sorted_data_ref && ref $sorted_data_ref eq 'ARRAY') { print STDERR "Warning: Invalid data reference passed to calculate_percentile\n"; return undef; } my @data = @{$sorted_data_ref}; my $n = scalar @data; return undef if $n == 0; return $data[0] if $n == 1; @data = grep { defined($_) && $_ =~ /^-?[0-9]+(?:\.[0-9]+)?$/ } @data; $n = scalar @data; return undef if $n == 0; @data = sort { $a <=> $b } @data; my $rank_fractional = ($p / 100) * ($n - 1); my $k = int($rank_fractional); my $d = $rank_fractional - $k; if ($p == 0) { return $data[0]; } if ($p == 100) { return $data[$n-1]; } if ($k >= $n - 1) { return $data[$n - 1]; } elsif ($k < 0) { return $data[0]; } else { my $val_k = $data[$k]; my $val_k_plus_1 = ($k + 1 < $n) ? $data[$k + 1] : $data[$k]; return $val_k + $d * ($val_k_plus_1 - $val_k); }}
sub apply_rounding { my ($value, $increment, $method) = @_; return $value unless (defined $value && $value =~ /^-?[0-9]+(?:\.[0-9]+)?$/); return $value if $method eq 'none' || !defined $increment || $increment <= $FLOAT_EPSILON; my $rounded_value; if ($method eq 'standard') { $rounded_value = int( ($value / $increment) + ( ($value >= 0) ? 0.5 : -0.5) ) * $increment; } elsif ($method eq 'up') { $rounded_value = ceil( $value / $increment ) * $increment; } else { $rounded_value = $value; } return $rounded_value; }
sub get_decimal_places { my ($number_str) = @_; $number_str = sprintf("%.15f", $number_str) if ($number_str =~ /e/i); if ($number_str =~ /\.(\d+)$/) { return length($1); } else { return 0; }}

sub get_weighted_metric_for_vm {
    my ($vm_data_by_window_href, $vm_name, $metric_key, 
        $processing_windows_aref, $analysis_ref_obj_arg, $decay_hl_days_arg, $sprintf_fmt_optional) = @_;

    my @metric_window_values;
    if (exists $vm_data_by_window_href->{$vm_name}) {
        foreach my $win_key (sort keys %{$vm_data_by_window_href->{$vm_name}}) {
            # Ensure the metric_key exists for this window and VM
            if (exists $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} && 
                defined $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} &&
                $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} ne "N/A" ) {
                
                # The window_key is YYYYMMDD_index. We need the index to get the Time::Piece object.
                my ($win_date_str_part, $win_idx_part) = ($win_key =~ /^(\d{8})_(\d+)$/);

                if (defined $win_idx_part && $win_idx_part < @{$processing_windows_aref}) {
                    # $processing_windows_aref structure: [ [start_obj, end_obj, representative_obj], ... ]
                    my $rep_date_obj = $processing_windows_aref->[$win_idx_part][2]; # Get Time::Piece obj for date
                    
                    unless (defined $rep_date_obj && $rep_date_obj->isa('Time::Piece')) {
                        # This should not happen if @processing_windows is correctly populated
                        print STDERR "Warning: Representative date for window key '$win_key' is invalid for VM '$vm_name', metric '$metric_key'. Skipping this window point.\n";
                        next;
                    }

                    push @metric_window_values, { 
                        value => $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key}, 
                        date  => $rep_date_obj
                    };
                } else {
                    # This indicates a mismatch between generated window_keys and the @processing_windows array
                    print STDERR "Warning: Could not accurately map window key '$win_key' to a processing window definition for VM '$vm_name', metric '$metric_key'. Skipping this window point.\n";
                }
            }
        }
    }

    if (@metric_window_values) {
        my $weighted_val_str = calculate_recency_weighted_average( # Ensure this sub also returns string "N/A" or formatted number
            \@metric_window_values, $analysis_ref_obj_arg, $decay_hl_days_arg
        );
        
        if (defined $sprintf_fmt_optional && defined $weighted_val_str && $weighted_val_str ne "N/A" && $weighted_val_str =~ /^-?[0-9.]+$/) {
            return sprintf($sprintf_fmt_optional, $weighted_val_str + 0); # Convert to num before sprintf
        }
        return $weighted_val_str; # Already formatted to 4dp or is "N/A" string
    }
    return "N/A"; # Default if no values found
}

sub usage { my $script_name = $0; $script_name =~ s{.*/}{}; my $valid_decays_usage = join("|", sort keys %EMA_ALPHAS);
    return <<END_USAGE;
Usage: $script_name --physc-data <file> [options]

Analyses NMON PhysC and optionally RunQ data.
If --enable-windowed-decay is used, applies recency weighting to windowed results.

Core Input & Averaging Method (used within each window if decay enabled):
  --physc-data, -pc <file> : Path to input CSV file with PhysC data (required).
  --avg-method <method>    : Averaging method for PhysC: 'sma' or 'ema'. (Default: $DEFAULT_AVG_METHOD)
  --decay <level>          : If 'ema', specifies decay level: $valid_decays_usage. (Default: $DEFAULT_DECAY_LEVEL)
  -w, --window <minutes>     : Window for SMA/EMA rolling average calculation. (Default: $DEFAULT_WINDOW_MINUTES min).

RunQ Data Input (Optional):
  --runq-data, -rq <file>  : Path to input CSV file with RunQ data.
  --smt <N>                : SMT level for RunQ normalisation (Default: $DEFAULT_SMT).
  --runq-norm-perc <list>  : Comma-separated percentiles for Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERC").
  --runq-abs-perc <list>   : Comma-separated percentiles for Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERC").

Filtering Options (Applied BEFORE windowing if decay enabled):
  -s, --startdate <YYYY-MM-DD> : Ignore data before this date (overall filter).
  -ed, --enddate <YYYY-MM-DD>  : Ignore data after this date (overall filter).
  -startt <HH:MM> / -endt <HH:MM> : Daily time filter.
  -online / -batch           : Shortcut daily time filters.
  -no-weekends               : Exclude data from Saturdays and Sundays.
  -vm, --lpar <name>         : Analyse only the specified VM/LPAR name.

PhysC Calculation Options:
  -p, --percentile <value>   : Final percentile of PhysC (0-100) (Default: $DEFAULT_PERCENTILE).
                               If windowed decay, this is the percentile calculated per window.
  -k, --peak                 : Calculate peak PhysC value. (If windowed, weighted peak of window peaks).
  --filter-above-perc <N>    : Optional. Filter rolling PhysC values before PXX calc. (Applied per window if decay enabled).

Windowed Recency Decay (Optional - nfit performs all windowing internally):
  --enable-windowed-decay     : Enable internal windowed processing with recency decay.
  --process-window-unit <days|weeks> : Unit for processing window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT).
  --process-window-size <N>   : Size of each window in specified units (Default: $DEFAULT_PROCESS_WINDOW_SIZE).
  --decay-half-life-days <N>  : Half-life in days for recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS).
  --analysis-reference-date <YYYY-MM-DD> : "Current" date for recency calculation
                                (Default: Date of last record in filtered NMON PhysC data).
Rounding Options:
  -r[=increment] / -u[=increment] : Round results (Default increment: $DEFAULT_ROUND_INCREMENT).

Other:
  -h, --help                 : Display this help message.
  -v, --version              : Display script version.
END_USAGE
}
