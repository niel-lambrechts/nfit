#!/usr/bin/env perl

# NAME     : nfit
# VERSION  : 2.25.147.0 # User provided version, will be updated upon release
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Analyse NMON PhysC and optionally RunQ data for AIX and Linux on Power
#            VM right-sizing recommendations. Calculates rolling average (SMA or EMA)
#            percentiles, optionally absolute peaks, and specified percentiles of
#            normalised and absolute run-queue statistics.
#            Supports filtering by date, time, VM, weekends, and percentile threshold,
#            plus rounding options.
# REQUIRES : Perl, Time::Piece, POSIX (for ceil), List::Util (for sum0), Getopt::Long, File::Temp

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Temp qw(tempfile);
use List::Util qw(sum0);
use POSIX qw(ceil);
use Time::Piece;

# --- Version ---
my $VERSION = '2.25.147.0'; # Will reflect updates if this version changes behaviour

# --- Configuration ---
my $DEFAULT_AVG_METHOD     = 'ema';
my $DEFAULT_DECAY_LEVEL    = 'medium';
my $DEFAULT_WINDOW_MINUTES = 15;
my $DEFAULT_PERCENTILE     = 95;
my $DEFAULT_ROUND_INCREMENT= 0.05;
my $DEFAULT_SMT            = 8;
my $DEFAULT_RUNQ_NORM_PERC = "50,90";
my $DEFAULT_RUNQ_ABS_PERC  = "90";
my $FLOAT_EPSILON          = 1e-9;
my $ACTIVE_PHYSC_THRESHOLD = 0.05;

# EMA Alpha values based on decay level
my %EMA_ALPHAS = (
    'low'        => 0.03, # Very conservative smoothing
    'medium'     => 0.08, # Balanced, still conservative
    'high'       => 0.15, # Gently responsive
    'extreme'    => 0.30, # Strong recent bias
    'very-high'  => 0.30, # Alias for extreme
);

# --- Argument Parsing ---
my $physc_csv_file;
my $runq_csv_file;
my $avg_method     = $DEFAULT_AVG_METHOD;
my $decay_level    = $DEFAULT_DECAY_LEVEL;
my $window_minutes = $DEFAULT_WINDOW_MINUTES;
my $percentile     = $DEFAULT_PERCENTILE;
my $start_date_str;
my $calculate_peak = 0;
my $round_arg;
my $roundup_arg;
my $start_time_str;
my $end_time_str;
my $online_flag = 0;
my $batch_flag  = 0;
my $target_vm_name;
my $no_weekends = 0;
my $filter_above_perc_value = undef;
my $smt_value = $DEFAULT_SMT;
my $runq_norm_perc_str = $DEFAULT_RUNQ_NORM_PERC;
my $runq_abs_perc_str  = $DEFAULT_RUNQ_ABS_PERC;
my $help           = 0;
my $show_version   = 0;

GetOptions(
    'physc-data|pc=s'     => \$physc_csv_file,
    'runq-data|rq=s'      => \$runq_csv_file,
    'avg-method=s'        => \$avg_method,
    'decay=s'             => \$decay_level,
    'window|w=i'          => \$window_minutes,
    'percentile|p=f'      => \$percentile,
    'startdate|s=s'       => \$start_date_str,
    'peak|k'              => \$calculate_peak,
    'round|r:f'           => \$round_arg,
    'roundup|u:f'         => \$roundup_arg,
    'startt=s'            => \$start_time_str,
    'endt=s'              => \$end_time_str,
    'online'              => \$online_flag,
    'batch'               => \$batch_flag,
    'vm|lpar=s'           => \$target_vm_name,
    'no-weekends'         => \$no_weekends,
    'filter-above-perc=f' => \$filter_above_perc_value,
    'smt=i'               => \$smt_value,
    'runq-norm-perc=s'    => \$runq_norm_perc_str,
    'runq-abs-perc=s'     => \$runq_abs_perc_str,
    'help|h'              => \$help,
    'version|v'           => \$show_version,
) or die usage();

# --- Validation ---
if ($show_version) {
    print STDERR "nfit version $VERSION\n";
    exit 0;
}
if ($help || !$physc_csv_file) {
    print STDERR usage();
    exit 0;
}

$avg_method = lc($avg_method);
if ($avg_method ne 'sma' && $avg_method ne 'ema') {
    die "Error: --avg-method must be 'sma' or 'ema'. Got '$avg_method'.\n";
}
$decay_level = lc($decay_level);
if ($avg_method eq 'ema' && !exists $EMA_ALPHAS{$decay_level}) {
    my $valid_decays = join(", ", sort keys %EMA_ALPHAS);
    die "Error: --decay level '$decay_level' is invalid for EMA. Valid levels are: $valid_decays.\n";
}

if (! -f $physc_csv_file) {
    die "Error: PhysC data file (--physc-data) not found: $physc_csv_file\n";
}
if (defined $runq_csv_file && ! -f $runq_csv_file) {
    die "Error: RunQ data file (--runq-data) not found: $runq_csv_file\n";
}
if ($smt_value <= 0) {
    die "Error: --smt value must be a positive integer.\n";
}
if ($window_minutes < 1) {
    die "Error: Window size (-w) must be at least 1 minute.\n";
}
if ($percentile < 0 || $percentile > 100) {
    die "Error: Percentile (-p) must be between 0 and 100.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/) {
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}
if (defined($round_arg) && defined($roundup_arg)) {
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $round_arg && length $round_arg && $round_arg !~ /^[0-9.]*$/) {
    die "Error: Invalid value for -r increment: '$round_arg'\n";
}
if (defined $roundup_arg && length $roundup_arg && $roundup_arg !~ /^[0-9.]*$/) {
    die "Error: Invalid value for -u increment: '$roundup_arg'\n";
}
if (($online_flag || $batch_flag) && (defined $start_time_str || defined $end_time_str)) {
    die "Error: Cannot use -online or -batch with -startt or -endt.\n";
}
if ($online_flag && $batch_flag) {
    die "Error: Cannot use -online and -batch together.\n";
}
if ((defined $start_time_str && !defined $end_time_str) || (!defined $start_time_str && defined $end_time_str)) {
    die "Error: Must specify both -startt and -endt.\n";
}
if (defined $start_time_str && $start_time_str !~ /^\d{2}:\d{2}$/) {
    die "Error: Invalid startt format '$start_time_str'. Use HH:MM.\n";
}
if (defined $end_time_str && $end_time_str !~ /^\d{2}:\d{2}$/) {
    die "Error: Invalid endt format '$end_time_str'. Use HH:MM.\n";
}
if (defined $filter_above_perc_value && ($filter_above_perc_value < 0 || $filter_above_perc_value > 100)) {
    die "Error: --filter-above-perc value must be between 0 and 100.\n";
}

my @runq_norm_percentiles_to_calc = parse_percentile_list($runq_norm_perc_str, "runq-norm-perc");
my @runq_abs_percentiles_to_calc  = parse_percentile_list($runq_abs_perc_str,  "runq-abs-perc");

# --- Determine Rounding Method and Increment ---
my $rounding_method = 'none';
my $round_increment = undef;
my $output_dp = 4; # Default decimal places for PhysC results
if (defined $round_arg) {
    $rounding_method = 'standard';
    $round_increment = (length $round_arg && $round_arg =~ /^[0-9.]*$/) ? $round_arg : $DEFAULT_ROUND_INCREMENT;
    print STDERR "Applying standard rounding to nearest $round_increment\n";
}
elsif (defined $roundup_arg) {
    $rounding_method = 'up';
    $round_increment = (length $roundup_arg && $roundup_arg =~ /^[0-9.]*$/) ? $roundup_arg : $DEFAULT_ROUND_INCREMENT;
    print STDERR "Applying ceiling rounding up to nearest $round_increment\n";
}
if ($rounding_method ne 'none') {
    if (!defined $round_increment || $round_increment <= 0) {
        die "Error: Rounding increment must be positive (got '$round_increment').\n";
    }
    $output_dp = get_decimal_places($round_increment);
}

# --- Determine Time Filter Window ---
my $time_filter_active = 0;
my $time_filter_start = undef;
my $time_filter_end = undef;
my $time_filter_overnight = 0;
my $time_filter_desc = "";
if ($online_flag) {
    $time_filter_active = 1; $time_filter_start = "08:00"; $time_filter_end = "17:00";
    $time_filter_desc = "ONLINE ($time_filter_start <= time < $time_filter_end)";
}
elsif ($batch_flag) {
    $time_filter_active = 1; $time_filter_start = "18:00"; $time_filter_end = "06:00"; $time_filter_overnight = 1;
    $time_filter_desc = "BATCH (time >= $time_filter_start OR time < $time_filter_end)";
}
elsif (defined $start_time_str) {
    $time_filter_active = 1; $time_filter_start = $start_time_str; $time_filter_end = $end_time_str;
    if ($time_filter_end lt $time_filter_start) {
        $time_filter_overnight = 1; $time_filter_desc = "OVERNIGHT (time >= $time_filter_start OR time < $time_filter_end)";
    } else {
        $time_filter_desc = "MANUAL ($time_filter_start <= time < $time_filter_end)";
    }
}

# --- Main Processing ---
my $start_time = time();
print STDERR "nfit version $VERSION\n";
print STDERR "Processing PhysC data from: $physc_csv_file\n";
my $alpha_for_ema = undef; # Will be set if EMA method is chosen
if ($avg_method eq 'ema') {
    $alpha_for_ema = $EMA_ALPHAS{$decay_level};
    print STDERR "Using EMA for PhysC rolling average (decay: $decay_level, alpha: $alpha_for_ema).\n";
    print STDERR "Conceptual window for EMA start trigger: $window_minutes minutes.\n";
} else {
    print STDERR "Using SMA for PhysC rolling average with window: $window_minutes minutes.\n";
}
if (defined $runq_csv_file) {
    print STDERR "Processing RunQ data from: $runq_csv_file (using SMT: $smt_value for normalisation)\n";
    print STDERR "Calculating Normalised RunQ Percentiles: " . join(", ", map {"P$_"} @runq_norm_percentiles_to_calc) . "\n" if @runq_norm_percentiles_to_calc;
    print STDERR "Calculating Absolute RunQ Percentiles: " . join(", ", map {"P$_"} @runq_abs_percentiles_to_calc) . "\n" if @runq_abs_percentiles_to_calc;
}
my $p_label_display = sprintf("P%.2f", $percentile); $p_label_display =~ s/\.?0+$//; $p_label_display = "0" if $p_label_display eq "" && $percentile == 0;
print STDERR "Calculating PhysC percentile: $p_label_display\n";
print STDERR "Calculating absolute PhysC peak: " . ($calculate_peak ? "Yes" : "No") . "\n";
if (defined $start_date_str) { print STDERR "Ignoring data before start date: $start_date_str\n"; }
if ($no_weekends) { print STDERR "Applying filter: Excluding Weekends (Sat/Sun)\n"; }
if ($time_filter_active) { print STDERR "Applying time filter: $time_filter_desc\n"; }
if (defined $filter_above_perc_value) { my $filter_p_label = sprintf("P%.2f", $filter_above_perc_value); $filter_p_label =~ s/\.?0+$//; $filter_p_label = "0" if $filter_p_label eq "" && $filter_above_perc_value == 0; print STDERR "Applying PhysC percentile filter: Using rolling averages >= $filter_p_label of all rolling averages\n"; }
if (defined $target_vm_name) { print STDERR "Filtering for VM/LPAR: $target_vm_name\n"; }

# --- Initialization ---
my @vm_names_from_physc_header;
my $target_vm_index_in_physc = undef;

my @vm_physc_avg_temp_windows_list_of_arefs; # Holds recent points for SMA, or just acts as counter for EMA start
my $vm_physc_avg_temp_window_aref;
my @vm_physc_previous_ema_list; # Stores previous EMA value for each VM
my $vm_physc_previous_ema_scalar;

my @vm_physc_max_peaks_list;
my $vm_physc_max_peak_scalar = undef;
my @temp_fh_physc_list;
my $temp_fh_physc_scalar;
my @temp_filenames_physc_list;
my $temp_filename_physc_scalar;

my %runq_data_store;
my @vm_collected_norm_runq_values_list_of_arefs;
my $vm_collected_norm_runq_values_aref;
my @vm_collected_abs_runq_values_list_of_arefs;
my $vm_collected_abs_runq_values_aref;

my $line_count = 0;
my $data_lines_processed = 0;

# --- Load RunQ Data (if provided) ---
if (defined $runq_csv_file) {
    # (Logic formatted with OTBS and multi-line bodies)
    print STDERR "Pre-loading RunQ data...\n";
    open my $runq_fh, '<:encoding(utf8)', $runq_csv_file or die "Error: Cannot open RunQ CSV file '$runq_csv_file': $!\n";
    my $runq_line_count = 0;
    my @runq_vm_names_header;
    while (my $line = <$runq_fh>) {
        chomp $line; $line =~ s/\r$//; $runq_line_count++;
        next if ($line =~ /^\s*$/o);
        $line =~ s/^\x{FEFF}// if $runq_line_count == 1;
        my @fields = split /,/, $line, -1;

        if ($runq_line_count == 1) {
            shift @fields; # Remove "Time"
            @runq_vm_names_header = map { my ($name) = split / /; $name =~ s/^"|"$//g; $name } @fields;
            if (defined $target_vm_name && !grep { $_ eq $target_vm_name } @runq_vm_names_header) {
                print STDERR "Warning: Target VM '$target_vm_name' not found in RunQ CSV header. RunQ metrics for it will be N/A.\n";
            }
            next;
        }
        my $timestamp_str = $fields[0];
        shift @fields;
        for (my $i = 0; $i <= $#fields; $i++) {
            my $vm_name = $runq_vm_names_header[$i];
            next unless (defined $vm_name && $vm_name ne '');
            if (!defined $target_vm_name || $vm_name eq $target_vm_name) {
                if (defined $fields[$i] && $fields[$i] =~ /^[0-9.]+$/) {
                    $runq_data_store{$vm_name}{$timestamp_str} = $fields[$i];
                }
            }
        }
    }
    close $runq_fh;
    print STDERR "Finished pre-loading RunQ data for " . scalar(keys %runq_data_store) . " VMs from $runq_line_count lines.\n";
}

# --- Process PhysC Data (Main Loop) ---
print STDERR "Processing PhysC data and calculating metrics...\n";
open my $physc_csv_fh, '<:encoding(utf8)', $physc_csv_file or die "Error: Cannot open PhysC CSV file '$physc_csv_file': $!\n";

while (my $line = <$physc_csv_fh>) {
    chomp $line; $line =~ s/\r$//; $line_count++;
    next if ($line =~ /^\s*$/o);
    $line =~ s/^\x{FEFF}// if $line_count == 1;
    my @fields = split /,/, $line, -1;

    if ($line_count == 1) { # PhysC Header
        shift @fields; my $num_vms_found = 0; my $current_index = 0;
        foreach my $header_field (@fields) {
            $header_field =~ s/^\s+|\s+$//g; $header_field =~ s/^"|"$//g;
            my ($vm_name) = split / /, $header_field, 2;
            if (defined $vm_name && $vm_name ne '') {
                push @vm_names_from_physc_header, $vm_name;
                if (defined $target_vm_name && $vm_name eq $target_vm_name) { $target_vm_index_in_physc = $current_index; }
                $num_vms_found++;
            } else {
                print STDERR "Warning: Could not extract VM name from PhysC header index $current_index: '$header_field'\n";
                push @vm_names_from_physc_header, "UNKNOWN_VM_PHYSC_$current_index";
            }
            $current_index++;
        }
        my $num_vms = scalar(@vm_names_from_physc_header);
        if ($num_vms == 0) { die "Error: No valid VM columns found in PhysC header.\n"; }
        print STDERR "Found $num_vms VMs in PhysC header.\n";
        if (defined $target_vm_name && !defined $target_vm_index_in_physc) {
             my $avail_vms = join(", ", @vm_names_from_physc_header); $avail_vms = substr($avail_vms, 0, 200) . "..." if length($avail_vms) > 200;
             die "Error: Target VM '$target_vm_name' not found in PhysC CSV header.\nAvailable VMs: $avail_vms\n";
        }

        if (defined $target_vm_index_in_physc) {
            $vm_physc_avg_temp_window_aref = []; $vm_physc_max_peak_scalar = undef;
            my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file: $!\n"; }
            $temp_fh_physc_scalar = $fh; $temp_filename_physc_scalar = $fname;
            if (defined $runq_csv_file) { $vm_collected_norm_runq_values_aref = []; $vm_collected_abs_runq_values_aref = []; }
            $vm_physc_previous_ema_scalar = undef; # For EMA
        } else {
            for (my $i = 0; $i < $num_vms; $i++) {
                $vm_physc_avg_temp_windows_list_of_arefs[$i] = []; $vm_physc_max_peaks_list[$i] = undef;
                my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file for $vm_names_from_physc_header[$i]: $!\n"; }
                $temp_fh_physc_list[$i] = $fh; $temp_filenames_physc_list[$i] = $fname;
                if (defined $runq_csv_file) { $vm_collected_norm_runq_values_list_of_arefs[$i] = []; $vm_collected_abs_runq_values_list_of_arefs[$i] = []; }
                $vm_physc_previous_ema_list[$i] = undef; # For EMA
            }
        }
        next;
    }
    my $timestamp_str = $fields[0];
    my $tp;
    eval { $tp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S"); };
    if ($@ || !defined $tp) { print STDERR "Warning: Could not parse timestamp '$timestamp_str' line $line_count. Skipping.\n"; next; }

    if (defined $start_date_str) { if ($tp->ymd('-') lt $start_date_str) { next; } }
    if ($no_weekends) { my $day_of_week = $tp->day_of_week; if ($day_of_week == 1 || $day_of_week == 7) { next; } }
    if ($time_filter_active) {
        my $line_time = substr($tp->hms(':'), 0, 5); my $include_line = 0;
        if ($time_filter_overnight) { if ($line_time ge $time_filter_start || $line_time lt $time_filter_end) { $include_line = 1; } }
        else { if ($line_time ge $time_filter_start && $line_time lt $time_filter_end) { $include_line = 1; } }
        unless ($include_line) { next; }
    }

    $data_lines_processed++;
    shift @fields;
    my $num_data_fields = scalar @fields;
    my $num_header_vms = scalar @vm_names_from_physc_header;
    if ($num_data_fields != $num_header_vms) { print STDERR "Warning: Line $line_count PhysC field count mismatch ($num_data_fields vs $num_header_vms). Skipping.\n"; next; }

    if (defined $target_vm_index_in_physc) {
        my $i = $target_vm_index_in_physc;
        my $current_vm_name = $target_vm_name;
        my $physc_value_str = defined $fields[$i] ? $fields[$i] : '';
        my $physc_value;
        if ($physc_value_str =~ /^\s*([0-9.]+)\s*$/) { $physc_value = $1; } else { $physc_value = undef; }

        if ($calculate_peak && defined $physc_value) {
            if (!defined($vm_physc_max_peak_scalar) || $physc_value > $vm_physc_max_peak_scalar) { $vm_physc_max_peak_scalar = $physc_value; }
        }
        
        my $current_avg_output_value; # This will hold SMA or EMA
        if ($avg_method eq 'sma') {
            push @{ $vm_physc_avg_temp_window_aref }, $physc_value;
            shift @{ $vm_physc_avg_temp_window_aref } while scalar @{ $vm_physc_avg_temp_window_aref } > $window_minutes;
            if (scalar @{ $vm_physc_avg_temp_window_aref } == $window_minutes) {
                $current_avg_output_value = calculate_average(@{ $vm_physc_avg_temp_window_aref });
            }
        } else { # EMA
            if (defined $physc_value) {
                if (!defined $vm_physc_previous_ema_scalar) { # Seed EMA with first valid point
                    $vm_physc_previous_ema_scalar = $physc_value;
                } else {
                    $vm_physc_previous_ema_scalar = ($physc_value * $alpha_for_ema) + ($vm_physc_previous_ema_scalar * (1 - $alpha_for_ema));
                }
                # To keep EMA output count similar to SMA (for consistent # of points for percentile)
                # we conceptually wait for 'window_minutes' of data to have been processed before outputting EMA
                push @{ $vm_physc_avg_temp_window_aref }, $physc_value; # Use this as a counter
                shift @{ $vm_physc_avg_temp_window_aref } while scalar @{ $vm_physc_avg_temp_window_aref } > $window_minutes;
                if (scalar @{ $vm_physc_avg_temp_window_aref } == $window_minutes) {
                    $current_avg_output_value = $vm_physc_previous_ema_scalar;
                }
            } else { # physc_value is undef for EMA
                 push @{ $vm_physc_avg_temp_window_aref }, undef; # Still manage counter
                 shift @{ $vm_physc_avg_temp_window_aref } while scalar @{ $vm_physc_avg_temp_window_aref } > $window_minutes;
                 # No EMA point generated if current PhysC is undef, previous EMA value is held
            }
        }
        if (defined $current_avg_output_value) {
            print { $temp_fh_physc_scalar } "$current_avg_output_value\n" or die "Error writing PhysC temp file for $current_vm_name: $!";
        }

        if (defined $runq_csv_file && defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
            if (exists $runq_data_store{$current_vm_name}{$timestamp_str}) {
                my $runq_value = $runq_data_store{$current_vm_name}{$timestamp_str};
                push @{$vm_collected_abs_runq_values_aref}, $runq_value;
                my $effective_lcpus = $physc_value * $smt_value;
                if ($effective_lcpus > $FLOAT_EPSILON) {
                    my $norm_runq = $runq_value / $effective_lcpus;
                    push @{$vm_collected_norm_runq_values_aref}, $norm_runq;
                }
            }
        }
    } else { # Process all VMs
        for (my $i = 0; $i < $num_header_vms; $i++) {
            my $current_vm_name = $vm_names_from_physc_header[$i];
            my $physc_value_str = defined $fields[$i] ? $fields[$i] : '';
            my $physc_value;
            if ($physc_value_str =~ /^\s*([0-9.]+)\s*$/) { $physc_value = $1; } else { $physc_value = undef; }

            if ($calculate_peak && defined $physc_value) {
                if (!defined($vm_physc_max_peaks_list[$i]) || $physc_value > $vm_physc_max_peaks_list[$i]) { $vm_physc_max_peaks_list[$i] = $physc_value; }
            }

            my $current_avg_output_value_all;
            if ($avg_method eq 'sma') {
                push @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] }, $physc_value;
                shift @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } while scalar @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } > $window_minutes;
                if (scalar @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } == $window_minutes) {
                    $current_avg_output_value_all = calculate_average(@{ $vm_physc_avg_temp_windows_list_of_arefs[$i] });
                }
            } else { # EMA
                if (defined $physc_value) {
                    if (!defined $vm_physc_previous_ema_list[$i]) { $vm_physc_previous_ema_list[$i] = $physc_value; }
                    else { $vm_physc_previous_ema_list[$i] = ($physc_value * $alpha_for_ema) + ($vm_physc_previous_ema_list[$i] * (1 - $alpha_for_ema)); }
                    push @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] }, $physc_value; # Used as counter
                    shift @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } while scalar @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } > $window_minutes;
                    if (scalar @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } == $window_minutes) {
                        $current_avg_output_value_all = $vm_physc_previous_ema_list[$i];
                    }
                } else {
                    push @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] }, undef;
                    shift @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } while scalar @{ $vm_physc_avg_temp_windows_list_of_arefs[$i] } > $window_minutes;
                }
            }
            if (defined $current_avg_output_value_all) {
                print { $temp_fh_physc_list[$i] } "$current_avg_output_value_all\n" or die "Error writing PhysC temp file for $current_vm_name: $!";
            }

            if (defined $runq_csv_file && defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
                if (exists $runq_data_store{$current_vm_name}{$timestamp_str}) {
                    my $runq_value = $runq_data_store{$current_vm_name}{$timestamp_str};
                    push @{$vm_collected_abs_runq_values_list_of_arefs[$i]}, $runq_value;
                    my $effective_lcpus = $physc_value * $smt_value;
                    if ($effective_lcpus > $FLOAT_EPSILON) {
                        my $norm_runq = $runq_value / $effective_lcpus;
                        push @{$vm_collected_norm_runq_values_list_of_arefs[$i]}, $norm_runq;
                    }
                }
            }
        }
    }
    if ($data_lines_processed > 0 && $data_lines_processed % 10000 == 0) {
        print STDERR "Processed $data_lines_processed data lines (matching filters)...\n";
    }
}
# --- Close Files ---
close $physc_csv_fh;
print STDERR "Finished reading $line_count total lines from PhysC file.\n";
print STDERR "Processed $data_lines_processed data lines matching filters.\n";
print STDERR "Closing PhysC temporary files...\n";
if (defined $target_vm_index_in_physc) {
    if (defined $temp_fh_physc_scalar) { close $temp_fh_physc_scalar or warn "Warning: Could not close PhysC temp file handle: $!"; }
} else {
    foreach my $fh (@temp_fh_physc_list) {
        if (defined $fh) { close $fh or warn "Warning: Could not close PhysC temp file handle: $!"; }
    }
}

# --- Calculate Percentiles and Format Output ---
print STDERR "Calculating final results...\n";
my @results_data;

if (defined $target_vm_index_in_physc) {
    my $vm_name = $target_vm_name;
    my $temp_file_physc_path = $temp_filename_physc_scalar; # Use correct variable
    my @physc_avg_values_from_file;
    my $percentile_val_raw = undef;
    my $peak_val_raw = $vm_physc_max_peak_scalar;
    my %runq_percentile_results;

    if (! -f $temp_file_physc_path || ! -s $temp_file_physc_path) {
        print STDERR "Warning: PhysC Temp file '$temp_file_physc_path' for VM '$vm_name' empty/missing. Skip percentile.\n" if -e $temp_file_physc_path;
        unlink $temp_file_physc_path or warn "Warning: Del '$temp_file_physc_path': $!" if -e $temp_file_physc_path;
    } else {
        open my $in_fh, '<', $temp_file_physc_path or die "Error opening PhysC temp file $temp_file_physc_path: $!";
        while (my $num = <$in_fh>) { chomp $num; if ($num =~ /^-?[0-9]+(?:\.[0-9]+)?$/) { push @physc_avg_values_from_file, $num; } else { print STDERR "Warning: Non-numeric '$num' in PhysC temp file for $vm_name, skipping.\n"; } }
        close $in_fh;
        unlink $temp_file_physc_path or warn "Warning: Could not delete PhysC temporary file '$temp_file_physc_path': $!";
    }
    
    if (@physc_avg_values_from_file && defined $filter_above_perc_value) {
        my @sff = sort { $a <=> $b } @physc_avg_values_from_file;
        my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
        if (defined $ft) {
            my @fa = grep { defined($_) && $_ >= ($ft - $FLOAT_EPSILON) } @physc_avg_values_from_file;
            my $fpl = sprintf("P%.2f", $filter_above_perc_value); $fpl =~ s/\.?0+$//; $fpl = "0" if $fpl eq "" && $filter_above_perc_value == 0;
            print STDERR "Info ($vm_name): Filtered " . scalar(@physc_avg_values_from_file) . " PhysC $avg_method avgs >= $fpl (" . sprintf("%.4f", $ft) . "), -> " . scalar(@fa) . " values for P$percentile calc.\n";
            if (@fa) { my @sf = sort { $a <=> $b } @fa; $percentile_val_raw = calculate_percentile(\@sf, $percentile); }
            else { print STDERR "Warning ($vm_name): Filtering PhysC $avg_method avgs removed all data. Percentile N/A.\n"; $percentile_val_raw = undef; }
        } else {
             print STDERR "Warning ($vm_name): Could not calc PhysC filter threshold. Using all avgs.\n";
             if (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw = calculate_percentile(\@sa, $percentile); }
        }
    } elsif (@physc_avg_values_from_file) {
        my @sa = sort { $a <=> $b } @physc_avg_values_from_file;
        $percentile_val_raw = calculate_percentile(\@sa, $percentile);
    }

    if (defined $runq_csv_file && defined $vm_collected_norm_runq_values_aref && @{$vm_collected_norm_runq_values_aref}) {
        my @sorted_norm_runq = sort { $a <=> $b } @{$vm_collected_norm_runq_values_aref};
        foreach my $p_val (@runq_norm_percentiles_to_calc) {
            my $val = calculate_percentile(\@sorted_norm_runq, $p_val);
            my $p_label = sprintf("P%.2f", $p_val); $p_label =~ s/\.?0+$//; $p_label = "0" if $p_label eq "" && $p_val == 0;
            $runq_percentile_results{"NormRunQ_$p_label"} = defined($val) ? sprintf("%.2f", $val) : "N/A";
        }
    }
    if (defined $runq_csv_file && defined $vm_collected_abs_runq_values_aref && @{$vm_collected_abs_runq_values_aref}) {
        my @sorted_abs_runq = sort { $a <=> $b } @{$vm_collected_abs_runq_values_aref};
        foreach my $p_val (@runq_abs_percentiles_to_calc) {
            my $val = calculate_percentile(\@sorted_abs_runq, $p_val);
            my $p_label = sprintf("P%.2f", $p_val); $p_label =~ s/\.?0+$//; $p_label = "0" if $p_label eq "" && $p_val == 0;
            $runq_percentile_results{"AbsRunQ_$p_label"} = defined($val) ? sprintf("%.2f", $val) : "N/A"; # Use $v for value
        }
    }

    my $percentile_final_str; my $peak_final_str; my $sprintf_format = "%.".$output_dp."f";
    if (defined $percentile_val_raw) { my $r = apply_rounding($percentile_val_raw, $round_increment, $rounding_method); $percentile_final_str = sprintf($sprintf_format, $r); } else { $percentile_final_str = "N/A"; }
    if ($calculate_peak) { if (defined $peak_val_raw) { my $r = apply_rounding($peak_val_raw, $round_increment, $rounding_method); $peak_final_str = sprintf($sprintf_format, $r); } else { $peak_final_str = "N/A"; } }
    my $p_label = sprintf("P%.2f", $percentile); $p_label =~ s/\.?0+$//; $p_label = "0" if $p_label eq "" && $percentile == 0;
    my $out_line = "$vm_name: $p_label=$percentile_final_str";
    if ($calculate_peak) { $out_line .= " Peak=$peak_final_str"; }
    foreach my $key (sort keys %runq_percentile_results) { $out_line .= " $key=$runq_percentile_results{$key}"; }
    push @results_data, { line => $out_line };
}
else { # Process all VMs
    for (my $i = 0; $i <= $#vm_names_from_physc_header; $i++) {
        my $vm_name = $vm_names_from_physc_header[$i];
        my $temp_file_physc_path = $temp_filenames_physc_list[$i]; # Use correct variable
        my @physc_avg_values_from_file;
        my $percentile_val_raw = undef;
        my $peak_val_raw = $vm_physc_max_peaks_list[$i];
        my %runq_percentile_results;

        if (! -f $temp_file_physc_path || ! -s $temp_file_physc_path) { print STDERR "Warning: PhysC Temp file '$temp_file_physc_path' for VM '$vm_name' empty/missing. Skip percentile.\n" if -e $temp_file_physc_path; unlink $temp_file_physc_path or warn "Warning: Del '$temp_file_physc_path': $!" if -e $temp_file_physc_path; }
        else { open my $in_fh, '<', $temp_file_physc_path or die "Error opening PhysC temp file $temp_file_physc_path: $!"; while (my $num = <$in_fh>) { chomp $num; if ($num =~ /^-?[0-9]+(?:\.[0-9]+)?$/) { push @physc_avg_values_from_file, $num; } else { print STDERR "Warning: Non-numeric '$num' in PhysC temp file for $vm_name, skipping.\n"; } } close $in_fh; unlink $temp_file_physc_path or warn "Warning: Could not delete PhysC temporary file '$temp_file_physc_path': $!"; }
        
        if (@physc_avg_values_from_file && defined $filter_above_perc_value) {
             my @sff = sort { $a <=> $b } @physc_avg_values_from_file; my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
             if (defined $ft) {
                 my @fa = grep { defined($_) && $_ >= ($ft - $FLOAT_EPSILON) } @physc_avg_values_from_file;
                 if (@fa) { my @sf = sort { $a <=> $b } @fa; $percentile_val_raw = calculate_percentile(\@sf, $percentile); }
                 else { print STDERR "Warning ($vm_name): Filtering PhysC $avg_method avgs removed all data. Percentile N/A.\n"; $percentile_val_raw = undef; }
             } else {
                 print STDERR "Warning ($vm_name): Could not calc PhysC filter threshold. Using all avgs.\n";
                 if (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw = calculate_percentile(\@sa, $percentile); }
             }
        } elsif (@physc_avg_values_from_file) {
            my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw = calculate_percentile(\@sa, $percentile);
        }

        if (defined $runq_csv_file && defined $vm_collected_norm_runq_values_list_of_arefs[$i] && @{$vm_collected_norm_runq_values_list_of_arefs[$i]}) {
            my @sorted_norm_runq = sort { $a <=> $b } @{$vm_collected_norm_runq_values_list_of_arefs[$i]};
            foreach my $p_val (@runq_norm_percentiles_to_calc) { my $v = calculate_percentile(\@sorted_norm_runq, $p_val); my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && $p_val == 0; $runq_percentile_results{"NormRunQ_$p_lbl"} = defined($v) ? sprintf("%.2f", $v) : "N/A"; }
        }
        if (defined $runq_csv_file && defined $vm_collected_abs_runq_values_list_of_arefs[$i] && @{$vm_collected_abs_runq_values_list_of_arefs[$i]}) {
            my @sorted_abs_runq = sort { $a <=> $b } @{$vm_collected_abs_runq_values_list_of_arefs[$i]};
            foreach my $p_val (@runq_abs_percentiles_to_calc) { my $v = calculate_percentile(\@sorted_abs_runq, $p_val); my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && $p_val == 0; $runq_percentile_results{"AbsRunQ_$p_lbl"} = defined($v) ? sprintf("%.2f", $v) : "N/A"; } # Corrected $val to $v
        }

        my $percentile_final_str; my $peak_final_str; my $sprintf_format = "%.".$output_dp."f";
        if (defined $percentile_val_raw) { my $r = apply_rounding($percentile_val_raw, $round_increment, $rounding_method); $percentile_final_str = sprintf($sprintf_format, $r); } else { $percentile_final_str = "N/A"; }
        if ($calculate_peak) { if (defined $peak_val_raw) { my $r = apply_rounding($peak_val_raw, $round_increment, $rounding_method); $peak_final_str = sprintf($sprintf_format, $r); } else { $peak_final_str = "N/A"; } }
        my $p_label = sprintf("P%.2f", $percentile); $p_label =~ s/\.?0+$//; $p_label = "0" if $p_label eq "" && $percentile == 0;
        my $out_line = "$vm_name: $p_label=$percentile_final_str";
        if ($calculate_peak) { $out_line .= " Peak=$peak_final_str"; }
        foreach my $key (sort keys %runq_percentile_results) { $out_line .= " $key=$runq_percentile_results{$key}"; }
        push @results_data, { line => $out_line };
        if (($i + 1) % 100 == 0) { print STDERR "Processed results for " . ($i+1) . " VMs...\n"; }
    }
}

# --- Output Results ---
my $header_run_params_label = sprintf("P%.2f", $percentile); $header_run_params_label =~ s/\.?0+$//; $header_run_params_label = "0" if $header_run_params_label eq "" && $percentile == 0;
$header_run_params_label .= ", W=$window_minutes (" . uc($avg_method);
if ($avg_method eq 'ema') { $header_run_params_label .= ", Decay=$decay_level"; }
$header_run_params_label .= ")";
my $rounding_note = ($rounding_method ne 'none') ? " (Rounded $rounding_method to $round_increment)" : "";
my $filter_note = $time_filter_active ? " (Time Filter: $time_filter_desc)" : "";
my $weekend_note = $no_weekends ? " (Weekends Excluded)" : "";
my $perc_filter_note_val = defined($filter_above_perc_value) ? sprintf("P%.2f", $filter_above_perc_value) : ""; 
if ($perc_filter_note_val ne "") {$perc_filter_note_val =~ s/\.?0+$//; $perc_filter_note_val = "0" if $perc_filter_note_val eq "" && $filter_above_perc_value == 0;}
my $perc_filter_note = defined($filter_above_perc_value) ? " (PhysC Perc Filter >= $perc_filter_note_val)" : "";
my $peak_note = $calculate_peak ? " (Peak Calc: Yes)" : "";
my $runq_note = defined($runq_csv_file) ? " (RunQ SMT: $smt_value, NormPercs: $runq_norm_perc_str, AbsPercs: $runq_abs_perc_str)" : "";
if (@results_data) { print STDERR "\n--- Run Summary ($header_run_params_label)$peak_note$runq_note$rounding_note$filter_note$weekend_note$perc_filter_note ---\n"; }
else { print STDERR "\n--- No results generated for this run (check filters/data) ---\n"; }
foreach my $res (@results_data) { print STDOUT $res->{line} . "\n"; }
my $end_time = time(); my $duration = $end_time - $start_time;
print STDERR "\nProcessing completed in $duration seconds.\n";
exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================

sub calculate_average
{
    my @values = @_;
    my @defined_values = grep { defined($_) && $_ ne '' } @values;
    my $count = scalar @defined_values;
    return undef if $count == 0;
    my $sum = sum0(@defined_values);
    return $sum / $count;
}

sub calculate_percentile
{
    my ($sorted_data_ref, $p) = @_;
    unless (defined $sorted_data_ref && ref $sorted_data_ref eq 'ARRAY') {
         print STDERR "Warning: Invalid data reference passed to calculate_percentile\n";
         return undef;
    }
    my @data = @{$sorted_data_ref};
    my $n = scalar @data;
    return undef if $n == 0;
    return $data[0] if $n == 1;
    my $rank_fractional = ($p / 100) * ($n - 1);
    my $k = int($rank_fractional);
    my $d = $rank_fractional - $k;
    if ($k >= $n - 1) { return $data[$n - 1]; }
    elsif ($k < 0) { return $data[0]; }
    else { my $next_val = ($k + 1 < $n) ? $data[$k + 1] : $data[$k]; return $data[$k] + $d * ($next_val - $data[$k]); }
}

sub apply_rounding
{
    my ($value, $increment, $method) = @_;
    return $value unless (defined $value && $value =~ /^-?[0-9]+(?:\.[0-9]+)?$/);
    return $value if $method eq 'none' || !defined $increment || $increment <= 0;
    my $rounded_value;
    if ($method eq 'standard') { $rounded_value = int( ($value / $increment) + 0.5 ) * $increment; }
    elsif ($method eq 'up') { $rounded_value = ceil( $value / $increment ) * $increment; }
    else { $rounded_value = $value; }
    return $rounded_value;
}

sub get_decimal_places
{
    my ($number) = @_;
    $number = sprintf("%.15f", $number) if ($number =~ /e/i);
    if ($number =~ /\.(\d+)$/) { return length($1); }
    else { return 0; }
}

sub parse_percentile_list
{
    my ($perc_str, $arg_name) = @_;
    my @percentiles;
    if (defined $perc_str && $perc_str ne '') {
        @percentiles = split /,\s*/, $perc_str;
        foreach my $p (@percentiles) {
            if ($p !~ /^[0-9]+(?:\.[0-9]+)?$/ || $p < 0 || $p > 100) {
                die "Error: Invalid percentile value '$p' in --$arg_name list. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return @percentiles;
}

sub usage
{
    my $script_name = $0; $script_name =~ s{.*/}{};
    my $valid_decays_usage = join("|", sort keys %EMA_ALPHAS);
    return <<END_USAGE;
Usage: $script_name --physc-data <file> [--runq-data <file>] [--smt <N>]
                  [--avg-method <sma|ema>] [--decay <$valid_decays_usage>] [options]

Analyses NMON PhysC and optionally RunQ data for AIX/Linux on Power VM right-sizing.

Core Input & Averaging Method:
  --physc-data, -pc <file> : Path to input CSV file with PhysC data (required).
  --avg-method <method>    : Averaging method for PhysC: 'sma' (Simple) or 'ema' (Exponential).
                           (Default: $DEFAULT_AVG_METHOD)
  --decay <level>          : If --avg-method is 'ema', specifies decay level.
                           Valid levels: $valid_decays_usage. (Default: $DEFAULT_DECAY_LEVEL)
  -w, --window <minutes>     : Window for SMA; conceptual span/stabilisation trigger for EMA.
                           (Default: $DEFAULT_WINDOW_MINUTES min).

RunQ Data Input (Optional):
  --runq-data, -rq <file>  : Path to input CSV file with RunQ data.
                           Format: "Time","VM1 RunQ","VM2 RunQ",...
  --smt <N>                : SMT level for RunQ normalisation (Default: $DEFAULT_SMT).
  --runq-norm-perc <list>  : Comma-separated percentiles for Normalised RunQ
                           (e.g., "50,90", Default: "$DEFAULT_RUNQ_NORM_PERC").
  --runq-abs-perc <list>   : Comma-separated percentiles for Absolute RunQ
                           (e.g., "90", Default: "$DEFAULT_RUNQ_ABS_PERC").

Filtering Options:
  -s, --startdate <YYYY-MM-DD> : Ignore data before this date.
  -startt <HH:MM>            : Start time for daily filter (requires -endt).
  -endt <HH:MM>              : End time (exclusive) for daily filter (requires -startt).
  -online                    : Shortcut for -startt 08:00 -endt 17:00.
  -batch                     : Shortcut for -startt 18:00 -endt 06:00 (overnight).
  -no-weekends               : Exclude data from Saturdays and Sundays.
  -vm, --lpar <name>         : Analyse only the specified VM/LPAR name.

PhysC Calculation Options:
  -p, --percentile <value>   : Final percentile of PhysC (SMA/EMA) (0-100) (Default: P$DEFAULT_PERCENTILE).
  -k, --peak                 : Calculate the absolute maximum peak PhysC value.
  --filter-above-perc <N>    : Optional. Calculate final PhysC percentile (-p) only using
                               rolling/EMA PhysC values >= Nth percentile of those values.
Rounding Options:
  -r[=increment]             : Round results to NEAREST increment (Default: $DEFAULT_ROUND_INCREMENT).
  -u[=increment]             : Round results UP to nearest increment (Default: $DEFAULT_ROUND_INCREMENT).
                               (-r and -u are mutually exclusive)
Other:
  -h, --help                 : Display this help message.
  -v, --version              : Display script version.

Output Format (to STDOUT):
  VMName: PXX=Val Peak=Val [NormRunQ_P50=Val NormRunQ_P90=Val AbsRunQ_P90=Val ...]
  (RunQ metrics included if --runq-data is specified, labels match requested percs)

Example with EMA:
  $script_name -pc physc.csv --runq-data runq.csv --avg-method ema --decay high -p 95 -w 15
END_USAGE
}
