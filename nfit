#!/usr/bin/env perl

# NAME     : nfit
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Analyse NMON PhysC and optionally RunQ data for AIX and Linux on Power
#            VM right-sizing recommendations. Calculates rolling average (SMA or EMA)
#            percentiles, optionally absolute peaks, and specified percentiles of
#            normalised and absolute run-queue statistics.
#            RunQ data can now also be smoothed using SMA or EMA before percentile calculation.
#            If windowed decay is enabled, metrics are calculated per window,
#            weighted by recency, and then aggregated.
#            NEW: Can predict future growth based on windowed data trends.
#            Supports filtering by date (start and end), time, VM, weekends,
#            and percentile threshold, plus rounding options.
# REQUIRES : Perl, Time::Piece, POSIX (for ceil), List::Util (for sum0, max, min), Getopt::Long, File::Temp, version, File::Spec

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Temp qw(tempfile);
use List::Util qw(sum0 max min);
use Scalar::Util qw(looks_like_number);
use POSIX qw(ceil);
use Time::Piece;
use Time::Seconds;
use version;
use File::Spec;
use File::Find;
use List::MoreUtils qw(uniq);

# --- Version ---
my $VERSION = '3.25.166.0';

# --- Configuration ---
my $DEFAULT_AVG_METHOD     = 'ema';
my $DEFAULT_DECAY_LEVEL    = 'medium';
my $DEFAULT_WINDOW_MINUTES = 15;
my $DEFAULT_PERCENTILE     = 95;
my $DEFAULT_ROUND_INCREMENT= 0.05;
my $DEFAULT_SMT            = 8;
my $DEFAULT_RUNQ_NORM_PERC = "50,90";
my $DEFAULT_RUNQ_ABS_PERC  = "90";
my $DEFAULT_RUNQ_AVG_METHOD = "ema";

my $FLOAT_EPSILON          = 1e-9; # Small number for float comparisons
my $ACTIVE_PHYSC_THRESHOLD = 0.15; # Original threshold for RunQ normalization
my $SAFETY_MARGIN_FOR_THRESHOLD_CONST = 1.05; # Safety margin for ACTIVE_PHYSC_THRESHOLD calculation
my $PLACEHOLDER_ENTITLEMENT_ADJUSTMENT_FACTOR = 1.0; # Placeholder in ACTIVE_PHYSC_THRESHOLD calc

# Windowed Decay Defaults (if enabled for nfit itself)
my $DEFAULT_PROCESS_WINDOW_UNIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS = 30;

# EMA Alpha values based on decay level
my %EMA_ALPHAS = (
    'low'        => 0.03,
    'medium'     => 0.08,
    'high'       => 0.15,
    'very-high'  => 0.30,
    'extreme'    => 0.40,
);

# --- Growth Prediction Configuration (NEW) ---
my $DEFAULT_GROWTH_PROJECTION_DAYS         = 90;
my $DEFAULT_MAX_GROWTH_INFLATION_PERCENT   = 25;

# Internal constants for growth heuristics (not user-configurable initially)
my $GROWTH_MIN_HISTORICAL_PERIODS       = 5;    # Min number of windowed periods to attempt trend
my $GROWTH_MAX_CV_THRESHOLD             = 0.50; # Max Coefficient of Variation (StdDev/Mean); if > this, data too volatile
my $GROWTH_MIN_POSITIVE_SLOPE_THRESHOLD = 0.01; # Min slope (units/period) to consider as actual growth for inflation
my $GROWTH_MAX_PROJECTION_HISTORY_RATIO = 2.0;  # Max ratio of projection duration to history duration used for trend

# --- Argument Parsing ---
my $physc_csv_file;
my $runq_csv_file;
my $nmon_dir;
my $avg_method     = $DEFAULT_AVG_METHOD;
my $decay_level    = $DEFAULT_DECAY_LEVEL;
my $runq_decay_level_arg = undef;
my $window_minutes = $DEFAULT_WINDOW_MINUTES;
my $percentile     = $DEFAULT_PERCENTILE;
my $start_date_str;
my $end_date_str;
my $calculate_peak = 0;
my $round_arg;
my $roundup_arg;
my $start_time_str;
my $end_time_str;
my $online_flag = 0;
my $batch_flag  = 0;
my $target_vm_name;
my $no_weekends = 0;
my $filter_above_perc_value = undef;
my $smt_value = $DEFAULT_SMT;
my $runq_norm_perc_str = $DEFAULT_RUNQ_NORM_PERC;
my $runq_abs_perc_str  = $DEFAULT_RUNQ_ABS_PERC;
my $runq_avg_method_str = $DEFAULT_RUNQ_AVG_METHOD;
my $help           = 0;
my $show_version   = 0;
my $verbose   = 0;

# Windowed Decay options
my $enable_windowed_decay_internal = 0;
my $process_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT;
my $process_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE;
my $decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS;
my $analysis_reference_date_str;

# Growth Prediction options (NEW)
my $enable_growth_prediction = 0;
my $growth_projection_days = $DEFAULT_GROWTH_PROJECTION_DAYS;
my $max_growth_inflation_percent = $DEFAULT_MAX_GROWTH_INFLATION_PERCENT;

my $show_states_flag = 0;
my $include_states_selector = 'all'; # Default value

GetOptions(
    'physc-data|pc=s'     => \$physc_csv_file,
    'runq-data|rq=s'      => \$runq_csv_file,
    'nmondir=s'           => \$nmon_dir,
    'avg-method=s'        => \$avg_method,
    'decay=s'             => \$decay_level,
    'runq-decay=s'        => \$runq_decay_level_arg,
    'window|w=i'          => \$window_minutes,
    'percentile|p=f'      => \$percentile,
    'startdate|s=s'       => \$start_date_str,
    'enddate|ed=s'        => \$end_date_str,
    'peak|k'              => \$calculate_peak,
    'round|r:f'           => \$round_arg,
    'roundup|u:f'         => \$roundup_arg,
    'startt=s'            => \$start_time_str,
    'endt=s'              => \$end_time_str,
    'online'              => \$online_flag,
    'batch'               => \$batch_flag,
    'vm|lpar=s'           => \$target_vm_name,
    'no-weekends'         => \$no_weekends,
    'filter-above-perc=f' => \$filter_above_perc_value,
    'smt=i'               => \$smt_value,
    'runq-norm-perc=s'    => \$runq_norm_perc_str,
    'runq-abs-perc=s'     => \$runq_abs_perc_str,
    'runq-avg-method=s'   => \$runq_avg_method_str,
    # Windowed Decay Options
    'enable-windowed-decay'     => \$enable_windowed_decay_internal,
    'process-window-unit=s'     => \$process_window_unit_str,
    'process-window-size=i'     => \$process_window_size_val,
    'decay-half-life-days=i'    => \$decay_half_life_days_val,
    'analysis-reference-date=s' => \$analysis_reference_date_str,
    # Growth Prediction Options (NEW)
    'enable-growth-prediction'       => \$enable_growth_prediction,
    'growth-projection-days=i'       => \$growth_projection_days,
    'max-growth-inflation-percent=i' => \$max_growth_inflation_percent,
    'show-states'               => \$show_states_flag,
    'include-states=s'          => \$include_states_selector,
    # General Options
    'help|h'              => \$help,
    'verbose|v'           => \$verbose,
    'version'             => \$show_version,
) or die usage();

# --- Validation ---
if ($show_version)
{
    print STDERR "nfit version $VERSION\n";
    exit 0;
}

if ($show_states_flag)
{
    # The --include-states argument might be present with its default value.
    # We only error if the user explicitly provided a different value.
    if (defined $include_states_selector and lc($include_states_selector) ne 'all')
    {
        die "Error: --show-states and --include-states are mutually exclusive.\n";
    }
}

if ( ($show_states_flag or (defined $include_states_selector and lc($include_states_selector) ne 'all')) and !$nmon_dir )
{
    die "Error: --show-states and --include-states can only be used with the --nmondir option.\n";
}

if ($help || (!$physc_csv_file && !$nmon_dir))
{
    print STDERR usage();
    exit 0;
}

if ($nmon_dir)
{
    if ($physc_csv_file || $runq_csv_file)
    {
        die "Error: --nmondir cannot be used with --physc-data or --runq-data.\n";
    }
    unless (-d $nmon_dir)
    {
        die "Error: Provided --nmondir path is not a valid directory: $nmon_dir\n";
    }
}

$avg_method = lc($avg_method);
if ($avg_method ne 'sma' && $avg_method ne 'ema')
{
    die "Error: --avg-method must be 'sma' or 'ema'. Got '$avg_method'.\n";
}

$decay_level = lc($decay_level);
unless (exists $EMA_ALPHAS{$decay_level})
{
    my $valid_decays = join(", ", sort keys %EMA_ALPHAS);
    die "Error: --decay level '$decay_level' is invalid. Valid levels are: $valid_decays.\n";
}
my $alpha_for_physc_ema = $EMA_ALPHAS{$decay_level};

my $runq_decay_level_to_use = $decay_level;
my $runq_decay_source_for_log = "$decay_level (from PhysC decay setting)";
if (defined $runq_decay_level_arg)
{
    $runq_decay_level_arg = lc($runq_decay_level_arg);
    unless (exists $EMA_ALPHAS{$runq_decay_level_arg})
    {
        my $valid_decays = join(", ", sort keys %EMA_ALPHAS);
        die "Error: --runq-decay level '$runq_decay_level_arg' is invalid. Valid levels are: $valid_decays.\n";
    }
    $runq_decay_level_to_use = $runq_decay_level_arg;
    $runq_decay_source_for_log = "$runq_decay_level_arg (from --runq-decay)";
}
my $alpha_for_runq_ema = $EMA_ALPHAS{$runq_decay_level_to_use};

$runq_avg_method_str = lc($runq_avg_method_str);
if ($runq_avg_method_str ne 'none' && $runq_avg_method_str ne 'sma' && $runq_avg_method_str ne 'ema')
{
    die "Error: --runq-avg-method must be 'none', 'sma', or 'ema'. Got '$runq_avg_method_str'.\n";
}

if ($physc_csv_file && ! -f $physc_csv_file)
{
    die "Error: PhysC data file (--physc-data) not found: $physc_csv_file\n";
}

if (defined $runq_csv_file && ! -f $runq_csv_file)
{
    die "Error: RunQ data file (--runq-data) not found: $runq_csv_file\n";
}

if ($smt_value <= 0)
{
    die "Error: --smt value must be a positive integer.\n";
}
if ($window_minutes < 1)
{
    die "Error: Window size (-w) for SMA/EMA must be at least 1 minute.\n";
}
if ($percentile < 0 || $percentile > 100)
{
    die "Error: Percentile (-p) must be between 0 and 100.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}
if (defined $end_date_str && $end_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid enddate (-ed) format '$end_date_str'. Use YYYY-MM-DD.\n";
}
if (defined $start_date_str && defined $end_date_str)
{
    my ($s_tp_val, $e_tp_val);
    eval { $s_tp_val = Time::Piece->strptime($start_date_str, "%Y-%m-%d"); };
    if ($@ || (defined $start_date_str && !$s_tp_val) )
    {
        die "Error parsing startdate '$start_date_str': $@\n";
    }
    eval { $e_tp_val = Time::Piece->strptime($end_date_str, "%Y-%m-%d"); };
    if ($@ || (defined $end_date_str && !$e_tp_val) )
    {
        die "Error parsing enddate '$end_date_str': $@\n";
    }
    if ($s_tp_val && $e_tp_val && $e_tp_val < $s_tp_val)
    {
        die "Error: --enddate ($end_date_str) cannot be before --startdate ($start_date_str).\n";
    }
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if ($enable_windowed_decay_internal)
{
    if ($process_window_unit_str ne "days" && $process_window_unit_str ne "weeks")
    {
        die "Error: --process-window-unit must be 'days' or 'weeks'. Got '$process_window_unit_str'.\n";
    }
    if ($process_window_size_val < 1)
    {
        die "Error: --process-window-size must be at least 1. Got '$process_window_size_val'.\n";
    }
    if ($decay_half_life_days_val < 1)
    {
        die "Error: --decay-half-life-days must be at least 1. Got '$decay_half_life_days_val'.\n";
    }
    if (defined $analysis_reference_date_str && $analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
    {
        die "Error: Invalid --analysis-reference-date format '$analysis_reference_date_str'. Use YYYY-MM-DD.\n";
    }
}

# Growth Prediction Option Validation (NEW)
if ($enable_growth_prediction)
{
    unless ($enable_windowed_decay_internal)
    {
        # This also implies growth prediction cannot run in non-windowed decay mode.
        # Set flag to false to ensure growth logic is skipped later, even if initially enabled by user.
        print STDERR "Warning: --enable-growth-prediction requires --enable-windowed-decay to be active. Growth prediction will be SKIPPED.\n";
        $enable_growth_prediction = 0;
    }
    if ($growth_projection_days < 1)
    {
        die "Error: --growth-projection-days must be at least 1.\n";
    }
    if ($max_growth_inflation_percent < 0 || $max_growth_inflation_percent > 200) # Cap inflation percentage
    {
        die "Error: --max-growth-inflation-percent must be between 0 and 200.\n";
    }
}

my @runq_norm_percentiles_to_calc = parse_percentile_list($runq_norm_perc_str, "runq-norm-perc");
my @runq_abs_percentiles_to_calc  = parse_percentile_list($runq_abs_perc_str,  "runq-abs-perc");

my $rounding_method = 'none';
my $round_increment = undef;
my $output_dp = 4;
if (defined $round_arg)
{
    $rounding_method = 'standard';
    $round_increment = (length $round_arg && $round_arg =~ /^[0-9.]*$/) ? $round_arg : $DEFAULT_ROUND_INCREMENT;
    print STDERR "Applying standard rounding to nearest $round_increment\n";
}
elsif (defined $roundup_arg)
{
    $rounding_method = 'up';
    $round_increment = (length $roundup_arg && $roundup_arg =~ /^[0-9.]*$/) ? $roundup_arg : $DEFAULT_ROUND_INCREMENT;
    print STDERR "Applying ceiling rounding up to nearest $round_increment\n";
}
if ($rounding_method ne 'none')
{
    if (!defined $round_increment || $round_increment <= $FLOAT_EPSILON)
    {
        die "Error: Rounding increment must be positive (got '$round_increment').\n";
    }
    $output_dp = get_decimal_places($round_increment);
}

my $time_filter_active = 0;
my $time_filter_start = undef;
my $time_filter_end = undef;
my $time_filter_overnight = 0;
my $time_filter_desc = "";
if ($online_flag)
{
    $time_filter_active = 1;
    $time_filter_start = "08:00";
    $time_filter_end = "17:00";
    $time_filter_desc = "ONLINE ($time_filter_start <= time < $time_filter_end)";
}
elsif ($batch_flag)
{
    $time_filter_active = 1;
    $time_filter_start = "18:00";
    $time_filter_end = "06:00";
    $time_filter_overnight = 1;
    $time_filter_desc = "BATCH (time >= $time_filter_start OR time < $time_filter_end)";
}
elsif (defined $start_time_str && defined $end_time_str)
{
    $time_filter_active = 1;
    $time_filter_start = $start_time_str;
    $time_filter_end = $end_time_str;
    if ($time_filter_end lt $time_filter_start)
    {
        $time_filter_overnight = 1;
        $time_filter_desc = "OVERNIGHT (time >= $time_filter_start OR time < $time_filter_end)";
    }
    else
    {
        $time_filter_desc = "MANUAL ($time_filter_start <= time < $time_filter_end)";
    }
}
elsif (defined $start_time_str || defined $end_time_str)
{
    die "Error: Must specify both -startt and -endt if using manual time filtering.\n";
}

{
    # Block to keep calculation-specific variables local
    # Restoring original logic as requested, with a note about unreachable code.
	 my %smt_adjustment_map = (
		  1 => 1.00,
		  2 => 0.95,
		  4 => 0.90,
		  8 => 1.10,
	 );

	 my $smt_adjustment_factor = $smt_adjustment_map{$smt_value} // 1.00;  # default to 1.00

    my $entitlement_adjustment_factor = $PLACEHOLDER_ENTITLEMENT_ADJUSTMENT_FACTOR;
    my $calculated_threshold = $ACTIVE_PHYSC_THRESHOLD *
                               $smt_adjustment_factor *
                               $entitlement_adjustment_factor *
                               $SAFETY_MARGIN_FOR_THRESHOLD_CONST;
    my $MIN_ACTIVE_PHYSC_THRESHOLD = 0.10;
    $ACTIVE_PHYSC_THRESHOLD = ($calculated_threshold < $MIN_ACTIVE_PHYSC_THRESHOLD) ? $MIN_ACTIVE_PHYSC_THRESHOLD : $calculated_threshold;
}

## -- Main Block -- ##

my @processing_windows;
my $script_start_time = time();
print STDERR "nfit version $VERSION\n";
print STDERR "-------------------------\n";

# ==============================================================================
# Main Execution Block
# ==============================================================================

if ($nmon_dir)
{
    # --- Phase 1: Discovery ---
    print STDERR "Phase 1: Discovering Configuration States from '$nmon_dir'...\n";
    my $all_states_ref = define_configuration_states($nmon_dir, $smt_value);
    my %config_states_by_vm = %{$all_states_ref};

    # Handle the --show-states flag immediately after discovery
    if ($show_states_flag) {
        print_state_windows_report(\%config_states_by_vm);
        exit 0;
    }

    # Filter the states based on the user's --include-states selector
    my @all_selected_states;
    my @vms_to_process = (defined $target_vm_name) ? ($target_vm_name) : (sort keys %config_states_by_vm);
    foreach my $vm_name (@vms_to_process) {
        my @available = @{$config_states_by_vm{$vm_name} || []};
        my @selected_for_this_vm = parse_state_selector($include_states_selector, \@available);
        push @all_selected_states, @selected_for_this_vm;
    }

    if (scalar(@all_selected_states) == 0) {
        print STDERR " -> No matching states found for the specified selector '$include_states_selector'. No data to process.\n";
        exit 0;
    }
    my $total_vms_with_states = scalar(grep { @{$config_states_by_vm{$_}} } keys %config_states_by_vm);
    print STDERR " -> Found a total of " . scalar(@all_selected_states) . " matching configuration states across $total_vms_with_states VMs.\n\n";

    # --- Phase 2: Staging ---
    print STDERR "Phase 2: Staging NMON performance data for analysis...\n";
    my ($temp_physc_fh, $temp_physc_filename) = tempfile(UNLINK => 1);
    my ($temp_runq_fh, $temp_runq_filename)   = tempfile(UNLINK => 1);
    process_nmon_directory_to_tempfiles($nmon_dir, $temp_physc_fh, $temp_runq_fh);
    close($temp_physc_fh);
    close($temp_runq_fh);
    print STDERR " -> Data staging complete.\n\n";

    my %vm_results_aggregator;

    # --- Phase 3: Analysis ---
    # Group selected states by VM name to enable cleaner, grouped output
    my %selected_states_by_vm;
    foreach my $state (@all_selected_states) {
        push @{$selected_states_by_vm{$state->{vm_name}}}, $state;
    }

    print STDERR "Phase 3: Analysing Configuration States and Calculating Metrics...\n\n";

    foreach my $vm_name (sort keys %selected_states_by_vm) {
        my @states_for_this_vm = @{$selected_states_by_vm{$vm_name}};
        print STDERR "  VM: $vm_name (" . @states_for_this_vm . " " . (@states_for_this_vm == 1 ? "State" : "States") . ")\n";

        foreach my $state (@states_for_this_vm) {
            my $start_str = $state->{start_time}->strftime('%Y-%m-%d');
            my $end_str   = $state->{end_time}->strftime('%Y-%m-%d');
            print STDERR "    - Analysing Configuration State " . $state->{state_id} . " ($start_str to $end_str)...";

            my %filters = (
                start_date_str => $start_date_str, end_date_str   => $end_date_str,
                no_weekends    => $no_weekends,    time_filter_active => $time_filter_active,
                time_filter_start => $time_filter_start, time_filter_end => $time_filter_end,
                time_filter_overnight => $time_filter_overnight,
            );
            my @state_data_points = stream_data_for_state_from_temp($state, $temp_physc_filename, $temp_runq_filename, \%filters);

            if (!$enable_windowed_decay_internal) {
                my $metrics = calculate_metrics_for_period(\@state_data_points, $state->{metadata});
                # Store results in an array under the 'states' key
                push @{$vm_results_aggregator{$vm_name}{'states'}}, { metrics => $metrics, state_obj => $state };
            } else {
                my @time_windows = define_time_windows_for_state($state, $analysis_reference_date_str, $process_window_unit_str, $process_window_size_val);
                foreach my $win (@time_windows) {
                    my @data_in_window = grep { $_->{tp} >= $win->{start} && $_->{tp} <= $win->{end} } @state_data_points;
                    next unless @data_in_window;
                    my $win_metrics = calculate_metrics_for_period(\@data_in_window, $state->{metadata});
                    push @{$vm_results_aggregator{$vm_name}{time_windows}}, { metrics => $win_metrics, date_obj => $win->{rep_date} };
                }
            }
            print STDERR " Done.\n";
        }
        print STDERR "\n";
    }

    print STDERR generate_run_summary_string();
    print STDERR "------------------------------------------------------------------\n";

    # --- Final Output Generation ---

    print STDOUT "\n------------------------------------------------------------------\n";
    print STDOUT "Results\n";
    print STDOUT "------------------------------------------------------------------\n";

    my @output_header_cols = ("VM_Name", "State_ID", "Duration_Days", "Entitlement", "MaxCPU", "SMT", "Processor", "SerialNumber", "PoolID");
    my @metric_keys_in_order = ("P" . clean_perc_label($percentile));
    push @metric_keys_in_order, 'Peak' if $calculate_peak;
    foreach my $p (@runq_norm_percentiles_to_calc) { push @metric_keys_in_order, "NormRunQ_P" . clean_perc_label($p); }
    foreach my $p (@runq_abs_percentiles_to_calc) { push @metric_keys_in_order, "AbsRunQ_P" . clean_perc_label($p); }
    if ($enable_windowed_decay_internal && $enable_growth_prediction) {
        push @metric_keys_in_order, "GrowthAdj", "GrowthAdjAbs";
    }
    push @output_header_cols, @metric_keys_in_order;
#    print STDOUT join(",", @output_header_cols) . "\n";

	 if (!$enable_windowed_decay_internal) {
# When decay is OFF, print one key=value pair line per state processed.
		 foreach my $vm_name (sort keys %vm_results_aggregator) {

			 next unless (exists $vm_results_aggregator{$vm_name}{'states'} && ref($vm_results_aggregator{$vm_name}{'states'}) eq 'ARRAY');

			 my @states_for_this_vm = @{$vm_results_aggregator{$vm_name}{'states'}};
			 my $total_states_for_vm = scalar(@states_for_this_vm);

			 foreach my $result (@states_for_this_vm) {
				 my $state_obj = $result->{state_obj};
				 my $md        = $result->{state_obj}{metadata};

# Build the descriptive state identifier prefix
				 my $state_prefix = sprintf("%s:State-%d_of_%d (%s_to_%s)",
						 $vm_name,
						 $state_obj->{state_id},
						 $total_states_for_vm,
						 $state_obj->{start_time}->strftime('%Y-%m-%d'),
						 $state_obj->{end_time}->strftime('%Y-%m-%d')
						 );

				 my @output_parts = ($state_prefix);

# Push metadata key-value pairs
				 push @output_parts, sprintf("Entitlement=%.2f", $md->{entitlement} // 0);
				 push @output_parts, sprintf("MaxCPU=%.2f", $md->{max_cpu} // 0);
				 push @output_parts, sprintf("SMT=%d", $md->{smt} // 0);
				 push @output_parts, sprintf("Processor=%s", $md->{processor_state} // 'N/A');
				 push @output_parts, sprintf("SerialNumber=%s", $md->{serial_number} // '');
				 push @output_parts, sprintf("PoolID=%s", $md->{pool_id} // '');

# Push metric key-value pairs
				 my @metric_keys = sort keys %{$result->{metrics}};
				 foreach my $key (@metric_keys) {
					 my $val = $result->{metrics}{$key};
					 my $val_str = defined($val) && looks_like_number($val) ? sprintf("%.${output_dp}f", apply_rounding($val, $round_increment, $rounding_method)) : "N/A";
					 push @output_parts, "$key=$val_str";
				 }

# Final print statement, joined by spaces
				 print STDOUT join(" ", @output_parts) . "\n";
			 }
		 }
	 } else {
        # When decay is ON, aggregate results and print one line per VM.
        my $analysis_ref_obj;
        if (defined $analysis_reference_date_str) {
            eval { $analysis_ref_obj = Time::Piece->strptime($analysis_reference_date_str, "%Y-%m-%d"); };
            die "Error: Invalid --analysis-reference-date: '$analysis_reference_date_str'. Parser error: $@" if ($@ || !$analysis_ref_obj);
        } else {
             my $latest_epoch = 0;
             foreach my $state (@all_selected_states) { $latest_epoch = $state->{end_time}->epoch if $state->{end_time}->epoch > $latest_epoch; }
             $analysis_ref_obj = Time::Piece->new($latest_epoch);
        }
        $analysis_ref_obj = $analysis_ref_obj->truncate(to => 'day');

        foreach my $vm_name (sort keys %vm_results_aggregator) {
            my %final_metrics; my %all_keys;
            foreach my $win_result (@{$vm_results_aggregator{$vm_name}{time_windows}}) {
                foreach my $key (keys %{$win_result->{metrics}}) { $all_keys{$key} = 1; }
            }

            # Aggregate metrics across all time windows for the VM
            foreach my $metric_key (sort keys %all_keys) {
                my @data_points;
                foreach my $win_result (@{$vm_results_aggregator{$vm_name}{time_windows}}) {
                    if (defined $win_result->{metrics}{$metric_key}) {
                        push @data_points, { value => $win_result->{metrics}{$metric_key}, date => $win_result->{date_obj} };
                    }
                }
                $final_metrics{$metric_key} = calculate_recency_weighted_average(\@data_points, $analysis_ref_obj, $decay_half_life_days_val);
            }

            # --- Growth Prediction logic for aggregated result ---
            my $p_label_main = "P" . clean_perc_label($percentile);
            my ($growth_adj_value, $growth_adj_abs_value) = (0.0, 0.0);

            if ($enable_growth_prediction) {
                my @timeseries_values; my @timeseries_points; my $time_idx = 0;
                foreach my $win_result (@{$vm_results_aggregator{$vm_name}{time_windows}}) {
                    my $metric_val = $win_result->{metrics}{$p_label_main};
                    if (defined $metric_val && looks_like_number($metric_val)) {
                        push @timeseries_values, $metric_val; push @timeseries_points, [$time_idx, $metric_val]; $time_idx++;
                    }
                }

                my $num_hist_periods = scalar(@timeseries_points);
                if ($num_hist_periods >= $GROWTH_MIN_HISTORICAL_PERIODS) {
                    my ($mean_val, $stddev_val, $cv_val) = calculate_statistics_for_trend(\@timeseries_values);
                    if (defined $cv_val && $cv_val < $GROWTH_MAX_CV_THRESHOLD) {
                        my ($slope, $intercept) = calculate_manual_linear_regression(\@timeseries_points);
                        if ($slope > $GROWTH_MIN_POSITIVE_SLOPE_THRESHOLD) {
                            my $projected_val = $slope * ($num_hist_periods - 1 + $growth_projection_days) + $intercept;
                            my $baseline_val = $final_metrics{$p_label_main} // 0;
                            if ($baseline_val > $FLOAT_EPSILON) {
                                my $inflation_perc = (($projected_val - $baseline_val) / $baseline_val) * 100;
                                $inflation_perc = $max_growth_inflation_percent if $inflation_perc > $max_growth_inflation_percent;
                                $growth_adj_value = ($baseline_val * $inflation_perc / 100);
                                $growth_adj_abs_value = $growth_adj_value;
                            }
                        }
                    }
                }
            }
            $final_metrics{"GrowthAdj"} = $growth_adj_value;
            $final_metrics{"GrowthAdjAbs"} = $growth_adj_abs_value;

            if (defined $final_metrics{$p_label_main} && looks_like_number($final_metrics{$p_label_main})) {
                $final_metrics{$p_label_main} += $growth_adj_value;
            }

            # --- Print the single aggregated output line ---
            my $last_state_metadata = {};
            if (exists $config_states_by_vm{$vm_name} && @{$config_states_by_vm{$vm_name}}) {
                $last_state_metadata = $config_states_by_vm{$vm_name}[-1]->{metadata};
            }

            # --- Print the single aggregated output line ---
            my $output_string = "$vm_name:";

            $output_string .= sprintf(" Entitlement=%.2f", $last_state_metadata->{entitlement} // 0);
            $output_string .= sprintf(" MaxCPU=%.2f", $last_state_metadata->{max_cpu} // 0);
            $output_string .= sprintf(" SMT=%s", $last_state_metadata->{smt} // '');
            $output_string .= sprintf(" Processor=%s", $last_state_metadata->{processor_state} // 'N/A');
            $output_string .= sprintf(" SerialNumber=%s", $last_state_metadata->{serial_number} // '');
            $output_string .= sprintf(" PoolID=%s", $last_state_metadata->{pool_id} // '');

            my @keys_out = sort keys %final_metrics;
             foreach my $key (@keys_out) {
                my $val = $final_metrics{$key};
                my $val_str = defined($val) && looks_like_number($val) ? sprintf("%.${output_dp}f", apply_rounding($val, $round_increment, $rounding_method)) : "N/A";
                $output_string .= " $key=$val_str";
            }
            print STDOUT $output_string . "\n";
        }
    }
}
else
{
    # --- NON-NMONDIR (LEGACY) FILE-BASED PROCESSING ---
    my %vm_data_by_window;
    my $actual_overall_start_date_obj;
    my $actual_overall_end_date_obj;
    my $actual_analysis_ref_date_obj;
    my @vm_names_from_physc_header;
    my $target_vm_index_in_physc = undef;
    my %current_window_vm_data_buffer;
    my %temp_files_for_physc_rolling_avgs_overall;
    my %collected_runq_overall;
    my $line_count = 0;
    my $data_lines_processed = 0;
    my %runq_data_store;
    my $vm_physc_max_peak_scalar_overall;
    my @vm_physc_max_peaks_list_overall;

    if ($enable_windowed_decay_internal)
    {
        ($actual_overall_start_date_obj, $actual_overall_end_date_obj) = get_nmon_overall_date_range($physc_csv_file, $start_date_str, $end_date_str);
        unless (defined $actual_overall_start_date_obj && $actual_overall_start_date_obj->isa('Time::Piece') && defined $actual_overall_end_date_obj && $actual_overall_end_date_obj->isa('Time::Piece'))
        {
            die "Error: Could not determine actual data processing range from NMON file '$physc_csv_file' after applying global date filters. Windowed decay cannot proceed.\n";
        }
        if (defined $analysis_reference_date_str)
        {
            eval { $actual_analysis_ref_date_obj = Time::Piece->strptime($analysis_reference_date_str, "%Y-%m-%d"); };
            unless (defined $actual_analysis_ref_date_obj && $actual_analysis_ref_date_obj->isa('Time::Piece'))
            {
                die "Error: Invalid --analysis-reference-date: '$analysis_reference_date_str'. Ensure format YYYY-MM-DD. Parser error: $@\n";
            }
        }
        else
        {
            $actual_analysis_ref_date_obj = $actual_overall_end_date_obj;
        }
        $actual_analysis_ref_date_obj = $actual_analysis_ref_date_obj->truncate(to => 'day');
        @processing_windows = generate_processing_time_windows($actual_overall_start_date_obj, $actual_overall_end_date_obj, $process_window_unit_str, $process_window_size_val);
        if (scalar @processing_windows == 0)
        {
            die "Error: No processing windows generated. Check NMON data range and window parameters.\n";
        }
        print STDERR "Generated " . scalar(@processing_windows) . " processing windows for internal aggregation.\n";
    }

    if (defined $runq_csv_file && (-s $runq_csv_file))
    {
        print STDERR "Pre-loading RunQ data...\n";
        open my $runq_fh, '<:encoding(utf8)', $runq_csv_file or die "Error: Cannot open RunQ CSV file '$runq_csv_file': $!\n";
        my $runq_line_count = 0;
        my @runq_vm_names_header;
        while (my $line = <$runq_fh>)
        {
            chomp $line;
            $line =~ s/\r$//;
            $runq_line_count++;
            next if ($line =~ /^\s*$/o);
            $line =~ s/^\x{FEFF}// if $runq_line_count == 1;
            my @fields = split ',', $line, -1;
            if ($runq_line_count == 1)
            {
                shift @fields;
                @runq_vm_names_header = map { my ($name) = split / /; $name =~ s/^"|"$//g; $name; } @fields;
                if (defined $target_vm_name && !grep { $_ eq $target_vm_name } @runq_vm_names_header)
                {
                    print STDERR "Warning: Target VM '$target_vm_name' not found in RunQ CSV header. RunQ metrics for it will be N/A.\n";
                }
                next;
            }
            my $timestamp_str_local = $fields[0];
            shift @fields;
            for (my $i = 0; $i <= $#fields; $i++)
            {
                my $vm_name_local = $runq_vm_names_header[$i];
                next unless (defined $vm_name_local && $vm_name_local ne '');
                if (!defined $target_vm_name || $vm_name_local eq $target_vm_name)
                {
                    if (defined $fields[$i] && $fields[$i] =~ /^[0-9.]+$/)
                    {
                        $runq_data_store{$vm_name_local}{$timestamp_str_local} = $fields[$i];
                    }
                }
            }
        }
        close $runq_fh;
        print STDERR "Finished pre-loading RunQ data for " . scalar(keys %runq_data_store) . " VMs from $runq_line_count lines.\n";
    }

    print STDERR "Processing PhysC data and calculating metrics...\n";
    open my $physc_csv_fh, '<:encoding(utf8)', $physc_csv_file or die "Error: Cannot open PhysC CSV file '$physc_csv_file': $!\n";
    my $current_window_idx = 0;
    my $current_processing_window_end_obj = ($enable_windowed_decay_internal && @processing_windows) ? $processing_windows[0][1] : undef;

    while (my $line = <$physc_csv_fh>)
    {
        chomp $line;
        $line =~ s/\r$//;
        $line_count++;
        next if ($line =~ /^\s*$/o);
        $line =~ s/^\x{FEFF}// if $line_count == 1;
        my @fields = split /,/, $line, -1;

        if ($line_count == 1)
        {
            shift @fields;
            my $num_vms_found = 0;
            my $current_idx_header = 0;
            foreach my $header_field (@fields)
            {
                $header_field =~ s/^\s+|\s+$//g;
                $header_field =~ s/^"|"$//g;
                my ($vm_name_local) = split / /, $header_field, 2;
                if (defined $vm_name_local && $vm_name_local ne '')
                {
                    push @vm_names_from_physc_header, $vm_name_local;
                    if (defined $target_vm_name && $vm_name_local eq $target_vm_name)
                    {
                        $target_vm_index_in_physc = $current_idx_header;
                    }
                    $num_vms_found++;
                }
                else
                {
                    print STDERR "Warning: Could not extract VM name from PhysC header index $current_idx_header: '$header_field'\n";
                    push @vm_names_from_physc_header, "UNKNOWN_VM_PHYSC_$current_idx_header";
                }
                $current_idx_header++;
            }
            my $num_vms = scalar(@vm_names_from_physc_header);
            if ($num_vms == 0)
            {
                die "Error: No valid VM columns found in PhysC header.\n";
            }
            print STDERR "Found $num_vms VMs in PhysC header.\n";
            if (defined $target_vm_name && !defined $target_vm_index_in_physc)
            {
                my $avail_vms = join(", ", @vm_names_from_physc_header);
                $avail_vms = substr($avail_vms, 0, 200) . "..." if length($avail_vms) > 200;
                die "Error: Target VM '$target_vm_name' not found in PhysC CSV header.\nAvailable VMs: $avail_vms\n";
            }
            unless ($enable_windowed_decay_internal)
            {
                if (defined $target_vm_index_in_physc)
                {
                    my $vm_name_local = $target_vm_name; # Use local var
                    my ($fh, $fname) = tempfile(UNLINK => 0);
                    unless ($fh)
                    {
                        die "Error: Could not create PhysC temp file for $vm_name_local: $!\n";
                    }
                    $temp_files_for_physc_rolling_avgs_overall{$vm_name_local} = { fh => $fh, filename => $fname };
                }
                else
                {
                    foreach my $vm_name_local (@vm_names_from_physc_header) # Use local var
                    {
                        my ($fh, $fname) = tempfile(UNLINK => 0);
                        unless ($fh)
                        {
                            die "Error: Could not create PhysC temp file for $vm_name_local: $!\n";
                        }
                        $temp_files_for_physc_rolling_avgs_overall{$vm_name_local} = { fh => $fh, filename => $fname };
                    }
                }
            }
            next;
        }
        my $timestamp_str_loop = $fields[0]; # Use local var
        my $tp;
        eval { $tp = Time::Piece->strptime($timestamp_str_loop, "%Y-%m-%d %H:%M:%S"); };
        if ($@ || !defined $tp || !$tp->isa('Time::Piece'))
        {
            print STDERR "Warning: Could not parse timestamp '$timestamp_str_loop' line $line_count. Skipping.\n";
            next;
        }

        if (defined $start_date_str && $tp->ymd('-') lt $start_date_str) { next; }
        if (defined $end_date_str   && $tp->ymd('-') gt $end_date_str)   { next; }
        if ($no_weekends)
        {
            my $day_of_week = $tp->day_of_week;
            if ($day_of_week == 1 || $day_of_week == 7) { next; }
        }
        if ($time_filter_active)
        {
            my $line_time = substr($tp->hms(':'), 0, 5);
            my $include_line = 0;
            if ($time_filter_overnight)
            {
                if ($line_time ge $time_filter_start || $line_time lt $time_filter_end) { $include_line = 1; }
            }
            else
            {
                if ($line_time ge $time_filter_start && $line_time lt $time_filter_end) { $include_line = 1; }
            }
            unless ($include_line) { next; }
        }

        $data_lines_processed++;
        shift @fields;

        my $current_window_key_loop; # Use local var
        if ($enable_windowed_decay_internal)
        {
            my $current_timestamp_day_obj = $tp->truncate(to => 'day');
            while (defined $current_processing_window_end_obj && $current_timestamp_day_obj > $current_processing_window_end_obj)
            {
                process_and_store_window_results(
                    $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window,
                    \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
                    $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc,
                    $runq_avg_method_str, $window_minutes, $alpha_for_physc_ema
                );
                %current_window_vm_data_buffer = ();
                $current_window_idx++;
                if ($current_window_idx < @processing_windows)
                {
                    $current_processing_window_end_obj = $processing_windows[$current_window_idx][1];
                }
                else
                {
                    $current_processing_window_end_obj = undef;
                    last;
                }
            }
            $current_window_key_loop = get_window_key_for_timestamp($tp, \@processing_windows, $current_window_idx);
            unless (defined $current_window_key_loop) { next; }
        }

        my @vms_to_iterate_this_line;
        if (defined $target_vm_index_in_physc)
        {
            push @vms_to_iterate_this_line, { index => $target_vm_index_in_physc, name => $target_vm_name };
        }
        else
        {
            for (my $i=0; $i < @vm_names_from_physc_header; $i++)
            {
                push @vms_to_iterate_this_line, { index => $i, name => $vm_names_from_physc_header[$i] };
            }
        }

        foreach my $vm_info (@vms_to_iterate_this_line)
        {
            my $vm_idx = $vm_info->{index};
            my $current_vm_name_loop = $vm_info->{name}; # Use local var
            my $physc_value_str_local = defined $fields[$vm_idx] ? $fields[$vm_idx] : ''; # Use local var
            my $physc_value_loop; # Use local var
            if (defined $physc_value_str_local && $physc_value_str_local =~ /^-?[0-9.]+$/) { $physc_value_loop = $physc_value_str_local + 0; }
            else { $physc_value_loop = undef; }

            my $runq_value_for_this_ts_loop = undef; # Use local var
            if (defined $runq_csv_file && exists $runq_data_store{$current_vm_name_loop}{$timestamp_str_loop})
            {
                if ($runq_data_store{$current_vm_name_loop}{$timestamp_str_loop} =~ /^-?[0-9.]+$/)
                {
                    $runq_value_for_this_ts_loop = $runq_data_store{$current_vm_name_loop}{$timestamp_str_loop} + 0;
                }
            }

            if ($enable_windowed_decay_internal)
            {
                unless (exists $current_window_vm_data_buffer{$current_vm_name_loop}{$current_window_key_loop})
                {
                    $current_window_vm_data_buffer{$current_vm_name_loop}{$current_window_key_loop} = {
                        physc_sma_queue => [], physc_prev_ema => undef, physc_ema_point_counter => [],
                        raw_physc_for_peak => [], rolling_physc_avgs => [],
                        abs_rq_values_for_perc => [], norm_rq_values_for_perc => [],
                        runq_abs_sma_queue => [], runq_abs_prev_ema => undef, runq_abs_ema_point_counter => [],
                        runq_norm_sma_queue => [], runq_norm_prev_ema => undef, runq_norm_ema_point_counter => [],
                    };
                }
                my $vm_win_buf = $current_window_vm_data_buffer{$current_vm_name_loop}{$current_window_key_loop};

                if (defined $physc_value_loop) { push @{$vm_win_buf->{raw_physc_for_peak}}, $physc_value_loop; }
                my $current_physc_avg_output_win;
                if ($avg_method eq 'sma')
                {
                    if(defined $physc_value_loop) { push @{$vm_win_buf->{physc_sma_queue}}, $physc_value_loop; }
                    else { push @{$vm_win_buf->{physc_sma_queue}}, undef; }
                    shift @{$vm_win_buf->{physc_sma_queue}} while scalar @{$vm_win_buf->{physc_sma_queue}} > $window_minutes;
                    if (scalar @{$vm_win_buf->{physc_sma_queue}} == $window_minutes) { $current_physc_avg_output_win = calculate_average(@{$vm_win_buf->{physc_sma_queue}}); }
                }
                else # EMA for PhysC (windowed)
                {
                    if (defined $physc_value_loop) {
                        if (!defined $vm_win_buf->{physc_prev_ema}) { $vm_win_buf->{physc_prev_ema} = $physc_value_loop; }
                        else { $vm_win_buf->{physc_prev_ema} = ($physc_value_loop * $alpha_for_physc_ema) + ($vm_win_buf->{physc_prev_ema} * (1 - $alpha_for_physc_ema)); }
                    }
                    push @{$vm_win_buf->{physc_ema_point_counter}}, $physc_value_loop;
                    shift @{$vm_win_buf->{physc_ema_point_counter}} while scalar @{$vm_win_buf->{physc_ema_point_counter}} > $window_minutes;
                    if (scalar @{$vm_win_buf->{physc_ema_point_counter}} == $window_minutes) { $current_physc_avg_output_win = $vm_win_buf->{physc_prev_ema}; }
                }
                push @{$vm_win_buf->{rolling_physc_avgs}}, $current_physc_avg_output_win if defined $current_physc_avg_output_win;

                if (defined $runq_value_for_this_ts_loop)
                {
                    if ($runq_avg_method_str eq 'none') { push @{$vm_win_buf->{abs_rq_values_for_perc}}, $runq_value_for_this_ts_loop; }
                    else
                    {
                        my $smoothed_abs_rq;
                        if ($runq_avg_method_str eq 'sma') {
                            push @{$vm_win_buf->{runq_abs_sma_queue}}, $runq_value_for_this_ts_loop;
                            shift @{$vm_win_buf->{runq_abs_sma_queue}} while scalar @{$vm_win_buf->{runq_abs_sma_queue}} > $window_minutes;
                            if (scalar @{$vm_win_buf->{runq_abs_sma_queue}} == $window_minutes) { $smoothed_abs_rq = calculate_average(@{$vm_win_buf->{runq_abs_sma_queue}}); }
                        } elsif ($runq_avg_method_str eq 'ema') {
                            if (!defined $vm_win_buf->{runq_abs_prev_ema}) { $vm_win_buf->{runq_abs_prev_ema} = $runq_value_for_this_ts_loop; }
                            else { $vm_win_buf->{runq_abs_prev_ema} = ($runq_value_for_this_ts_loop * $alpha_for_runq_ema) + ($vm_win_buf->{runq_abs_prev_ema} * (1-$alpha_for_runq_ema)); }
                            push @{$vm_win_buf->{runq_abs_ema_point_counter}}, $runq_value_for_this_ts_loop;
                            shift @{$vm_win_buf->{runq_abs_ema_point_counter}} while scalar @{$vm_win_buf->{runq_abs_ema_point_counter}} > $window_minutes;
                            if (scalar @{$vm_win_buf->{runq_abs_ema_point_counter}} == $window_minutes) { $smoothed_abs_rq = $vm_win_buf->{runq_abs_prev_ema}; }
                        }
                        push @{$vm_win_buf->{abs_rq_values_for_perc}}, $smoothed_abs_rq if defined $smoothed_abs_rq;
                    }
                    if (defined $physc_value_loop && $physc_value_loop >= $ACTIVE_PHYSC_THRESHOLD)
                    {
                        my $effective_lcpus = $physc_value_loop * $smt_value;
                        if ($effective_lcpus > $FLOAT_EPSILON) {
                            my $norm_runq_raw_val = $runq_value_for_this_ts_loop / $effective_lcpus;
                            if ($runq_avg_method_str eq 'none') { push @{$vm_win_buf->{norm_rq_values_for_perc}}, $norm_runq_raw_val; }
                            else {
                                my $smoothed_norm_rq;
                                if ($runq_avg_method_str eq 'sma') {
                                    push @{$vm_win_buf->{runq_norm_sma_queue}}, $norm_runq_raw_val;
                                    shift @{$vm_win_buf->{runq_norm_sma_queue}} while scalar @{$vm_win_buf->{runq_norm_sma_queue}} > $window_minutes;
                                    if (scalar @{$vm_win_buf->{runq_norm_sma_queue}} == $window_minutes) { $smoothed_norm_rq = calculate_average(@{$vm_win_buf->{runq_norm_sma_queue}}); }
                                } elsif ($runq_avg_method_str eq 'ema') {
                                    if (!defined $vm_win_buf->{runq_norm_prev_ema}) { $vm_win_buf->{runq_norm_prev_ema} = $norm_runq_raw_val; }
                                    else { $vm_win_buf->{runq_norm_prev_ema} = ($norm_runq_raw_val * $alpha_for_runq_ema) + ($vm_win_buf->{runq_norm_prev_ema} * (1-$alpha_for_runq_ema)); }
                                    push @{$vm_win_buf->{runq_norm_ema_point_counter}}, $norm_runq_raw_val;
                                    shift @{$vm_win_buf->{runq_norm_ema_point_counter}} while scalar @{$vm_win_buf->{runq_norm_ema_point_counter}} > $window_minutes;
                                    if (scalar @{$vm_win_buf->{runq_norm_ema_point_counter}} == $window_minutes) { $smoothed_norm_rq = $vm_win_buf->{runq_norm_prev_ema}; }
                                }
                                push @{$vm_win_buf->{norm_rq_values_for_perc}}, $smoothed_norm_rq if defined $smoothed_norm_rq;
                            }
                        }
                    }
                }
            }
            else # Standard Non-Windowed Processing
            {
                my $vm_overall_peak_ref_local = defined($target_vm_name) ? \$vm_physc_max_peak_scalar_overall : \$vm_physc_max_peaks_list_overall[$vm_idx];
                if ($calculate_peak && defined $physc_value_loop)
                {
                    if (!defined(${$vm_overall_peak_ref_local}) || $physc_value_loop > ${$vm_overall_peak_ref_local})
                    {
                        ${$vm_overall_peak_ref_local} = $physc_value_loop;
                    }
                }
                my $current_avg_output_value_overall;
                my $temp_fh_overall;
                my $prev_ema_ref_overall;
                my $sma_queue_ref_overall;
                my $buffer_key = "_overall_vm_$current_vm_name_loop";

                $temp_fh_overall = $temp_files_for_physc_rolling_avgs_overall{$current_vm_name_loop}{fh};

                unless (exists $current_window_vm_data_buffer{$buffer_key})
                {
                     $current_window_vm_data_buffer{$buffer_key} = { 'physc_prev_ema' => undef, 'physc_sma_queue' => [] };
                }

                $prev_ema_ref_overall = \$current_window_vm_data_buffer{$buffer_key}{'physc_prev_ema'};
                $sma_queue_ref_overall = \@{$current_window_vm_data_buffer{$buffer_key}{'physc_sma_queue'}};

                if ($avg_method eq 'sma') {
                    if(defined $physc_value_loop) { push @{$sma_queue_ref_overall}, $physc_value_loop; }
                    else { push @{$sma_queue_ref_overall}, undef; }
                    shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes;
                    if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = calculate_average(@{$sma_queue_ref_overall}); }
                } else { # EMA for PhysC (non-windowed)
                    if (defined $physc_value_loop) {
                        if (!defined ${$prev_ema_ref_overall}) { ${$prev_ema_ref_overall} = $physc_value_loop; }
                        else { ${$prev_ema_ref_overall} = ($physc_value_loop * $alpha_for_physc_ema) + (${$prev_ema_ref_overall} * (1 - $alpha_for_physc_ema)); }
                    }
                    push @{$sma_queue_ref_overall}, $physc_value_loop;
                    shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes;
                    if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = ${$prev_ema_ref_overall}; }
                }
                if (defined $current_avg_output_value_overall && defined $temp_fh_overall) {
                    print {$temp_fh_overall} "$current_avg_output_value_overall\n" or die "Error writing PhysC temp file for $current_vm_name_loop: $!";
                }

                if (defined $runq_csv_file && defined $runq_value_for_this_ts_loop && $runq_value_for_this_ts_loop =~ /^-?[0-9.]+$/) {
                     my $current_raw_abs_rq_overall = $runq_value_for_this_ts_loop + 0;
                     push @{$collected_runq_overall{$current_vm_name_loop}{abs_raw}}, $current_raw_abs_rq_overall;
                     if (defined $physc_value_loop && $physc_value_loop >= $ACTIVE_PHYSC_THRESHOLD) {
                         my $effective_lcpus = $physc_value_loop * $smt_value;
                         if ($effective_lcpus > $FLOAT_EPSILON) {
                             push @{$collected_runq_overall{$current_vm_name_loop}{norm_raw}}, ($current_raw_abs_rq_overall / $effective_lcpus);
                         }
                     }
                }
            }
        }
        if ($data_lines_processed > 0 && $data_lines_processed % 10000 == 0)
        {
            print STDERR "Processed $data_lines_processed NMON data lines (matching filters).\n";
        }
    }
    close $physc_csv_fh;

    if ($enable_windowed_decay_internal)
    {
        if ($current_window_idx < @processing_windows && %current_window_vm_data_buffer)
        {
             process_and_store_window_results(
                $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window,
                \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
                $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc,
                $runq_avg_method_str, $window_minutes, $alpha_for_physc_ema
            );
        }
    }
    else
    {
        foreach my $vm_name_local (keys %temp_files_for_physc_rolling_avgs_overall) # Use local var
        {
            if (defined $temp_files_for_physc_rolling_avgs_overall{$vm_name_local}{fh})
            {
                close $temp_files_for_physc_rolling_avgs_overall{$vm_name_local}{fh} or warn "Could not close temp file for $vm_name_local: $!";
            }
        }
        if (defined $runq_csv_file && $runq_avg_method_str ne 'none')
        {
            print STDERR "Calculating overall smoothed RunQ values for non-windowed mode...\n";
            foreach my $vm_name_local (keys %collected_runq_overall) # Use local var
            {
                if (exists $collected_runq_overall{$vm_name_local}{abs_raw} && @{$collected_runq_overall{$vm_name_local}{abs_raw}})
                {
                    my $smoothed_series_ref = calculate_rolling_average_series(
                        \@{$collected_runq_overall{$vm_name_local}{abs_raw}}, $runq_avg_method_str, $window_minutes, $alpha_for_runq_ema
                    );
                    $collected_runq_overall{$vm_name_local}{abs_smoothed} = $smoothed_series_ref;
                }
                if (exists $collected_runq_overall{$vm_name_local}{norm_raw} && @{$collected_runq_overall{$vm_name_local}{norm_raw}})
                {
                    my $smoothed_series_ref = calculate_rolling_average_series(
                        \@{$collected_runq_overall{$vm_name_local}{norm_raw}}, $runq_avg_method_str, $window_minutes, $alpha_for_runq_ema
                    );
                    $collected_runq_overall{$vm_name_local}{norm_smoothed} = $smoothed_series_ref;
                }
            }
        }
    }
    print STDERR "Finished reading NMON data ($data_lines_processed lines matching filters).\n";

    my @results_data_output;
    my @vms_for_final_output_loop = defined($target_vm_name) ? ($target_vm_name) : @vm_names_from_physc_header;

    foreach my $vm_name_loop (@vms_for_final_output_loop)
    {
        my $output_line_for_vm = "$vm_name_loop:";
        my %final_metrics_for_vm;

        if ($enable_windowed_decay_internal)
        {
            my $p_label_main_decay = sprintf("P%.2f", $percentile);
            $p_label_main_decay =~ s/\.?0+$//;
            $p_label_main_decay = "0" if $p_label_main_decay eq "" && abs($percentile-0)<0.001;
            $p_label_main_decay = "P$p_label_main_decay" unless $p_label_main_decay =~ /^P/;

            my $baseline_weighted_metric_val_str = get_weighted_metric_for_vm(
                \%vm_data_by_window, $vm_name_loop, $p_label_main_decay,
                \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val
            );
            $final_metrics_for_vm{$p_label_main_decay} = $baseline_weighted_metric_val_str;

            my $growth_adj_value_for_output = 0.0;

            if ($enable_growth_prediction)
            {
                print STDERR "INFO [$vm_name_loop]: Performing Growth Prediction processing ($p_label_main_decay)...\n" if ($verbose);
                my $baseline_for_growth_str = $final_metrics_for_vm{$p_label_main_decay};
                my $growth_skipped_reason = "";
                $final_metrics_for_vm{"GrowthAdjAbs"} = "0.0000";

                if (defined $baseline_for_growth_str && $baseline_for_growth_str ne "N/A" && $baseline_for_growth_str =~ /^-?[0-9.]+$/)
                {
                    my $current_baseline_entitlement_for_growth = $baseline_for_growth_str + 0;
                    my @metric_time_series_points;
                    my @metric_time_series_values;

                    if (exists $vm_data_by_window{$vm_name_loop})
                    {
                        my $time_idx = 0;
                        foreach my $win_key (sort {
                                                my ($ad, $ai) = ($a =~ /^(\d{8})_(\d+)$/);
                                                my ($bd, $bi) = ($b =~ /^(\d{8})_(\d+)$/);
                                                return ($ad cmp $bd) || ($ai <=> $bi);
                                             } keys %{$vm_data_by_window{$vm_name_loop}})
                        {
                            if (exists $vm_data_by_window{$vm_name_loop}{$win_key}{$p_label_main_decay} &&
                                defined $vm_data_by_window{$vm_name_loop}{$win_key}{$p_label_main_decay} &&
                                $vm_data_by_window{$vm_name_loop}{$win_key}{$p_label_main_decay} ne "N/A" &&
                                $vm_data_by_window{$vm_name_loop}{$win_key}{$p_label_main_decay} =~ /^-?[0-9.]+$/)
                            {
                                my $metric_val = $vm_data_by_window{$vm_name_loop}{$win_key}{$p_label_main_decay} + 0;
                                push @metric_time_series_points, [$time_idx, $metric_val];
                                push @metric_time_series_values, $metric_val;
                                $time_idx++;
                            }
                        }
                    }

                    my $num_hist_periods_for_trend = scalar @metric_time_series_points;
                    print STDERR "INFO [$vm_name_loop]: Found $num_hist_periods_for_trend historical periods for $p_label_main_decay trend analysis.\n" if ($verbose);

                    if ($num_hist_periods_for_trend < $GROWTH_MIN_HISTORICAL_PERIODS)
                    {
                        $growth_skipped_reason = "Insufficient historical periods ($num_hist_periods_for_trend < $GROWTH_MIN_HISTORICAL_PERIODS)";
                    }
                    else
                    {
                        my $stats_for_trend = calculate_statistics_for_trend(\@metric_time_series_values);
                        my $cv_for_trend = (defined $stats_for_trend && defined $stats_for_trend->{cv}) ? $stats_for_trend->{cv} : undef;
                        print STDERR "INFO [$vm_name_loop]: Trend data stats - Mean: " . (defined $stats_for_trend ? sprintf("%.4f", $stats_for_trend->{mean}) : "N/A") .
                                     ", StdDev: " . (defined $stats_for_trend ? sprintf("%.4f", $stats_for_trend->{stddev}) : "N/A") .
                                     ", CV: " . (defined $cv_for_trend ? sprintf("%.4f", $cv_for_trend) : "N/A") . ".\n" if ($verbose);

                        if (defined $cv_for_trend && abs($cv_for_trend) > $GROWTH_MAX_CV_THRESHOLD)
                        {
                            $growth_skipped_reason = sprintf("High volatility (CV %.2f > threshold %.2f)", $cv_for_trend, $GROWTH_MAX_CV_THRESHOLD);
                        }
                        else
                        {
                            my $regression_results = calculate_manual_linear_regression(\@metric_time_series_points);
                            if (defined $regression_results && defined $regression_results->{slope})
                            {
                                my $slope     = $regression_results->{slope};
                                my $r_squared = $regression_results->{r_squared};
                                print STDERR "INFO [$vm_name_loop]: Linear regression - Slope: " . sprintf("%.4f units/%s", $slope, $process_window_unit_str) .
                                             (defined $r_squared ? sprintf(" (RÂ²: %.4f)", $r_squared) : "") . ".\n" if ($verbose);

                                if ($slope <= 0 || ($slope > 0 && $slope < $GROWTH_MIN_POSITIVE_SLOPE_THRESHOLD) )
                                {
                                    $growth_skipped_reason = sprintf("Slope (%.4f) not sufficiently positive (min threshold for inflation: %.4f) or is non-positive", $slope, $GROWTH_MIN_POSITIVE_SLOPE_THRESHOLD);
                                }
                                else
                                {
                                    my $days_per_hist_window = ($process_window_unit_str eq "weeks" ? 7 : 1);
                                    my $total_hist_duration_days_for_trend = $num_hist_periods_for_trend * $days_per_hist_window;

                                    if ($total_hist_duration_days_for_trend > 0 && ($growth_projection_days / $total_hist_duration_days_for_trend) > $GROWTH_MAX_PROJECTION_HISTORY_RATIO)
                                    {
                                        $growth_skipped_reason = sprintf("Projection horizon (%d days) too long for available history (%.1f days, ratio limit %.1f)",
                                                                         $growth_projection_days, $total_hist_duration_days_for_trend, $GROWTH_MAX_PROJECTION_HISTORY_RATIO);
                                    }
                                    else
                                    {
                                        my $num_effective_projection_periods = $growth_projection_days / $days_per_hist_window;
                                        my $projected_absolute_increase = $slope * $num_effective_projection_periods;
                                        print STDERR "INFO [$vm_name_loop]: Growth Prediction: Raw projected increase over $growth_projection_days days: " . sprintf("%.4f", $projected_absolute_increase) . ".\n" if ($verbose);

                                        $final_metrics_for_vm{"GrowthAdjAbs"} = sprintf("%.4f", ($projected_absolute_increase < 0 ? 0 : $projected_absolute_increase) );

                                        my $max_allowed_increase_by_cap = $current_baseline_entitlement_for_growth * ($max_growth_inflation_percent / 100.0);
                                        print STDERR "INFO [$vm_name_loop]: Growth Prediction: Max allowed inflation ($max_growth_inflation_percent% of baseline " . sprintf("%.4f", $current_baseline_entitlement_for_growth) . "): " . sprintf("%.4f", $max_allowed_increase_by_cap) . ".\n" if ($verbose);

                                        my $final_capped_increase = $projected_absolute_increase;
                                        if ($final_capped_increase > $max_allowed_increase_by_cap)
                                        {
                                            $final_capped_increase = $max_allowed_increase_by_cap;
                                            print STDERR "INFO [$vm_name_loop]: Growth capped: projected +" . sprintf("%.4f", $projected_absolute_increase) .
                                                         " cores â +" . sprintf("%.4f", $final_capped_increase) .
                                                         " cores (" . $max_growth_inflation_percent . "% max).\n";

                                        }
                                        $final_capped_increase = 0 if $final_capped_increase < 0;

                                        $growth_adj_value_for_output = $final_capped_increase;
                                        my $inflated_recommendation = $current_baseline_entitlement_for_growth + $growth_adj_value_for_output;

                                        print STDERR "INFO [$vm_name_loop]: Growth Prediction: Inflated $p_label_main_decay: " . sprintf("%.4f", $inflated_recommendation) . " (+" . sprintf("%.4f", $growth_adj_value_for_output) . ").\n";
                                        $final_metrics_for_vm{$p_label_main_decay} = sprintf("%.4f", $inflated_recommendation);
                                    }
                                }
                            }
                            else
                            {
                                $growth_skipped_reason = "Linear regression failed (e.g., could not calculate slope)";
                            }
                        }
                    }
                }
                else
                {
                    $growth_skipped_reason = "Baseline metric for growth ($p_label_main_decay = $baseline_for_growth_str) is N/A or not numeric";
                }

                if ($growth_skipped_reason ne "" && $verbose)
                {
                    print STDERR "WARN [$vm_name_loop]: Growth projection for $p_label_main_decay skipped: $growth_skipped_reason.\n";
                }
                $final_metrics_for_vm{"GrowthAdj"} = sprintf("%.4f", $growth_adj_value_for_output);
                print STDERR "INFO [$vm_name_loop]: Growth prediction processing for $p_label_main_decay finished.\n" if ($verbose);
            }
            else
            {
                 $final_metrics_for_vm{"GrowthAdj"} = "0.0000";
            }
            if ($calculate_peak)
            {
                $final_metrics_for_vm{'Peak'} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name_loop, 'Peak', \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val);
            }
            if (defined $runq_csv_file)
            {
                foreach my $p_val (@runq_norm_percentiles_to_calc)
                {
                    my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//; $p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001;
                    my $mk="NormRunQ_P$p_lbl_base";
                    $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name_loop, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");
                }
                foreach my $p_val (@runq_abs_percentiles_to_calc)
                {
                    my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//; $p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001;
                    my $mk="AbsRunQ_P$p_lbl_base";
                    $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name_loop, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");
                }
            }
        }
        else
        {
            my $temp_file_path_val = $temp_files_for_physc_rolling_avgs_overall{$vm_name_loop}{filename};
            my @physc_avg_values_from_file;
            my $percentile_val_raw_overall = undef;
            my $vm_idx_overall = (defined($target_vm_name) && $target_vm_name eq $vm_name_loop) ? $target_vm_index_in_physc : get_vm_index_by_name($vm_name_loop, \@vm_names_from_physc_header);
            my $peak_val_raw_overall = defined($target_vm_name) ? $vm_physc_max_peak_scalar_overall : ( (defined $vm_idx_overall && $vm_idx_overall <= $#vm_physc_max_peaks_list_overall && defined $vm_physc_max_peaks_list_overall[$vm_idx_overall]) ? $vm_physc_max_peaks_list_overall[$vm_idx_overall] : undef);

            if (defined $temp_file_path_val && -f $temp_file_path_val && -s $temp_file_path_val) {
                open my $in_fh, '<', $temp_file_path_val or print STDERR "Warning: Could not open temp file $temp_file_path_val for $vm_name_loop: $!\n";
                if ($in_fh) {
                    while (my $num = <$in_fh>) { chomp $num; if ($num =~ /^-?[0-9]+(?:\.[0-9]+)?$/) { push @physc_avg_values_from_file, $num; } }
                    close $in_fh;
                }
            }
            unlink $temp_file_path_val or warn "Could not delete temporary file '$temp_file_path_val': $!" if defined $temp_file_path_val && -f $temp_file_path_val;

            if (@physc_avg_values_from_file && defined $filter_above_perc_value) {
                 my @sff = sort { $a <=> $b } @physc_avg_values_from_file;
                 my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
                 if (defined $ft) {
                     my @fa = grep { defined($_) && $_ >= ($ft - $FLOAT_EPSILON) } @physc_avg_values_from_file;
                     if (@fa) { my @sf = sort { $a <=> $b } @fa; $percentile_val_raw_overall = calculate_percentile(\@sf, $percentile); }
                     else { $percentile_val_raw_overall = undef; }
                 } else {
                     if (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile); }
                 }
            } elsif (@physc_avg_values_from_file) {
                my @sa = sort { $a <=> $b } @physc_avg_values_from_file;
                $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile);
            }

            my $p_label_main_overall = sprintf("P%.2f", $percentile);
            $p_label_main_overall =~ s/\.?0+$//;
            $p_label_main_overall = "0" if $p_label_main_overall eq "" && abs($percentile-0)<0.001;
            $p_label_main_overall = "P$p_label_main_overall" unless $p_label_main_overall =~ /^P/;
            $final_metrics_for_vm{$p_label_main_overall} = defined($percentile_val_raw_overall) ? $percentile_val_raw_overall : "N/A";

            if ($calculate_peak) {
                $final_metrics_for_vm{'Peak'} = defined($peak_val_raw_overall) ? $peak_val_raw_overall : "N/A";
            }

            if (defined $runq_csv_file && exists $collected_runq_overall{$vm_name_loop}) {
                my $norm_data_source_ref = ($runq_avg_method_str ne 'none' && exists $collected_runq_overall{$vm_name_loop}{norm_smoothed})
                                         ? $collected_runq_overall{$vm_name_loop}{norm_smoothed}
                                         : (exists $collected_runq_overall{$vm_name_loop}{norm_raw} ? \@{$collected_runq_overall{$vm_name_loop}{norm_raw}} : undef );
                my $abs_data_source_ref  = ($runq_avg_method_str ne 'none' && exists $collected_runq_overall{$vm_name_loop}{abs_smoothed})
                                         ? $collected_runq_overall{$vm_name_loop}{abs_smoothed}
                                         : (exists $collected_runq_overall{$vm_name_loop}{abs_raw} ? \@{$collected_runq_overall{$vm_name_loop}{abs_raw}} : undef );

                if (defined $norm_data_source_ref && @{$norm_data_source_ref}) {
                    my @sorted_norm = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$norm_data_source_ref};
                    if (@sorted_norm) {
                        foreach my $p_val (@runq_norm_percentiles_to_calc) {
                            my $val = calculate_percentile(\@sorted_norm, $p_val);
                            my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                            $final_metrics_for_vm{"NormRunQ_P$p_num_for_key"} = defined($val)?sprintf("%.2f",$val):"N/A";
                        }
                    } else {
                         foreach my $p_val (@runq_norm_percentiles_to_calc) {
                             my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                             $final_metrics_for_vm{"NormRunQ_P$p_num_for_key"} = "N/A";
                         }
                    }
                } else {
                     foreach my $p_val (@runq_norm_percentiles_to_calc) {
                         my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                         $final_metrics_for_vm{"NormRunQ_P$p_num_for_key"} = "N/A";
                     }
                }
                if (defined $abs_data_source_ref && @{$abs_data_source_ref}) {
                    my @sorted_abs = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$abs_data_source_ref};
                    if (@sorted_abs) {
                        foreach my $p_val (@runq_abs_percentiles_to_calc) {
                            my $val = calculate_percentile(\@sorted_abs, $p_val);
                            my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                            $final_metrics_for_vm{"AbsRunQ_P$p_num_for_key"} = defined($val)?sprintf("%.2f",$val):"N/A";
                        }
                    } else {
                        foreach my $p_val (@runq_abs_percentiles_to_calc) {
                            my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                            $final_metrics_for_vm{"AbsRunQ_P$p_num_for_key"} = "N/A";
                        }
                    }
                } else {
                    foreach my $p_val (@runq_abs_percentiles_to_calc) {
                        my $p_num_for_key = sprintf("%.2f",$p_val); $p_num_for_key =~ s/\.?0+$//; $p_num_for_key = "0" if $p_num_for_key eq "" && abs($p_val-0)<0.001;
                        $final_metrics_for_vm{"AbsRunQ_P$p_num_for_key"} = "N/A";
                    }
                }
            }
            if ($enable_growth_prediction)
            {
                $final_metrics_for_vm{"GrowthAdj"} = "0.0000";
            }
        }

        my $p_label_out_final = sprintf("P%.2f", $percentile);
        $p_label_out_final =~ s/\.?0+$//;
        $p_label_out_final = "0" if $p_label_out_final eq "" && abs($percentile-0)<0.001;
        $p_label_out_final = "P$p_label_out_final" unless $p_label_out_final =~ /^P/;
        my $physc_p_val_to_print = $final_metrics_for_vm{$p_label_out_final} // "N/A";

        if ($physc_p_val_to_print ne "N/A" && $physc_p_val_to_print =~ /^-?[0-9.]+$/)
        {
            my $r_val = apply_rounding($physc_p_val_to_print, $round_increment, $rounding_method);
            $output_line_for_vm .= " $p_label_out_final=" . sprintf("%.${output_dp}f", $r_val);
        }
        else
        {
            $output_line_for_vm .= " $p_label_out_final=N/A";
        }

        if ($calculate_peak)
        {
            my $peak_val_to_print = $final_metrics_for_vm{'Peak'} // "N/A";
            if ($peak_val_to_print ne "N/A" && $peak_val_to_print =~ /^-?[0-9.]+$/)
            {
                my $r_val = apply_rounding($peak_val_to_print, $round_increment, $rounding_method);
                $output_line_for_vm .= " Peak=" . sprintf("%.${output_dp}f", $r_val);
            }
            else
            {
                $output_line_for_vm .= " Peak=N/A";
            }
        }

        my @runq_metric_keys_ordered_for_output;
        if (defined $runq_csv_file)
        {
            foreach my $p_val (@runq_norm_percentiles_to_calc)
            {
                my $p_num_label = sprintf("%.2f", $p_val); $p_num_label =~ s/\.?0+$//; $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
                push @runq_metric_keys_ordered_for_output, "NormRunQ_P$p_num_label";
            }
            foreach my $p_val (@runq_abs_percentiles_to_calc)
            {
                my $p_num_label = sprintf("%.2f", $p_val); $p_num_label =~ s/\.?0+$//; $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
                push @runq_metric_keys_ordered_for_output, "AbsRunQ_P$p_num_label";
            }
        }
        foreach my $key (@runq_metric_keys_ordered_for_output)
        {
            $output_line_for_vm .= " $key=" . ($final_metrics_for_vm{$key} // "N/A");
        }

        if ($enable_growth_prediction)
        {
            my $growth_adj_display_val = $final_metrics_for_vm{"GrowthAdj"} // "0.0000";
            if ($growth_adj_display_val =~ /^-?[0-9.]+$/)
            {
                $output_line_for_vm .= sprintf(" GrowthAdj=%.4f", $growth_adj_display_val + 0);
            }
            else
            {
                 $output_line_for_vm .= " GrowthAdj=$growth_adj_display_val";
            }
            my $growth_adj_abs_display_val = $final_metrics_for_vm{"GrowthAdjAbs"} // "0.0000";
            if ($growth_adj_abs_display_val =~ /^-?[0-9.]+$/)
            {
                $output_line_for_vm .= sprintf(" GrowthAdjAbs=%.4f", $growth_adj_abs_display_val + 0);
            }
            else
            {
                 $output_line_for_vm .= " GrowthAdjAbs=$growth_adj_abs_display_val";
            }
        }

        push @results_data_output, { line => $output_line_for_vm };
    }

    my @output_header_cols = ("VM_Name", "State", "Duration_Days", "Entitlement", "MaxCPU", "SMT", "Processor", "SerialNumber", "PoolID");
    my @metric_keys_in_order = ("P" . clean_perc_label($percentile));
    push @metric_keys_in_order, 'Peak' if $calculate_peak;
    foreach my $p (@runq_norm_percentiles_to_calc) { push @metric_keys_in_order, "NormRunQ_P" . clean_perc_label($p); }
    foreach my $p (@runq_abs_percentiles_to_calc) { push @metric_keys_in_order, "AbsRunQ_P" . clean_perc_label($p); }
    if ($enable_growth_prediction) {
        push @metric_keys_in_order, "GrowthAdj", "GrowthAdjAbs";
    }
    push @output_header_cols, @metric_keys_in_order;
#    print STDOUT join(",", @output_header_cols) . "\n";

    # Print the new standardized summary if there are results.
    if (@results_data_output)
    {
        print STDERR generate_run_summary_string();

        print STDOUT "\n------------------------------------------------------------------\n";
        print STDOUT "Results\n";
        print STDOUT "------------------------------------------------------------------\n";

# This loop now simply prints the pre-formatted key=value string for each VM.
        foreach my $res (@results_data_output)
        {
            print STDOUT $res->{line} . "\n";
        }
    }
    else
    {
        print STDERR "\n--- No results generated for this run (check filters/data) ---\n";
    }
}

my $script_end_time = time();
my $duration = $script_end_time - $script_start_time;
print STDERR "\nCompleted in $duration second(s).\n\n";
exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================

# --- clean_perc_label ---
# Helper to format a percentile number into a clean string for metric keys.
sub clean_perc_label {
    my ($p) = @_;
    my $label = sprintf("%.2f", $p);
    $label =~ s/\.?0+$//;
    $label = "0" if $label eq "" && abs($p-0)<0.001;
    return $label;
}

# --- calculate_rolling_average ---
# Generic sub to calculate a single rolling average point (SMA or EMA).
sub calculate_rolling_average {
    my ($value, $method, $sma_queue_aref, $prev_ema_sref, $window, $alpha) = @_;

    my $avg_to_return;
    if ($method eq 'sma') {
        push @$sma_queue_aref, $value;
        shift @$sma_queue_aref while @$sma_queue_aref > $window;
        if (@$sma_queue_aref == $window) {
            $avg_to_return = calculate_average(@$sma_queue_aref);
        }
    } else { # ema
        if (defined $value) {
            if (!defined $$prev_ema_sref) { $$prev_ema_sref = $value; }
            else { $$prev_ema_sref = ($value * $alpha) + ($$prev_ema_sref * (1 - $alpha)); }
        }
        push @$sma_queue_aref, $value; # Use sma_queue as a simple counter
        shift @$sma_queue_aref while @$sma_queue_aref > $window;
        if (@$sma_queue_aref == $window) {
            $avg_to_return = $$prev_ema_sref;
        }
    }
    return $avg_to_return;
}

# --- define_configuration_states ---
# Performs the first pass over all .nmon files in a directory to detect
# changes in key configuration metadata (SMT, Entitlement, vCPU, etc.).
# It builds a timeline of these changes and consolidates them into discrete
# "state windows" where the configuration for a VM was static.
#
# Args:
#   1. $dir (string): The path to the directory containing .nmon files.
#
# Returns:
#   - A hash reference where keys are VM names. Each VM name maps to an array
#     of state window hashes. Each state window hash contains:
#     {
#       vm_name      => string,
#       state_id     => int,
#       start_time   => Time::Piece object,
#       end_time     => Time::Piece object,
#       duration_days => float,
#       metadata     => {
#         smt          => int,
#         entitlement  => float,
#         virtual_cpus => int,
#         pool_cpu     => int,
#         capped       => int (0 or 1),
#         max_cpu      => float,
#         proc_type    => string,
#         proc_version => string,
#         proc_clock   => string,
#         processor_state => string
#       }
#     }
# ==============================================================================
# Subroutines for v3 State Management
# ==============================================================================

# --- define_configuration_states ---
# Performs the first pass over all .nmon files in a directory to detect
# changes in key configuration metadata (SMT, Entitlement, vCPU, etc.).
# It builds a timeline of these changes and consolidates them into discrete
# "state windows" where the configuration for a VM was static.
#
# Args:
#   1. $dir (string): The path to the directory containing .nmon files.
#
# Returns:
#   - A hash reference where keys are VM names. Each VM name maps to an array
#     of state window hashes.
#
sub define_configuration_states
{
    my ($dir, $default_smt) = @_;

    my @nmon_files;
    find( sub { push @nmon_files, $File::Find::name if -f && /\.nmon$/i; }, $dir );

    unless (@nmon_files)
    {
        die "Error: No .nmon files found in directory '$dir'.\n";
    }

    @nmon_files = sort @nmon_files;
    print STDERR "  Found " . scalar(@nmon_files) . " NMON files to scan for metadata.\n";

    my %config_events_by_vm;
    my %file_boundaries;

    # --- Pass 1.1: Scan each file to gather all raw metadata events ---
    foreach my $file_path (@nmon_files)
    {
        open my $fh, '<:encoding(utf8)', $file_path or do {
            warn "Warning: Could not open '$file_path': $!. Skipping.";
            next;
        };

        my $current_vm;
        my %zzzz_map;
        my %file_static_config;

        while (my $line = <$fh>)
        {
            chomp $line; $line =~ s/\r$//;
            my @fields = split ',', $line;
            my $key = $fields[0];

            if ($key eq 'AAA' && $fields[1] eq 'host') {
               $current_vm = $fields[2];
            }
            elsif ($key eq 'AAA' && $fields[1] eq 'SerialNumber') {
                $file_static_config{serial_number} = $fields[2];
            }
            elsif ($key eq 'ZZZZ') {
                my ($t_num, $time, $date_str) = @fields[1..3];
                my $tp_date;
                eval { $tp_date = Time::Piece->strptime($date_str, "%d-%b-%Y"); };
                if ($@ || !$tp_date) { eval { $tp_date = Time::Piece->strptime($date_str, "%d-%B-%Y"); }; }
                next if ($@ || !$tp_date);
                my $timestamp = $tp_date->ymd . " " . $time;
                $zzzz_map{$t_num} = $timestamp;
                $file_boundaries{$current_vm}{$timestamp} = 1;
            }
            elsif ($key eq 'BBBL') {
                my ($id, $bkey, $bval) = @fields[1..3];
                if    ($id eq '04') { $file_static_config{virtual_cpus} = $bval + 0 if looks_like_number($bval); }
                elsif ($id eq '06') { $file_static_config{smt}          = $bval + 0 if looks_like_number($bval); }
                elsif ($id eq '07') { $file_static_config{capped}       = ($bval =~ /true|1/i ? 1 : 0); }
                elsif ($id eq '18') { $file_static_config{pool_cpu}      = $bval + 0 if looks_like_number($bval); }
            }
            elsif ($key eq 'BBBP') {
                my $bval = $fields[3] // "";
                if    ($bval =~ /"Processor Type:\s*(.+?)"?$/)    { $file_static_config{proc_type} = $1; }
                elsif ($bval =~ /"Processor Version:\s*(.+?)"?$/) { $file_static_config{proc_version} = $1; }
                elsif ($bval =~ /"Processor Clock Speed:\s*(\d+)/){ $file_static_config{proc_clock} = $1; }
                elsif ($bval =~ /Shared Pool ID\s*:\s*(\d+)/) { $file_static_config{pool_id} = $1; }
            }
            elsif ($key eq 'LPAR') {
                my $t_num = $fields[1];
                if (defined $zzzz_map{$t_num}) {
                    my $ts_obj = Time::Piece->strptime($zzzz_map{$t_num}, "%Y-%m-%d %H:%M:%S");
                    my $ent_val = $fields[6]; # Entitled is 5th field after Txxxx
                    if (defined $ent_val && looks_like_number($ent_val)) {
                        push @{$config_events_by_vm{$current_vm}}, { ts => $ts_obj->epoch, key => 'entitlement', value => $ent_val + 0 };
                    }
                }
            }
        }
        close $fh;

        if (defined $current_vm && %file_static_config) {
            my @file_ts_epochs = map { Time::Piece->strptime($_, "%Y-%m-%d %H:%M:%S")->epoch } values %zzzz_map;
            next unless @file_ts_epochs;
            my $file_start_ts = (sort {$a <=> $b} @file_ts_epochs)[0];
            foreach my $key (keys %file_static_config) {
                push @{$config_events_by_vm{$current_vm}}, { ts => $file_start_ts, key => $key, value => $file_static_config{$key} };
            }
        }
    }

    # --- Pass 1.2: Process events grouped by timestamp to define state windows ---
    my %all_vm_states;
    foreach my $vm_name (sort keys %config_events_by_vm) {
        # Group all events by their exact timestamp to treat changes at one moment as atomic.
        my %events_by_ts;
        foreach my $event (@{$config_events_by_vm{$vm_name}}) {
            $events_by_ts{$event->{ts}}{$event->{key}} = $event->{value};
        }

        my @sorted_timestamps = sort {$a <=> $b} keys %events_by_ts;
        next unless @sorted_timestamps;

        my %last_known_metadata;
        my $last_fingerprint = "";
        my $current_state_start_epoch;

        # Iterate through the unique timestamps where configuration changes occurred.
        for (my $i = 0; $i < @sorted_timestamps; $i++) {
            my $ts = $sorted_timestamps[$i];

            # Create a snapshot of the current state BEFORE applying the new events
            my %metadata_before_change = %last_known_metadata;

            # Apply all events for this timestamp to a temporary hash to create the new state
            my %snapshot_metadata = %last_known_metadata;
            foreach my $key (keys %{$events_by_ts{$ts}}) {
                $snapshot_metadata{$key} = $events_by_ts{$ts}{$key};
            }

            my $current_fingerprint = join "|", map { $snapshot_metadata{$_} // 'U' }
                                      sort qw(entitlement smt virtual_cpus pool_cpu capped proc_type proc_version proc_clock);

            if ($i == 0) {
                # This is the very first event for the VM. Initialize the first state.
                $last_fingerprint = $current_fingerprint;
                $current_state_start_epoch = $ts;
            } elsif ($current_fingerprint ne $last_fingerprint) {
                # A change was detected. Finalize the PREVIOUS state using the metadata from before the change.
                push @{$all_vm_states{$vm_name}}, {
                    start_epoch => $current_state_start_epoch,
                    end_epoch   => $ts - 1, # End time is 1 second before the change.
                    metadata    => { %metadata_before_change } # CRITICAL: Use the state BEFORE the change.
                };

                # Start the new state.
                $current_state_start_epoch = $ts;
                $last_fingerprint = $current_fingerprint;
            }

            # Persist the fully updated state for the next iteration.
            %last_known_metadata = %snapshot_metadata;
        }

        # After the loop, finalize the very last state for the VM.
        my $vm_timestamps = [sort {$a <=> $b} map {Time::Piece->strptime($_, "%Y-%m-%d %H:%M:%S")->epoch} keys %{$file_boundaries{$vm_name}}];
        my $final_end_epoch = @$vm_timestamps ? $vm_timestamps->[-1] : $current_state_start_epoch;

        if (defined $current_state_start_epoch) {
            push @{$all_vm_states{$vm_name}}, {
                start_epoch => $current_state_start_epoch,
                end_epoch   => $final_end_epoch,
                metadata    => \%last_known_metadata
            };
        }

        # Post-process: Add IDs, duration, and calculated fields
        for (my $i=0; $i < @{$all_vm_states{$vm_name} || []}; $i++) {
            my $state = $all_vm_states{$vm_name}[$i];
            $state->{state_id} = $i + 1;
            $state->{start_time} = Time::Piece->new($state->{start_epoch});
            $state->{end_time} = Time::Piece->new($state->{end_epoch});
            $state->{duration_days} = ($state->{end_epoch} - $state->{start_epoch}) / (60*60*24);
            $state->{vm_name} = $vm_name;

            my $md = $state->{metadata};
            $md->{smt} //= $default_smt;
            my $ent = $md->{entitlement} // 0;
            my $vcpu = $md->{virtual_cpus} // 0;
            my $poolcpu = $md->{pool_cpu} // 0;
            my $is_capped = $md->{capped} // 0;
            $md->{lpar_state} = "capped=$is_capped";

            my $max_cpu_calc = $is_capped ? $ent : ($poolcpu > 0 && $vcpu > 0 ? min($vcpu, $poolcpu) : $vcpu);
            $md->{max_cpu} = $max_cpu_calc > 0 ? $max_cpu_calc : ($vcpu > 0 ? $vcpu : 0);

            my $p_type = $md->{proc_type} // 'UNK'; $p_type =~ s/PowerPC_//;
            my $p_ver = $md->{proc_version} // 'UNK';
            my $p_clk = $md->{proc_clock} // 'UNK';

            $md->{processor_state} = join("_", $p_type, $p_ver, $p_clk);
            $md->{processor_state} =~ s/\s+/-/g;
            $md->{duration_days} = $state->{duration_days};
        }
    }

    print STDERR "Phase 1 finished. Found states for " . scalar(keys %all_vm_states) . " VMs.\n";
    return \%all_vm_states;
}

# --- print_state_windows_report ---
# Takes the data structure returned by define_configuration_states and
# prints a formatted, compact report to STDOUT.
#
# Args:
#   1. $states_href (hash ref): The state windows data structure.
#
sub print_state_windows_report
{
    my ($states_href) = @_;

    my $header_format = "%-20s %-10s %-20s %-20s %-10s %-45s %s\n";
    my $row_format    = "%-20s %-10s %-20s %-20s %-10.2f %-45s %s\n";

    printf $header_format, "VM_Name", "State_ID", "Start_Time", "End_Time", "Duration", "Config_Summary", "Processor";

    my $separator = ("-" x 20) . " " . ("-" x 10) . " " . ("-" x 20) . " " . ("-" x 20) . " " . ("-" x 10) . " " . ("-" x 45) . " " . ("-" x 30) . "\n";
    print STDOUT $separator;

    foreach my $vm_name (sort keys %$states_href)
    {
        my @vm_states = @{$states_href->{$vm_name}};
        my $total_states = scalar(@vm_states);
        foreach my $state (@vm_states)
        {
            my $md = $state->{metadata};

            # Build the compact configuration summary string
            my $capped_str = ($md->{capped} // 0) ? "Capped" : "Uncapped";
            my $config_summary = sprintf("Ent:%.2f vCPU:%d PoolCPU:%d SMT:%d %s",
                $md->{entitlement} // 0,
                $md->{virtual_cpus} // 0,
                $md->{pool_cpu} // 0,
                $md->{smt} // 0,
                $capped_str
            );

            printf $row_format,
                $state->{vm_name},
                $state->{state_id} . "/" . $total_states,
                $state->{start_time}->strftime('%Y-%m-%d %H:%M'),
                $state->{end_time}->strftime('%Y-%m-%d %H:%M'),
                $state->{duration_days},
                $config_summary,
                $md->{processor_state};
        }
    }
}

# --- parse_state_selector ---
# Parses the user's state selection string (e.g., "1,3,5-7,-1") and returns
# an array of the actual state window objects that match the selection.
#
# Args:
#   1. $selector_str (string): The raw string from the --include-states flag.
#   2. $available_states_aref (array ref): An array of all state window hashes for a VM.
#
# Returns:
#   - An array containing the state window hashes that were selected.
#
sub parse_state_selector
{
    my ($selector_str, $available_states_aref) = @_;
    my @selected_states;
    return @$available_states_aref if (lc($selector_str) eq 'all');
    return () if (scalar(@$available_states_aref) == 0);
    my %selected_ids;
    my $total_states = scalar(@$available_states_aref);
    my @parts = split ',', $selector_str;
    foreach my $part (@parts) {
        $part =~ s/\s+//g;
        if ($part =~ /^(\d+)-(\d+)$/) {
            for my $id ($1 .. $2) { $selected_ids{$id} = 1; }
        } elsif ($part =~ /^-(\d+)$/) {
            my $offset = $1;
            if ($total_states - $offset >= 0) { $selected_ids{ $total_states - ($offset - 1) } = 1; }
        } elsif ($part =~ /^\d+$/) {
            $selected_ids{$part} = 1;
        }
    }
    foreach my $state (@$available_states_aref) {
        push @selected_states, $state if exists $selected_ids{$state->{state_id}};
    }
    return @selected_states;
}

sub process_nmon_directory
{
    my ($dir, $physc_out_fh, $runq_out_fh) = @_;

    opendir(my $dh, $dir) or die "Error: Cannot open directory '$dir': $!";
    my @nmon_files = grep { /\.nmon$/ && -f File::Spec->catfile($dir, $_) } readdir($dh);
    closedir($dh);

    if (!@nmon_files)
    {
        die "Error: No .nmon files found in directory '$dir'.\n";
    }

    my %data; # {timestamp} -> {vm_name} -> {physc => val, runq => val}
    my %vm_names;
    my $smt_value_from_file;

    # First pass: Get SMT from the first file
    my $first_file_path = File::Spec->catfile($dir, $nmon_files[0]);
    open(my $fh_first, '<:encoding(utf8)', $first_file_path) or die "Error opening $first_file_path: $!";
    while (my $line = <$fh_first>)
    {
        if ($line =~ /^BBBL,06,smt threads,(\d+)/)
        {
            $smt_value_from_file = $1;
            last;
        }
    }
    close $fh_first;

    if (defined $smt_value_from_file)
    {
        $smt_value = $smt_value_from_file;
        print STDERR "  Using SMT value of $smt_value from the first NMON file.\n";
    }
    else
    {
        print STDERR "Warning: Could not determine SMT from first file. Using default of $DEFAULT_SMT.\n";
    }

    # Second pass: Process all files
    foreach my $file (@nmon_files)
    {
        my $file_path = File::Spec->catfile($dir, $file);
        print STDERR "Processing file: $file\n" if $verbose;
        open(my $fh, '<:encoding(utf8)', $file_path) or die "Error opening $file_path: $!";

        my %timestamps;
        my $vm_name;

        while (my $line = <$fh>)
        {
            chomp $line;
            $line =~ s/\r$//;

            if ($line =~ /^AAA,host,(.+)$/)
            {
                $vm_name = $1;
                $vm_names{$vm_name} = 1;
            }
            elsif ($line =~ /^ZZZZ,T(\d+),(\d{2}:\d{2}:\d{2}),(.+)$/)
            {
                my ($t_num, $time, $date_str) = ($1, $2, $3);
                my $tp_date = Time::Piece->strptime($date_str, "%d-%b-%Y");
                $timestamps{$t_num} = $tp_date->ymd . " " . $time;
            }
            elsif ($line =~ /^LPAR,T(\d+),(.+)$/)
            {
                my ($t_num, $lpar_data) = ($1, $2);
                my @lpar_fields = split(/,/, $lpar_data);
                if (defined $timestamps{$t_num} && defined $vm_name)
                {
                    $data{$timestamps{$t_num}}{$vm_name}{physc} = $lpar_fields[1];
                }
            }
            elsif ($line =~ /^CPU_ALL,T(\d+),(.+)$/)
            {
                my ($t_num, $cpu_data) = ($1, $2);
                my @cpu_fields = split(/,/, $cpu_data);
                if (defined $timestamps{$t_num} && defined $vm_name)
                {
                    $data{$timestamps{$t_num}}{$vm_name}{runq} = $cpu_fields[5];
                }
            }
        }
        close $fh;
    }

    # Generate the temporary CSV files
    my @sorted_timestamps = sort keys %data;
    my @sorted_vm_names = sort keys %vm_names;

    # Write headers
    print $physc_out_fh "Time," . join(",", @sorted_vm_names) . "\n";
    print $runq_out_fh "Time," . join(",", @sorted_vm_names) . "\n";

    # Write data
    foreach my $ts (@sorted_timestamps)
    {
        my @physc_row = ($ts);
        my @runq_row = ($ts);
        foreach my $vm (@sorted_vm_names)
        {
            push @physc_row, $data{$ts}{$vm}{physc} // '';
            push @runq_row, $data{$ts}{$vm}{runq} // '';
        }
        print $physc_out_fh join(",", @physc_row) . "\n";
        print $runq_out_fh join(",", @runq_row) . "\n";
    }
}

# Calculate basic statistics (mean, stddev, CV) for a list of values
# Input: reference to an array of numeric values
# Output: hashref { mean, stddev, cv, count } or undef if insufficient data
sub calculate_statistics_for_trend
{
    my ($values_aref) = @_;
    my @defined_values = grep { defined $_ && $_ =~ /^-?[0-9.]+$/ } @{$values_aref};
    my $count = scalar @defined_values;

    return undef if $count == 0;

    my $sum = sum0(@defined_values);
    my $mean = $sum / $count;
    my $stddev = 0;
    my $cv = undef;

    if ($count > 1)
    {
        my $sum_sq_diff = 0;
        foreach my $val (@defined_values)
        {
            $sum_sq_diff += ($val - $mean)**2;
        }
        $stddev = sqrt($sum_sq_diff / ($count - 1));
    }

    if (abs($mean) > $FLOAT_EPSILON)
    {
        $cv = $stddev / $mean;
    }
    elsif ($stddev < $FLOAT_EPSILON && abs($mean) < $FLOAT_EPSILON)
    {
        $cv = 0;
    }

    return {
        mean   => $mean,
        stddev => $stddev,
        cv     => $cv,
        count  => $count,
    };
}

# Calculate linear regression (slope, intercept, R-squared) manually
# Input: reference to an array of [x, y] points, where x and y are numeric.
#        x is typically a time index (0, 1, 2,...), y is the metric value.
# Output: hashref { slope, intercept, r_squared, n_points } or undef if
#         insufficient data (n < 2) or if slope cannot be determined (e.g., all x values are identical).
sub calculate_manual_linear_regression
{
    my ($points_aref) = @_;
    my $n = scalar @{$points_aref};

    # Regression requires at least 2 distinct points to define a line.
    return undef if $n < 2;

    my $sum_x = 0;
    my $sum_y = 0;
    my $sum_xy = 0;
    my $sum_x_squared = 0;
    my $sum_y_squared = 0;

    foreach my $point (@{$points_aref})
    {
        my ($x_val, $y_val) = @{$point};

        # Assuming $x_val and $y_val are already numeric based on upstream processing.
        # If strict validation is needed here, it can be added, but the input
        # preparation logic should ensure numeric data.

        $sum_x += $x_val;
        $sum_y += $y_val;
        $sum_xy += $x_val * $y_val;
        $sum_x_squared += $x_val**2;
        $sum_y_squared += $y_val**2;
    }

    my $slope_calc     = undef;
    my $intercept_calc = undef;
    my $r_squared_calc = undef;

    # Denominator for slope calculation: N * sum(x^2) - (sum(x))^2
    # This is also N * SS_xx (where SS_xx is sum of squares for x)
    my $denominator_slope = ($n * $sum_x_squared) - ($sum_x**2);

    # Check if denominator is too close to zero (implies x values are not distinct enough
    # or only one unique x value if n > 1, which makes slope undefined or infinite).
    if (abs($denominator_slope) > $FLOAT_EPSILON)
    {
        $slope_calc = (($n * $sum_xy) - ($sum_x * $sum_y)) / $denominator_slope;
        $intercept_calc = ($sum_y - ($slope_calc * $sum_x)) / $n;

        # Calculate R-squared (Coefficient of Determination)
        # R^2 = (N * sum(xy) - sum(x) * sum(y))^2 / ((N * sum(x^2) - (sum(x))^2) * (N * sum(y^2) - (sum(y))^2))
        my $numerator_r_sq_squared = (($n * $sum_xy) - ($sum_x * $sum_y))**2;
        my $denominator_r_sq_part_yy = ($n * $sum_y_squared) - ($sum_y**2);

        if (abs($denominator_r_sq_part_yy) > $FLOAT_EPSILON) # Avoid division by zero if all y values are the same
        {
            $r_squared_calc = $numerator_r_sq_squared / ($denominator_slope * $denominator_r_sq_part_yy);
            # Clamp R-squared to [0, 1] due to potential floating point inaccuracies
            $r_squared_calc = 0.0 if defined $r_squared_calc && $r_squared_calc < 0;
            $r_squared_calc = 1.0 if defined $r_squared_calc && $r_squared_calc > 1.0;
        }
        elsif (abs($numerator_r_sq_squared) < $FLOAT_EPSILON**2) # All y are same, and slope is ~0
        {
            # If all y values are identical, the line should perfectly predict them if slope is also ~0.
            $r_squared_calc = 1.0;
        }
        else
        {
            # This case implies an issue or perfect vertical correlation if all x were same (but ss_xx_calc > 0 here)
            # If y is constant, variance of y is 0. If model doesn't perfectly predict this constant, R^2 can be odd.
            # Given y is constant, and slope is non-zero, it means the line isn't horizontal.
            # SS_tot would be 0. SS_res would be >0. R^2 = 1 - SS_res/SS_tot is undefined.
            # However, if $denominator_r_sq_part_yy is near zero, it implies SS_tot is near zero.
            # If the numerator $numerator_r_sq_squared is also near zero, it suggests the model fits perfectly (R^2 = 1).
            # If numerator is not zero but denominator_yy is, it's effectively a poor fit for variation that doesn't exist.
            $r_squared_calc = 0.0; # Default to 0 for poor/undefined fit in this edge scenario
        }
    }
    else
    {
        # Denominator for slope is zero or too small.
        # This happens if all x values are (nearly) identical.
        # Cannot reliably determine a linear trend.
        return undef;
    }

    return {
        slope     => $slope_calc,
        intercept => $intercept_calc,
        r_squared => $r_squared_calc,
        n_points  => $n,
    };
}

sub process_and_store_window_results
{
    my ($window_def_ref, $current_vm_win_buf_href, $vm_overall_win_data_href,
        $all_vm_names_aref, $target_vm_idx_nullable, $target_vm_name_nullable,
        $main_physc_percentile_arg, $calc_peak_arg, $has_runq_data_arg,
        $runq_norm_p_aref_arg, $runq_abs_p_aref_arg,
        $current_runq_avg_method_arg, $current_win_minutes_arg, $current_alpha_for_ema_arg_unused
    ) = @_;

    my ($win_start, $win_end, $win_rep_date) = @{$window_def_ref};
    my $win_idx = -1;
    for (my $i=0; $i < @processing_windows; $i++)
    {
        if ($processing_windows[$i][2]->epoch == $win_rep_date->epoch)
        {
            $win_idx = $i;
            last;
        }
    }
    return unless $win_idx != -1;
    my $window_key = $win_rep_date->ymd('') . "_" . $win_idx;

    my @vms_to_process_this_window_list;
    if (defined $target_vm_idx_nullable)
    {
        push @vms_to_process_this_window_list, $target_vm_name_nullable;
    }
    else
    {
        @vms_to_process_this_window_list = @{$all_vm_names_aref};
    }

    foreach my $vm_name_local (@vms_to_process_this_window_list) # Use local var
    {
        next unless (exists $current_vm_win_buf_href->{$vm_name_local} && exists $current_vm_win_buf_href->{$vm_name_local}{$window_key});
        my $vm_win_data = $current_vm_win_buf_href->{$vm_name_local}{$window_key};

        my $p_label_main = sprintf("P%.2f", $main_physc_percentile_arg);
        $p_label_main =~ s/\.?0+$//;
        $p_label_main = "0" if $p_label_main eq "" && abs($main_physc_percentile_arg-0)<0.001;

        if (exists $vm_win_data->{rolling_physc_avgs} && @{$vm_win_data->{rolling_physc_avgs}})
        {
            my @sorted_physc_avgs = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{rolling_physc_avgs}};
            if (@sorted_physc_avgs)
            {
                my $physc_perc_val = calculate_percentile(\@sorted_physc_avgs, $main_physc_percentile_arg);
                $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$p_label_main} = defined($physc_perc_val) ? $physc_perc_val : "N/A";
            }
            else
            {
                $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$p_label_main} = "N/A";
            }
        }
        else
        {
            $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$p_label_main} = "N/A";
        }

        if ($calc_peak_arg)
        {
            if (exists $vm_win_data->{raw_physc_for_peak} && @{$vm_win_data->{raw_physc_for_peak}})
            {
                my @defined_peaks = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{raw_physc_for_peak}};
                $vm_overall_win_data_href->{$vm_name_local}{$window_key}{'Peak'} = @defined_peaks ? max(@defined_peaks) : "N/A";
            }
            else
            {
                $vm_overall_win_data_href->{$vm_name_local}{$window_key}{'Peak'} = "N/A";
            }
        }
        if ($has_runq_data_arg)
        {
            my @abs_rq_for_perc_cleaned = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{abs_rq_values_for_perc}};
            foreach my $p_val (@{$runq_abs_p_aref_arg})
            {
                my $p_num_label = sprintf("%.2f", $p_val);
                $p_num_label =~ s/\.?0+$//;
                $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
                my $metric_key = "AbsRunQ_P$p_num_label";
                if (@abs_rq_for_perc_cleaned)
                {
                    my @sorted_vals = sort {$a <=> $b} @abs_rq_for_perc_cleaned;
                    my $val = calculate_percentile(\@sorted_vals, $p_val);
                    $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A";
                }
                else
                {
                    $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$metric_key} = "N/A";
                }
            }
            my @norm_rq_for_perc_cleaned = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{norm_rq_values_for_perc}};
            foreach my $p_val (@{$runq_norm_p_aref_arg})
            {
                my $p_num_label = sprintf("%.2f", $p_val);
                $p_num_label =~ s/\.?0+$//;
                $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
                my $metric_key = "NormRunQ_P$p_num_label";
                if (@norm_rq_for_perc_cleaned)
                {
                    my @sorted_vals = sort {$a <=> $b} @norm_rq_for_perc_cleaned;
                    my $val = calculate_percentile(\@sorted_vals, $p_val);
                    $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A";
                }
                else
                {
                    $vm_overall_win_data_href->{$vm_name_local}{$window_key}{$metric_key} = "N/A";
                }
            }
        }
    }
}


# --- Existing Subroutines from Original Script ---
sub parse_percentile_list
{
    my ($perc_str, $arg_name) = @_;
    my @percentiles;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p !~ /^[0-9]+(?:\.[0-9]+)?$/ || $p < 0 || $p > 100)
            {
                die "Error: Invalid percentile value '$p' in --$arg_name list. Must be numeric between 0 and 100.\n";
            }
            push @percentiles, $p + 0;
        }
    }
    return @percentiles;
}

sub get_nmon_overall_date_range
{
    my ($nmon_file, $global_start_filter_str, $global_end_filter_str) = @_;
    print STDERR "Scanning NMON file '$nmon_file' for overall effective date range...\n" if ($verbose);
    open my $fh, '<:encoding(utf8)', $nmon_file or die "Error: Cannot open NMON file '$nmon_file': $!\n";
    my $min_date_obj;
    my $max_date_obj;
    my $header_skipped = 0;
    my $first_data_line_checked = 0;
    my $start_filter_obj;
    my $end_filter_obj;
    if (defined $global_start_filter_str)
    {
        eval { $start_filter_obj = Time::Piece->strptime($global_start_filter_str, "%Y-%m-%d"); };
        if ($@ || (defined $global_start_filter_str && ! (defined $start_filter_obj && $start_filter_obj->isa('Time::Piece') ) ) )
        {
            die "Error parsing global start date filter '$global_start_filter_str': $@\n";
        }
    }
    if (defined $global_end_filter_str)
    {
        eval { $end_filter_obj = Time::Piece->strptime($global_end_filter_str, "%Y-%m-%d"); };
        if ($@ || (defined $global_end_filter_str && ! (defined $end_filter_obj && $end_filter_obj->isa('Time::Piece') ) ) )
        {
            die "Error parsing global end date filter '$global_end_filter_str': $@\n";
        }
    }
    while (my $line = <$fh>)
    {
        chomp $line;
        $line =~ s/\r$//;
        next if $line =~ /^\s*$/;
        if (!$header_skipped && !$first_data_line_checked)
        {
            if ($line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i)
            {
                $header_skipped = 1;
                next;
            }
            $first_data_line_checked = 1;
        }
        elsif ($header_skipped && $line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i)
        {
            next;
        }
        if ($line =~ /^(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/)
        {
            my $timestamp_str_local = $1;
            $timestamp_str_local =~ s/T/ /;
            my $current_tp;
            eval { $current_tp = Time::Piece->strptime($timestamp_str_local, "%Y-%m-%d %H:%M:%S"); };
            if ($@ || !$current_tp || !$current_tp->isa('Time::Piece'))
            {
                next;
            }
            my $current_date_day_obj = $current_tp->truncate(to => 'day');
            if (defined $start_filter_obj && $current_date_day_obj < $start_filter_obj) { next; }
            if (defined $end_filter_obj   && $current_date_day_obj > $end_filter_obj)   { next; }
            if (!defined $min_date_obj || !$min_date_obj->isa('Time::Piece') || $current_tp < $min_date_obj)
            {
                $min_date_obj = $current_tp;
            }
            if (!defined $max_date_obj || !$max_date_obj->isa('Time::Piece') || $current_tp > $max_date_obj)
            {
                $max_date_obj = $current_tp;
            }
        }
    }
    close $fh;
    if (defined $min_date_obj && $min_date_obj->isa('Time::Piece') && defined $max_date_obj && $max_date_obj->isa('Time::Piece'))
    {
        print STDERR "Effective NMON data range for windowing: " . $min_date_obj->datetime . " to " . $max_date_obj->datetime . "\n";
        my $ret_start = $min_date_obj->truncate(to => 'day');
        my $ret_end   = $max_date_obj->truncate(to => 'day');
        unless (defined $ret_start && $ret_start->isa('Time::Piece') && defined $ret_end && $ret_end->isa('Time::Piece'))
        {
            print STDERR "Error: Truncated date objects became invalid in get_nmon_overall_date_range.\n";
            return (undef, undef);
        }
        return ($ret_start, $ret_end);
    }
    else
    {
        print STDERR "Warning: Could not determine valid min/max dates from NMON file '$nmon_file' after global filters.\n";
        return (undef, undef);
    }
}

sub generate_processing_time_windows
{
    my ($period_start_obj, $period_end_obj, $unit_str, $size_val) = @_;
    my @windows;
    return () unless (defined $period_start_obj && defined $period_end_obj && $period_start_obj->isa('Time::Piece') && $period_end_obj->isa('Time::Piece') && $period_start_obj <= $period_end_obj);
    my $current_window_start = Time::Piece->new($period_start_obj->epoch);
    while ($current_window_start <= $period_end_obj)
    {
        my $current_window_end;
        if ($unit_str eq "days")
        {
            $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_DAY() * ($size_val - 1));
        }
        elsif ($unit_str eq "weeks")
        {
            $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_WEEK() * $size_val) - ONE_DAY();
        }
        else
        {
            die "Unsupported window unit: $unit_str\n";
        }
        if ($current_window_end > $period_end_obj)
        {
            $current_window_end = Time::Piece->new($period_end_obj->epoch);
        }
        my $representative_date = Time::Piece->new($current_window_end->epoch);
        push @windows, [Time::Piece->new($current_window_start->epoch), Time::Piece->new($current_window_end->epoch), $representative_date];
        my $next_window_start_candidate = $current_window_end + ONE_DAY();
        last if ($next_window_start_candidate > $period_end_obj && $current_window_end >= $period_end_obj);
        $current_window_start = $next_window_start_candidate;
    }
    return @windows;
}

sub get_window_key_for_timestamp
{
    my ($timestamp_obj, $windows_aref, $hint_idx) = @_;
    my $timestamp_day_obj = $timestamp_obj->truncate(to => 'day');
    if (defined $hint_idx && $hint_idx >=0 && $hint_idx < @{$windows_aref})
    {
        my ($win_start, $win_end) = @{$windows_aref->[$hint_idx]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end)
        {
            return $windows_aref->[$hint_idx][2]->ymd('') . "_" . $hint_idx;
        }
    }
    for (my $i=0; $i < @{$windows_aref}; $i++)
    {
        my ($win_start, $win_end) = @{$windows_aref->[$i]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end)
        {
            return $windows_aref->[$i][2]->ymd('') . "_" . $i;
        }
    }
    return undef;
}

sub get_weighted_metric_for_vm
{
    my ($vm_data_by_window_href, $vm_name_local, $metric_key, # Use local var
        $processing_windows_aref, $analysis_ref_obj_arg, $decay_hl_days_arg, $sprintf_fmt_optional) = @_;

    my @metric_window_values;
    if (exists $vm_data_by_window_href->{$vm_name_local})
    {
        foreach my $win_key (sort {
                                my ($ad, $ai) = ($a =~ /^(\d{8})_(\d+)$/);
                                my ($bd, $bi) = ($b =~ /^(\d{8})_(\d+)$/);
                                return ($ad cmp $bd) || ($ai <=> $bi);
                             } keys %{$vm_data_by_window_href->{$vm_name_local}})
        {
            if (exists $vm_data_by_window_href->{$vm_name_local}{$win_key}{$metric_key} &&
                defined $vm_data_by_window_href->{$vm_name_local}{$win_key}{$metric_key} &&
                $vm_data_by_window_href->{$vm_name_local}{$win_key}{$metric_key} ne "N/A" )
            {
                my ($win_date_str_part, $win_idx_part) = ($win_key =~ /^(\d{8})_(\d+)$/);
                if (defined $win_idx_part && $win_idx_part < @{$processing_windows_aref})
                {
                    my $rep_date_obj = $processing_windows_aref->[$win_idx_part][2];
                    unless (defined $rep_date_obj && $rep_date_obj->isa('Time::Piece'))
                    {
                        print STDERR "Warning: Representative date for window key '$win_key' is invalid for VM '$vm_name_local', metric '$metric_key'. Skipping this window point.\n";
                        next;
                    }
                    push @metric_window_values, {
                        value => $vm_data_by_window_href->{$vm_name_local}{$win_key}{$metric_key},
                        date  => $rep_date_obj
                    };
                }
                else
                {
                    print STDERR "Warning: Could not accurately map window key '$win_key' to a processing window definition for VM '$vm_name_local', metric '$metric_key'. Skipping this window point.\n";
                }
            }
        }
    }

    if (@metric_window_values)
    {
        my $final_val_str;
        if ($metric_key eq 'Peak') {
            # For the Peak, we want the absolute maximum value found across all windows.
            my @values = map { $_->{value} } grep { defined $_->{value} && looks_like_number($_->{value}) } @metric_window_values;
            $final_val_str = @values ? max(@values) : "N/A";
        } else {
            # For all other metrics, perform the recency-weighted average.
            $final_val_str = calculate_recency_weighted_average(
                \@metric_window_values, $analysis_ref_obj_arg, $decay_hl_days_arg
            );
        }
        if (defined $sprintf_fmt_optional && defined $final_val_str && $final_val_str ne "N/A" && $final_val_str =~ /^-?[0-9.]+$/)
        {
            return sprintf($sprintf_fmt_optional, $final_val_str + 0);
        }
        return $final_val_str;
    }
    return "N/A";
}

sub calculate_recency_weighted_average
{
    my ($windowed_data_ref, $analysis_ref_obj_arg, $half_life_days_arg) = @_;
    my $sum_weighted_values = 0;
    my $sum_weights = 0;
    return "N/A" if (!defined $analysis_ref_obj_arg || !$analysis_ref_obj_arg->isa('Time::Piece'));
    return "N/A" if (!defined $half_life_days_arg || $half_life_days_arg <= 0);

    my $lambda = log(2) / $half_life_days_arg;

    foreach my $dp_ref (@{$windowed_data_ref})
    {
        my $value_str = $dp_ref->{value};
        next if (!defined $value_str || $value_str eq "N/A" || $value_str !~ /^-?[0-9.]+$/);
        my $value = $value_str + 0;
        my $date_obj = $dp_ref->{date};
        next if (!defined $date_obj || !$date_obj->isa('Time::Piece'));

        my $date_obj_day = $date_obj->truncate(to => 'day');
        my $analysis_ref_day = $analysis_ref_obj_arg->truncate(to => 'day');

        my $days_diff_seconds = $analysis_ref_day->epoch - $date_obj_day->epoch;
        my $days_diff = $days_diff_seconds / ONE_DAY(); # Use seconds from Time::Seconds object
        $days_diff = 0 if $days_diff < 0;

        my $weight = exp(-$lambda * $days_diff);
        $sum_weighted_values += $value * $weight;
        $sum_weights += $weight;
    }

    if ($sum_weights > $FLOAT_EPSILON)
    {
        return sprintf("%.4f", $sum_weighted_values / $sum_weights);
    }
    else
    {
        return "N/A";
    }
}

sub get_vm_index_by_name
{
    my ($vm_name_to_find, $vm_names_list_ref) = @_;
    for (my $i=0; $i < @{$vm_names_list_ref}; $i++)
    {
        if ($vm_names_list_ref->[$i] eq $vm_name_to_find)
        {
            return $i;
        }
    }
    return undef;
}

sub calculate_average
{
    my (@data) = @_;
    my @numbers = grep { defined $_ && looks_like_number($_) } @data;
    return 0 if !@numbers;
    return sum0(@numbers) / scalar(@numbers);
}

sub calculate_percentile
{
    my ($data_ref, $p) = @_;
    my @data_input = @{$data_ref};
    my @data = grep { defined($_) && $_ =~ /^-?[0-9]+(?:\.[0-9]+)?$/ } @data_input;
    my $n = scalar @data;
    return undef if $n == 0;
    @data = sort { $a <=> $b } @data;
    return $data[0] if $n == 1;

    my $rank_fractional = ($p / 100) * ($n - 1);
    my $k = int($rank_fractional);
    my $d = $rank_fractional - $k;

    if ($p == 0) { return $data[0]; }
    if ($p == 100) { return $data[$n-1]; }

    if ($k >= $n - 1)
    {
        return $data[$n - 1];
    }
    elsif ($k < 0)
    {
        return $data[0];
    }
    else
    {
        my $val_k = $data[$k];
        my $val_k_plus_1 = ($k + 1 < $n) ? $data[$k + 1] : $data[$k];
        return $val_k + $d * ($val_k_plus_1 - $val_k);
    }
}

sub calculate_rolling_average_series
{
    my ($data_series_ref, $method, $window_size, $alpha_val) = @_;
    my @output_series;
    my @current_window_sma;
    my $current_ema;

    if ($method eq 'none')
    {
        return $data_series_ref;
    }

    foreach my $value (@{$data_series_ref})
    {
        my $avg_val_to_add = undef;
        if ($method eq 'sma')
        {
            if (defined $value && $value =~ /^-?[0-9.]+$/)
            {
                push @current_window_sma, ($value + 0);
            }
            else
            {
                push @current_window_sma, undef;
            }
            shift @current_window_sma while scalar @current_window_sma > $window_size;
            if (scalar @current_window_sma == $window_size)
            {
                $avg_val_to_add = calculate_average(@current_window_sma);
            }
        }
        elsif ($method eq 'ema')
        {
            if (defined $value && $value =~ /^-?[0-9.]+$/)
            {
                my $numeric_value = $value + 0;
                if (!defined $current_ema)
                {
                    $current_ema = $numeric_value;
                }
                else
                {
                    $current_ema = ($numeric_value * $alpha_val) + ($current_ema * (1 - $alpha_val));
                }
            }
             push @current_window_sma, $value;
             shift @current_window_sma while scalar @current_window_sma > $window_size;
             if (scalar @current_window_sma == $window_size)
             {
                 $avg_val_to_add = $current_ema;
             }
        }
        push @output_series, $avg_val_to_add if defined $avg_val_to_add;
    }
    return \@output_series;
}

sub apply_rounding
{
    my ($value, $increment, $method) = @_;
    return $value unless (defined $value && $value =~ /^-?[0-9]+(?:\.[0-9]+)?$/);
    return $value if $method eq 'none' || !defined $increment || $increment <= $FLOAT_EPSILON;

    my $rounded_value;
    if ($method eq 'standard')
    {
        $rounded_value = int( ($value / $increment) + ( ($value >= 0) ? 0.5 : -0.5) ) * $increment;
    }
    elsif ($method eq 'up')
    {
        $rounded_value = ceil( $value / $increment ) * $increment;
    }
    else
    {
        $rounded_value = $value;
    }
    return $rounded_value;
}

sub get_decimal_places
{
    my ($number_str) = @_;
    $number_str = sprintf("%.15f", $number_str) if ($number_str =~ /e/i);
    if ($number_str =~ /\.(\d+)$/)
    {
        return length($1);
    }
    else
    {
        return 0;
    }
}

# --- define_time_windows_for_state ---
# Subdivides a configuration state window into smaller, regular time-based
# windows for decay and growth analysis.
#
sub define_time_windows_for_state {
    my ($state_obj, $ref_date_str, $unit, $size) = @_;
    my @windows;
    my $start = $state_obj->{start_time};
    my $end   = $state_obj->{end_time};

    my $current_win_start = $start->truncate(to => 'day');

    while ($current_win_start < $end) {
        my $current_win_end;
        if ($unit eq 'days') {
            $current_win_end = $current_win_start + ($size * ONE_DAY()) - 1;
        } else { # weeks
            $current_win_end = $current_win_start + ($size * ONE_WEEK()) - 1;
        }

        $current_win_end = $end if $current_win_end > $end;

        push @windows, {
            start => $current_win_start,
            end   => $current_win_end,
            rep_date => $current_win_end, # Representative date for weighting is the end of the window
        };

        $current_win_start = $current_win_end->truncate(to => 'day') + ONE_DAY();
    }
    return @windows;
}

# --- calculate_metrics_for_period ---
# A generic routine to calculate all relevant metrics (PhysC, RunQ, Peak)
# for a given set of data points and a specific configuration state.
#
sub calculate_metrics_for_period {
    my ($data_points_aref, $state_metadata_href) = @_;

    my %metrics;
    return \%metrics unless @$data_points_aref;

    my $smt_for_period = $state_metadata_href->{smt} // $DEFAULT_SMT;

    # Calculate rolling averages for PhysC
    my @physc_avgs;
    my $physc_sma_q = []; my $physc_ema_s = undef;
    foreach my $dp (@$data_points_aref) {
        my $avg = calculate_rolling_average($dp->{physc}, $avg_method, $physc_sma_q, \$physc_ema_s, $window_minutes, $alpha_for_physc_ema);
        push @physc_avgs, $avg if defined $avg;
    }

    # Filter and calculate PhysC percentile
    my @filtered_physc = @physc_avgs;
    if (defined $filter_above_perc_value && @physc_avgs) {
        my @sff = sort {$a <=> $b} @physc_avgs;
        my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
        if(defined $ft) { @filtered_physc = grep { $_ >= ($ft - $FLOAT_EPSILON) } @physc_avgs; }
    }
    my @sorted_final_physc = sort {$a <=> $b} @filtered_physc;
    my $p_val_physc = @sorted_final_physc ? calculate_percentile(\@sorted_final_physc, $percentile) : undef;
    $metrics{"P".clean_perc_label($percentile)} = $p_val_physc;

    # Calculate Peak PhysC
    if ($calculate_peak) {
        my $peak = 0;
        foreach my $dp (@$data_points_aref) {
            $peak = $dp->{physc} if (defined $dp->{physc} && $dp->{physc} > $peak);
        }
        $metrics{'Peak'} = $peak > 0 ? $peak : undef;
    }

    # Calculate RunQ metrics
    my @norm_runq_raw; my @abs_runq_raw;
    foreach my $dp (@$data_points_aref) {
        if (defined $dp->{runq} && defined $dp->{physc} && $dp->{physc} >= $ACTIVE_PHYSC_THRESHOLD) {
            push @abs_runq_raw, $dp->{runq};
            my $eff_lcpus = $dp->{physc} * $smt_for_period;
            if ($eff_lcpus > $FLOAT_EPSILON) {
                push @norm_runq_raw, ($dp->{runq} / $eff_lcpus);
            }
        }
    }

    my $norm_data_ref = \@norm_runq_raw;
    my $abs_data_ref = \@abs_runq_raw;
    if ($runq_avg_method_str ne 'none') {
        $norm_data_ref = calculate_rolling_average_series($norm_data_ref, $runq_avg_method_str, $window_minutes, $alpha_for_runq_ema);
        $abs_data_ref = calculate_rolling_average_series($abs_data_ref, $runq_avg_method_str, $window_minutes, $alpha_for_runq_ema);
    }
    my @sorted_norm = sort {$a <=> $b} @$norm_data_ref;
    my @sorted_abs = sort {$a <=> $b} @$abs_data_ref;
    foreach my $p (@runq_norm_percentiles_to_calc) { $metrics{"NormRunQ_P".clean_perc_label($p)} = @sorted_norm ? calculate_percentile(\@sorted_norm, $p) : undef; }
    foreach my $p (@runq_abs_percentiles_to_calc) { $metrics{"AbsRunQ_P".clean_perc_label($p)} = @sorted_abs ? calculate_percentile(\@sorted_abs, $p) : undef; }

    return \%metrics;
}

# --- stream_data_for_state_from_temp ---
#   - This function implements the efficient streaming part of the design.
#   - It reads from the consolidated temporary files ONCE per state, instead
#     of re-scanning all original NMON files. It handles "long" CSV format from temp files.
sub stream_data_for_state_from_temp
{
    my ($state_obj, $physc_temp_file, $runq_temp_file, $filters_ref) = @_;

    my @data_points;
    my $vm_to_find = $state_obj->{vm_name};

    # Pre-load all relevant RunQ data for the target VM into a hash for quick lookup.
    # This is efficient as it avoids re-scanning the RunQ file for every PhysC point.
    my %runq_data_for_vm;
    if (defined $runq_temp_file && -s $runq_temp_file) {
        open my $rq_fh, '<:encoding(utf8)', $runq_temp_file or die "Could not open temp RunQ file $runq_temp_file: $!";
        my $ln = 0;
        while(my $line = <$rq_fh>) {
            chomp $line; $ln++;
            next if $ln == 1; # Skip header line

            my ($ts_str, $vm_name, $runq_val) = split ',', $line, 3;
            next unless (defined $vm_name && $vm_name eq $vm_to_find);

            $runq_data_for_vm{$ts_str} = (defined $runq_val && looks_like_number($runq_val)) ? $runq_val+0 : undef;
        }
        close $rq_fh;
    }

    # Stream the PhysC file and build the final data points array for the state.
    open my $pc_fh, '<:encoding(utf8)', $physc_temp_file or die "Could not open temp PhysC file $physc_temp_file: $!";
    my $ln = 0;
    while(my $line = <$pc_fh>) {
        chomp $line; $ln++;
        next if $ln == 1; # Skip header line

        my ($ts_str, $vm_name, $physc_val) = split ',', $line, 3;

        # We only care about lines for the VM of the current state object.
        next unless (defined $vm_name && $vm_name eq $vm_to_find);

        my $tp;
        eval { $tp = Time::Piece->strptime($ts_str, "%Y-%m-%d %H:%M:%S"); };
        next if ($@ || !$tp);

        # --- Filtering Logic ---
        # 1. State Window Filter (the primary filter)
        next unless ($tp >= $state_obj->{start_time} && $tp <= $state_obj->{end_time});

        # 2. Global Date Filters (--startdate, --enddate)
        if (defined $filters_ref->{start_date_str} && $tp->ymd('-') lt $filters_ref->{start_date_str}) { next; }
        if (defined $filters_ref->{end_date_str}   && $tp->ymd('-') gt $filters_ref->{end_date_str})   { next; }

        # 3. Weekend Filter (--no-weekends)
        if ($filters_ref->{no_weekends}) {
            my $day_of_week = $tp->day_of_week;
            next if ($day_of_week == 1 || $day_of_week == 7); # Skip Sunday (1) and Saturday (7)
        }

        # 4. Time-of-Day Filter (--online, --batch, --startt/--endt)
        if ($filters_ref->{time_filter_active}) {
            my $line_time = substr($tp->hms(':'), 0, 5);
            my $include_line = 0;
            if ($filters_ref->{time_filter_overnight}) {
                $include_line = 1 if ($line_time ge $filters_ref->{time_filter_start} || $line_time lt $filters_ref->{time_filter_end});
            } else {
                $include_line = 1 if ($line_time ge $filters_ref->{time_filter_start} && $line_time lt $filters_ref->{time_filter_end});
            }
            next unless ($include_line);
        }

        # If the data point passed all filters, add it to the list for this state.
        my $p_val = (defined $physc_val && looks_like_number($physc_val)) ? $physc_val+0 : undef;
        my $r_val = $runq_data_for_vm{$ts_str} // undef; # Look up corresponding RunQ value

        push @data_points, { ts => $ts_str, physc => $p_val, runq => $r_val, tp => $tp };
    }
    close $pc_fh;

    return @data_points;
}

sub process_nmon_directory_to_tempfiles
{
    my ($dir, $physc_out_fh, $runq_out_fh) = @_;

    my @nmon_files;
    find(sub { push @nmon_files, $File::Find::name if -f && /\.nmon$/i; }, $dir);
    die "Error: No .nmon files found in directory '$dir'.\n" unless @nmon_files;

    # Write headers for the new "long" CSV format
    print $physc_out_fh "Timestamp,VMName,PhysC\n";
    print $runq_out_fh "Timestamp,VMName,RunQ\n";

    foreach my $file_path (sort @nmon_files)
    {
        # Handle both compressed or uncompressed files.
		  my $fh;
		  if ($file_path =~ /\.nmon\.gz$/i) {
				open $fh, "-|", "zcat", "--", $file_path or do {
					 warn "Warning: Could not zcat '$file_path': $!. Skipping.";
					 next;
				};
		  }
		  elsif ($file_path =~ /\.nmon\.(bz2|bzip2)$/i) {
				open $fh, "-|", "bzcat", "--", $file_path or do {
					 warn "Warning: Could not bzcat '$file_path': $!. Skipping.";
					 next;
				};
		  }
		  elsif ($file_path =~ /\.nmon$/i) {
				open $fh, '<:encoding(utf8)', $file_path or do {
					 warn "Warning: Could not open '$file_path': $!. Skipping.";
					 next;
				};
		  }
		  else {
				warn "Warning: Unsupported file type '$file_path'. Skipping.";
				next;
		  }

        my $vm_name;
        my %zzzz_map;

        while (my $line = <$fh>)
        {
            chomp $line; $line =~ s/\r$//;
            my @fields = split ',', $line;
            my $key = $fields[0];

            if ($key eq 'AAA' && $fields[1] eq 'host') {
                $vm_name = $fields[2];
            }
            elsif ($key eq 'ZZZZ') {
                my ($t_num, $time, $date_str) = @fields[1..3];
                my $tp_date;
                eval { $tp_date = Time::Piece->strptime($date_str, "%d-%b-%Y"); };
                if ($@ || !$tp_date) { eval { $tp_date = Time::Piece->strptime($date_str, "%d-%B-%Y"); }; }
                next if ($@ || !$tp_date);
                # Use the snapshot ID with the "T" prefix as the key
                $zzzz_map{$t_num} = $tp_date->ymd . " " . $time;
            }
            elsif ($key eq 'LPAR') {
                my $t_num = $fields[1]; # Do NOT strip the "T"
                if (defined $zzzz_map{$t_num} && defined $vm_name) {
                    my $physc_val = $fields[2];
                    # Add your check here to ensure only numeric data is written
                    if (defined $physc_val && looks_like_number($physc_val)) {
                        print $physc_out_fh join(",", $zzzz_map{$t_num}, $vm_name, $physc_val) . "\n";
                    }
                }
            }
            elsif ($key eq 'CPU_ALL') {
                my $t_num = $fields[1]; # Do NOT strip the "T"
                if (defined $zzzz_map{$t_num} && defined $vm_name) {
                    my $runq_val = $fields[6];
                    # Add your check here to ensure only numeric data is written
                    if (defined $runq_val && looks_like_number($runq_val)) {
                        print $runq_out_fh join(",", $zzzz_map{$t_num}, $vm_name, $runq_val) . "\n";
                    }
                }
            }
        }
        close $fh;
    }
}

sub generate_run_summary_string {
    my @summary_lines;
    my $label_width = 25;

    push @summary_lines, "\n------------------------------------------------------------------";
    push @summary_lines, "Run Summary";
    push @summary_lines, "------------------------------------------------------------------";

    # Input Method
    my $input_method = defined($nmon_dir) ? "--nmondir ($nmon_dir)" : "--physc-data ($physc_csv_file)";
    push @summary_lines, sprintf("%-".$label_width."s: %s", "Input Method", $input_method);

    # Primary Metric
    my $p_label = sprintf("P%.2f", $percentile);
    $p_label =~ s/\.?0+$//;
    my $primary_metric = sprintf("%s (Percentile: %.2f)", $p_label, $percentile);
    push @summary_lines, sprintf("%-".$label_width."s: %s", "Primary Metric", $primary_metric);

    # Averaging
    my $avg_details = uc($avg_method);
    $avg_details .= sprintf(" (Window: %d min, PhysC Decay: %s)", $window_minutes, $decay_level) if $avg_method eq 'ema';
    $avg_details .= sprintf(" (Window: %d min)", $window_minutes) if $avg_method eq 'sma';
    push @summary_lines, sprintf("%-".$label_width."s: %s", "Averaging Method", $avg_details);

    # RunQ
    if (defined($runq_csv_file) || defined($nmon_dir)) {
        my $runq_decay_str = ($runq_avg_method_str eq 'ema') ? ", Decay: $runq_decay_level_to_use" : "";
        my $runq_details = sprintf("Enabled (SMT: %d, Avg Method: %s%s)", $smt_value, $runq_avg_method_str, $runq_decay_str);
        push @summary_lines, sprintf("%-".$label_width."s: %s", "RunQ Analysis", $runq_details);

        my $norm_perc_str = $runq_norm_perc_str eq '' ? 'none' : $runq_norm_perc_str;
        my $abs_perc_str = $runq_abs_perc_str eq '' ? 'none' : $runq_abs_perc_str;
        push @summary_lines, sprintf("%-".$label_width."s: Norm(%s), Abs(%s)", "RunQ Percentiles", $norm_perc_str, $abs_perc_str);
    }

    # Filters
    my @filters;
    push @filters, "Time ($time_filter_desc)" if $time_filter_active;
    push @filters, "Weekends Excluded" if $no_weekends;
    if (defined $filter_above_perc_value) {
        my $perc_filter_label = sprintf("P%.2f", $filter_above_perc_value);
        $perc_filter_label =~ s/\.?0+$//;
        push @filters, "PhysC Perc (>= $perc_filter_label)";
    }
    push @summary_lines, sprintf("%-".$label_width."s: %s", "Filters Applied", join(', ', @filters)) if @filters;

    # Decay / Growth
    my $decay_status = $enable_windowed_decay_internal ? "Windowed Decay ON" : "Windowed Decay OFF";
    my $growth_status = $enable_growth_prediction ? "Growth Prediction ON" : "Growth Prediction OFF";
    push @summary_lines, sprintf("%-".$label_width."s: %s, %s", "Decay / Growth", $decay_status, $growth_status);

#    push @summary_lines, "------------------------------------------------------------------";

    return join("\n", @summary_lines) . "\n";
}

sub usage
{
    my $script_name = $0;
    $script_name =~ s{.*/}{};
    my $valid_decays_usage = join("|", sort keys %EMA_ALPHAS);
    return <<END_USAGE;
Usage: $script_name --physc-data <file> [options]
   or: $script_name --nmondir <directory> [options]

Analyses NMON PhysC and optionally RunQ data.
If --enable-windowed-decay is used, applies recency weighting to windowed results,
and can optionally enable growth prediction.

Input Method (mutually exclusive):
  --physc-data, -pc <file> : Path to input CSV file with PhysC data.
  --runq-data, -rq <file>  : Path to input CSV file with RunQ data.
  --nmondir <directory>    : Path to a directory of .nmon files to process.

NMON Directory State Management (NEW for v3, requires --nmondir):
  --show-states            : Scans NMON files, prints a report of all detected configuration
                             state windows for each VM, and exits.
  --include-states <sel>   : Specifies which state windows to analyze. <sel> is a comma-
                             separated list of state IDs or ranges (e.g., 'all', '1,3',
                             '2-4', '-1' for the most recent). (Default: all)
                             (--show-states and --include-states are mutually exclusive).

Averaging Method (used within each window if decay enabled):
  --avg-method <method>    : Averaging method for PhysC: 'sma' or 'ema'. (Default: $DEFAULT_AVG_METHOD)
  --decay <level>          : If 'ema' for PhysC, specifies decay level: $valid_decays_usage.
                           (Default: $DEFAULT_DECAY_LEVEL). This is also the default decay for RunQ EMA
                           if --runq-decay is not specified.
  --runq-decay <level>     : Optional. If 'ema' for RunQ, specifies its decay level, overriding --decay
                           for RunQ EMA. Accepts: $valid_decays_usage.
  -w, --window <minutes>     : Window for SMA (PhysC or RunQ); conceptual span/stabilisation trigger for EMA.
                           (Default: $DEFAULT_WINDOW_MINUTES min). Also used for RunQ if smoothing enabled.

RunQ Data Options (used with --physc-data or --nmondir):
  --smt <N>                : SMT level for RunQ normalisation (Default: $DEFAULT_SMT).
  --runq-norm-perc <list>  : Comma-separated percentiles for Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERC").
  --runq-abs-perc <list>   : Comma-separated percentiles for Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERC").
  --runq-avg-method <none|sma|ema> : Averaging method for RunQ data before percentile.
                               (Default: $DEFAULT_RUNQ_AVG_METHOD). Uses global -w and applicable decay settings.

Filtering Options (Applied BEFORE windowing if decay enabled):
  -s, --startdate <YYYY-MM-DD> : Ignore data before this date (overall filter).
  -ed, --enddate <YYYY-MM-DD>  : Ignore data after this date (overall filter).
  -startt <HH:MM> / -endt <HH:MM> : Daily time filter.
  -online / -batch           : Shortcut daily time filters.
  -no-weekends               : Exclude data from Saturdays and Sundays.
  -vm, --lpar <name>         : Analyse only the specified VM/LPAR name.

PhysC Calculation Options:
  -p, --percentile <value>   : Final percentile of PhysC (0-100) (Default: $DEFAULT_PERCENTILE).
                               If windowed decay, this is the percentile calculated per window and
                               forms the baseline for growth prediction.
  -k, --peak                 : Calculate peak PhysC value. (If windowed, weighted peak of window peaks).
  --filter-above-perc <N>    : Optional. Filter rolling PhysC values before PXX calc. (Applied per window if decay enabled).

Windowed Recency Decay (Prerequisite for Growth Prediction):
  --enable-windowed-decay     : Enable internal windowed processing with recency decay.
  --process-window-unit <days|weeks> : Unit for processing window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT).
  --process-window-size <N>   : Size of each window in specified units (Default: $DEFAULT_PROCESS_WINDOW_SIZE).
  --decay-half-life-days <N>  : Half-life in days for recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS).
  --analysis-reference-date <YYYY-MM-DD> : "Current" date for recency calculation
                                (Default: Date of last record in filtered NMON PhysC data).

Predicted Growth Feature (Requires --enable-windowed-decay):
  --enable-growth-prediction         : Enable growth prediction based on per-window primary percentile trend.
  --growth-projection-days <N>       : Project growth for N days into the future (e.g., 30 for 1 month, 90 for ~3 months). (Default: $DEFAULT_GROWTH_PROJECTION_DAYS)
  --max-growth-inflation-percent <X> : Maximum percentage to inflate the baseline by due to growth. (Default: $DEFAULT_MAX_GROWTH_INFLATION_PERCENT)

Rounding Options:
  -r[=increment] / -u[=increment] : Round results (Default increment: $DEFAULT_ROUND_INCREMENT).

Other:
  -h, --help                 : Display this help message.
  -v, --verbose              : Enable verbose output for debugging.
  --version                  : Display script version.
END_USAGE
}
