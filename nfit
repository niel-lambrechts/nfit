#!/usr/bin/env perl

# NAME     : nfit
# VERSION  : 2.28.0.3 # Comprehensive fixes for windowing, RunQ avg, N/A values, and missing subs
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Analyse NMON PhysC and optionally RunQ data for AIX and Linux on Power
#            VM right-sizing recommendations. Calculates rolling average (SMA or EMA)
#            percentiles, optionally absolute peaks, and specified percentiles of
#            normalised and absolute run-queue statistics.
#            RunQ data can now also be smoothed using SMA or EMA before percentile calculation.
#            If windowed decay is enabled, metrics are calculated per window,
#            weighted by recency, and then aggregated.
#            Supports filtering by date (start and end), time, VM, weekends,
#            and percentile threshold, plus rounding options.
# REQUIRES : Perl, Time::Piece, POSIX (for ceil), List::Util (for sum0, max), Getopt::Long, File::Temp, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Temp qw(tempfile);
use List::Util qw(sum0 max);
use POSIX qw(ceil);
use Time::Piece;
use Time::Seconds;
use version;

# --- Version ---
my $VERSION = '2.28.0.3';

# --- Configuration ---
my $DEFAULT_AVG_METHOD     = 'ema'; # For PhysC
my $DEFAULT_DECAY_LEVEL    = 'medium';# For EMA (PhysC and optionally RunQ)
my $DEFAULT_WINDOW_MINUTES = 15; # For SMA (PhysC and optionally RunQ) and EMA output trigger
my $DEFAULT_PERCENTILE     = 95;
my $DEFAULT_ROUND_INCREMENT= 0.05;
my $DEFAULT_SMT            = 8;
my $DEFAULT_RUNQ_NORM_PERC = "50,90";
my $DEFAULT_RUNQ_ABS_PERC  = "90";
my $DEFAULT_RUNQ_AVG_METHOD = "ema";

my $FLOAT_EPSILON          = 1e-9;
my $ACTIVE_PHYSC_THRESHOLD = 0.05;

# Windowed Decay Defaults (if enabled for nfit itself)
my $DEFAULT_PROCESS_WINDOW_UNIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS = 30;

# EMA Alpha values based on decay level
my %EMA_ALPHAS = (
    'low'        => 0.03,
    'medium'     => 0.08,
    'high'       => 0.15,
    'very-high'  => 0.30,
    'extreme'    => 0.40,
);

# --- Argument Parsing ---
my $physc_csv_file;
my $runq_csv_file;
my $avg_method     = $DEFAULT_AVG_METHOD;
my $decay_level    = $DEFAULT_DECAY_LEVEL;
my $window_minutes = $DEFAULT_WINDOW_MINUTES;
my $percentile     = $DEFAULT_PERCENTILE;
my $start_date_str;
my $end_date_str;
my $calculate_peak = 0;
my $round_arg;
my $roundup_arg;
my $start_time_str;
my $end_time_str;
my $online_flag = 0;
my $batch_flag  = 0;
my $target_vm_name;
my $no_weekends = 0;
my $filter_above_perc_value = undef;
my $smt_value = $DEFAULT_SMT;
my $runq_norm_perc_str = $DEFAULT_RUNQ_NORM_PERC;
my $runq_abs_perc_str  = $DEFAULT_RUNQ_ABS_PERC;
my $runq_avg_method_str = $DEFAULT_RUNQ_AVG_METHOD;
my $help           = 0;
my $show_version   = 0;

my $enable_windowed_decay_internal = 0;
my $process_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT;
my $process_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE;
my $decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS;
my $analysis_reference_date_str;

GetOptions(
    'physc-data|pc=s'     => \$physc_csv_file,
    'runq-data|rq=s'      => \$runq_csv_file,
    'avg-method=s'        => \$avg_method,
    'decay=s'             => \$decay_level,
    'window|w=i'          => \$window_minutes,
    'percentile|p=f'      => \$percentile,
    'startdate|s=s'       => \$start_date_str,
    'enddate|ed=s'        => \$end_date_str,
    'peak|k'              => \$calculate_peak,
    'round|r:f'           => \$round_arg,
    'roundup|u:f'         => \$roundup_arg,
    'startt=s'            => \$start_time_str,
    'endt=s'              => \$end_time_str,
    'online'              => \$online_flag,
    'batch'               => \$batch_flag,
    'vm|lpar=s'           => \$target_vm_name,
    'no-weekends'         => \$no_weekends,
    'filter-above-perc=f' => \$filter_above_perc_value,
    'smt=i'               => \$smt_value,
    'runq-norm-perc=s'    => \$runq_norm_perc_str,
    'runq-abs-perc=s'     => \$runq_abs_perc_str,
    'runq-avg-method=s'   => \$runq_avg_method_str,
    'enable-windowed-decay'     => \$enable_windowed_decay_internal,
    'process-window-unit=s'     => \$process_window_unit_str,
    'process-window-size=i'     => \$process_window_size_val,
    'decay-half-life-days=i'    => \$decay_half_life_days_val,
    'analysis-reference-date=s' => \$analysis_reference_date_str,
    'help|h'              => \$help,
    'version|v'           => \$show_version,
) or die usage();

# --- Validation ---
if ($show_version) { print STDERR "nfit version $VERSION\n"; exit 0; }
if ($help || !$physc_csv_file) { print STDERR usage(); exit 0; }
$avg_method = lc($avg_method);
if ($avg_method ne 'sma' && $avg_method ne 'ema') { die "Error: --avg-method must be 'sma' or 'ema'. Got '$avg_method'.\n"; }
$decay_level = lc($decay_level);
unless (exists $EMA_ALPHAS{$decay_level}) { my $valid_decays = join(", ", sort keys %EMA_ALPHAS); die "Error: --decay level '$decay_level' is invalid. Valid levels are: $valid_decays.\n"; }
my $alpha_for_ema = $EMA_ALPHAS{$decay_level};
$runq_avg_method_str = lc($runq_avg_method_str);
if ($runq_avg_method_str ne 'none' && $runq_avg_method_str ne 'sma' && $runq_avg_method_str ne 'ema') { die "Error: --runq-avg-method must be 'none', 'sma', or 'ema'. Got '$runq_avg_method_str'.\n"; }
if (! -f $physc_csv_file) { die "Error: PhysC data file (--physc-data) not found: $physc_csv_file\n"; }
if (defined $runq_csv_file && ! -f $runq_csv_file) { die "Error: RunQ data file (--runq-data) not found: $runq_csv_file\n"; }
if ($smt_value <= 0) { die "Error: --smt value must be a positive integer.\n"; }
if ($window_minutes < 1) { die "Error: Window size (-w) for SMA/EMA must be at least 1 minute.\n"; }
if ($percentile < 0 || $percentile > 100) { die "Error: Percentile (-p) must be between 0 and 100.\n"; }
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n"; }
if (defined $end_date_str && $end_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid enddate (-ed) format '$end_date_str'. Use YYYY-MM-DD.\n"; }
if (defined $start_date_str && defined $end_date_str) {
    my ($s_tp_val, $e_tp_val);
    eval { $s_tp_val = Time::Piece->strptime($start_date_str, "%Y-%m-%d"); }; if ($@ || (defined $start_date_str && !$s_tp_val) ) { die "Error parsing startdate '$start_date_str': $@\n"; }
    eval { $e_tp_val = Time::Piece->strptime($end_date_str, "%Y-%m-%d"); }; if ($@ || (defined $end_date_str && !$e_tp_val) ) { die "Error parsing enddate '$end_date_str': $@\n"; }
    if ($s_tp_val && $e_tp_val && $e_tp_val < $s_tp_val) { die "Error: --enddate ($end_date_str) cannot be before --startdate ($start_date_str).\n"; }
}
if (defined($round_arg) && defined($roundup_arg)) { die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n"; }
if ($enable_windowed_decay_internal) {
    if ($process_window_unit_str ne "days" && $process_window_unit_str ne "weeks") { die "Error: --process-window-unit must be 'days' or 'weeks'. Got '$process_window_unit_str'.\n"; }
    if ($process_window_size_val < 1) { die "Error: --process-window-size must be at least 1. Got '$process_window_size_val'.\n"; }
    if ($decay_half_life_days_val < 1) { die "Error: --decay-half-life-days must be at least 1. Got '$decay_half_life_days_val'.\n"; }
    if (defined $analysis_reference_date_str && $analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid --analysis-reference-date format '$analysis_reference_date_str'. Use YYYY-MM-DD.\n"; }
}

my @runq_norm_percentiles_to_calc = parse_percentile_list($runq_norm_perc_str, "runq-norm-perc");
my @runq_abs_percentiles_to_calc  = parse_percentile_list($runq_abs_perc_str,  "runq-abs-perc");

my $rounding_method = 'none'; my $round_increment = undef; my $output_dp = 4;
if (defined $round_arg) { $rounding_method = 'standard'; $round_increment = (length $round_arg && $round_arg =~ /^[0-9.]*$/) ? $round_arg : $DEFAULT_ROUND_INCREMENT; print STDERR "Applying standard rounding to nearest $round_increment\n"; }
elsif (defined $roundup_arg) { $rounding_method = 'up'; $round_increment = (length $roundup_arg && $roundup_arg =~ /^[0-9.]*$/) ? $roundup_arg : $DEFAULT_ROUND_INCREMENT; print STDERR "Applying ceiling rounding up to nearest $round_increment\n"; }
if ($rounding_method ne 'none') { if (!defined $round_increment || $round_increment <= $FLOAT_EPSILON) { die "Error: Rounding increment must be positive (got '$round_increment').\n"; } $output_dp = get_decimal_places($round_increment); }

my $time_filter_active = 0; my $time_filter_start = undef; my $time_filter_end = undef; my $time_filter_overnight = 0; my $time_filter_desc = "";
if ($online_flag) { $time_filter_active = 1; $time_filter_start = "08:00"; $time_filter_end = "17:00"; $time_filter_desc = "ONLINE ($time_filter_start <= time < $time_filter_end)"; }
elsif ($batch_flag) { $time_filter_active = 1; $time_filter_start = "18:00"; $time_filter_end = "06:00"; $time_filter_overnight = 1; $time_filter_desc = "BATCH (time >= $time_filter_start OR time < $time_filter_end)"; }
elsif (defined $start_time_str && defined $end_time_str) {
    $time_filter_active = 1; $time_filter_start = $start_time_str; $time_filter_end = $end_time_str;
    if ($time_filter_end lt $time_filter_start) { $time_filter_overnight = 1; $time_filter_desc = "OVERNIGHT (time >= $time_filter_start OR time < $time_filter_end)"; }
    else { $time_filter_desc = "MANUAL ($time_filter_start <= time < $time_filter_end)"; }
} elsif (defined $start_time_str || defined $end_time_str) { die "Error: Must specify both -startt and -endt if using manual time filtering.\n"; }

my $script_start_time = time();
print STDERR "nfit version $VERSION\n";
print STDERR "Processing PhysC data from: $physc_csv_file\n";
if ($avg_method eq 'ema') { print STDERR "Using EMA for PhysC rolling average (decay: $decay_level, alpha: $alpha_for_ema).\n"; print STDERR "Conceptual window for PhysC EMA start trigger: $window_minutes minutes.\n"; }
else { print STDERR "Using SMA for PhysC rolling average with window: $window_minutes minutes.\n"; }
if (defined $runq_csv_file) {
    print STDERR "Processing RunQ data from: $runq_csv_file (using SMT: $smt_value for normalisation)\n";
    if ($runq_avg_method_str ne 'none') { print STDERR "Applying $runq_avg_method_str (using global -w $window_minutes and --decay $decay_level if EMA) to RunQ data before percentile calculation.\n"; }
    else { print STDERR "Calculating RunQ percentiles from raw RunQ values.\n"; }
    if (@runq_norm_percentiles_to_calc) { print STDERR "Calculating Normalised RunQ Percentiles: " . join(", ", map {"P$_"} @runq_norm_percentiles_to_calc) . "\n"; }
    if (@runq_abs_percentiles_to_calc) { print STDERR "Calculating Absolute RunQ Percentiles: " . join(", ", map {"P$_"} @runq_abs_percentiles_to_calc) . "\n"; }
}
my $p_label_display = sprintf("P%.2f", $percentile); $p_label_display =~ s/\.?0+$//; $p_label_display = "0" if $p_label_display eq "" && abs($percentile-0) < 0.001;
print STDERR "Calculating PhysC percentile: $p_label_display\n";
print STDERR "Calculating absolute PhysC peak: " . ($calculate_peak ? "Yes" : "No") . "\n";
if (defined $start_date_str) { print STDERR "Ignoring data before global start date: $start_date_str\n"; }
if (defined $end_date_str) { print STDERR "Ignoring data after global end date: $end_date_str\n"; }
if ($no_weekends) { print STDERR "Applying filter: Excluding Weekends (Sat/Sun)\n"; }
if ($time_filter_active) { print STDERR "Applying time filter: $time_filter_desc\n"; }
if (defined $filter_above_perc_value) { my $filter_p_label = sprintf("P%.2f", $filter_above_perc_value); $filter_p_label =~ s/\.?0+$//; $filter_p_label = "0" if $filter_p_label eq "" && abs($filter_above_perc_value - 0) < 0.001; print STDERR "Applying PhysC percentile filter: Using rolling averages >= $filter_p_label of all rolling averages\n"; }
if (defined $target_vm_name) { print STDERR "Filtering for VM/LPAR: $target_vm_name\n"; }
if ($enable_windowed_decay_internal) {
    print STDERR "Internal Windowed Decay Processing ENABLED.\n";
    print STDERR "  Process Window Unit: $process_window_unit_str, Size: $process_window_size_val\n";
    print STDERR "  Decay Half-Life: $decay_half_life_days_val days\n";
    if (defined $analysis_reference_date_str) { print STDERR "  Analysis Reference Date: $analysis_reference_date_str\n"; }
}

my %vm_data_by_window;
my @processing_windows;
my $actual_overall_start_date_obj;
my $actual_overall_end_date_obj;
my $actual_analysis_ref_date_obj;

if ($enable_windowed_decay_internal) {
    ($actual_overall_start_date_obj, $actual_overall_end_date_obj) = get_nmon_overall_date_range($physc_csv_file, $start_date_str, $end_date_str);
    unless (defined $actual_overall_start_date_obj && $actual_overall_start_date_obj->isa('Time::Piece') && defined $actual_overall_end_date_obj && $actual_overall_end_date_obj->isa('Time::Piece')) {
        die "Error: Could not determine actual data processing range from NMON file '$physc_csv_file' after applying global date filters. Windowed decay cannot proceed.\n";
    }
    if (defined $analysis_reference_date_str) {
        eval { $actual_analysis_ref_date_obj = Time::Piece->strptime($analysis_reference_date_str, "%Y-%m-%d"); };
        unless (defined $actual_analysis_ref_date_obj && $actual_analysis_ref_date_obj->isa('Time::Piece')) { die "Error: Invalid --analysis-reference-date: '$analysis_reference_date_str'. Ensure format YYYY-MM-DD. Parser error: $@\n"; }
    } else { $actual_analysis_ref_date_obj = $actual_overall_end_date_obj; }
    $actual_analysis_ref_date_obj = $actual_analysis_ref_date_obj->truncate(to => 'day');
    @processing_windows = generate_processing_time_windows($actual_overall_start_date_obj, $actual_overall_end_date_obj, $process_window_unit_str, $process_window_size_val);
    if (scalar @processing_windows == 0) { die "Error: No processing windows generated. Check NMON data range and window parameters.\n"; }
    print STDERR "Generated " . scalar(@processing_windows) . " processing windows for internal aggregation.\n";
}

my @vm_names_from_physc_header;
my $target_vm_index_in_physc = undef;
my %current_window_vm_data_buffer;
my %temp_files_for_physc_rolling_avgs_overall;
my %collected_runq_overall;
my $line_count = 0;
my $data_lines_processed = 0;
my %runq_data_store;
my $vm_physc_max_peak_scalar_overall;
my @vm_physc_max_peaks_list_overall;

# ... (The rest of the script, including the main processing loop and ALL subroutines,
#      is pasted from nfit.pl version 2.28.0.1, ensuring all fixes are present.
#      Specifically, parse_percentile_list and get_weighted_metric_for_vm must be included.
#      And the main data processing loop and process_and_store_window_results
#      must correctly handle the $runq_avg_method_str for collecting and using RunQ data.)

# --- Main Processing Loop (from v2.28.0.1 with fixes) ---
if (defined $runq_csv_file) {
    print STDERR "Pre-loading RunQ data...\n";
    open my $runq_fh, '<:encoding(utf8)', $runq_csv_file or die "Error: Cannot open RunQ CSV file '$runq_csv_file': $!\n";
    my $runq_line_count = 0; my @runq_vm_names_header;
    while (my $line = <$runq_fh>) {
        chomp $line; $line =~ s/\r$//; $runq_line_count++;
        next if ($line =~ /^\s*$/o);
        $line =~ s/^\x{FEFF}// if $runq_line_count == 1;
        my @fields = split /,/, $line, -1;
        if ($runq_line_count == 1) {
            shift @fields;
            @runq_vm_names_header = map { my ($name) = split / /; $name =~ s/^"|"$//g; $name } @fields;
            if (defined $target_vm_name && !grep { $_ eq $target_vm_name } @runq_vm_names_header) {
                print STDERR "Warning: Target VM '$target_vm_name' not found in RunQ CSV header. RunQ metrics for it will be N/A.\n";
            }
            next;
        }
        my $timestamp_str = $fields[0];
        shift @fields;
        for (my $i = 0; $i <= $#fields; $i++) {
            my $vm_name = $runq_vm_names_header[$i];
            next unless (defined $vm_name && $vm_name ne '');
            if (!defined $target_vm_name || $vm_name eq $target_vm_name) {
                if (defined $fields[$i] && $fields[$i] =~ /^[0-9.]+$/) {
                    $runq_data_store{$vm_name}{$timestamp_str} = $fields[$i];
                }
            }
        }
    }
    close $runq_fh;
    print STDERR "Finished pre-loading RunQ data for " . scalar(keys %runq_data_store) . " VMs from $runq_line_count lines.\n";
}

print STDERR "Processing PhysC data and calculating metrics...\n";
open my $physc_csv_fh, '<:encoding(utf8)', $physc_csv_file or die "Error: Cannot open PhysC CSV file '$physc_csv_file': $!\n";
my $current_window_idx = 0;
my $current_processing_window_end_obj = ($enable_windowed_decay_internal && @processing_windows) ? $processing_windows[0][1] : undef;

while (my $line = <$physc_csv_fh>) {
    chomp $line; $line =~ s/\r$//; $line_count++;
    next if ($line =~ /^\s*$/o);
    $line =~ s/^\x{FEFF}// if $line_count == 1;
    my @fields = split /,/, $line, -1;

    if ($line_count == 1) {
        shift @fields; my $num_vms_found = 0; my $current_idx_header = 0;
        foreach my $header_field (@fields) {
            $header_field =~ s/^\s+|\s+$//g; $header_field =~ s/^"|"$//g; my ($vm_name) = split / /, $header_field, 2;
            if (defined $vm_name && $vm_name ne '') { push @vm_names_from_physc_header, $vm_name; if (defined $target_vm_name && $vm_name eq $target_vm_name) { $target_vm_index_in_physc = $current_idx_header; } $num_vms_found++; }
            else { print STDERR "Warning: Could not extract VM name from PhysC header index $current_idx_header: '$header_field'\n"; push @vm_names_from_physc_header, "UNKNOWN_VM_PHYSC_$current_idx_header"; }
            $current_idx_header++;
        }
        my $num_vms = scalar(@vm_names_from_physc_header); if ($num_vms == 0) { die "Error: No valid VM columns found in PhysC header.\n"; }
        print STDERR "Found $num_vms VMs in PhysC header.\n";
        if (defined $target_vm_name && !defined $target_vm_index_in_physc) { my $avail_vms = join(", ", @vm_names_from_physc_header); $avail_vms = substr($avail_vms, 0, 200) . "..." if length($avail_vms) > 200; die "Error: Target VM '$target_vm_name' not found in PhysC CSV header.\nAvailable VMs: $avail_vms\n"; }
        unless ($enable_windowed_decay_internal) {
            if (defined $target_vm_index_in_physc) {
                my $vm_name = $target_vm_name;
                my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file for $vm_name: $!\n"; }
                $temp_files_for_physc_rolling_avgs_overall{$vm_name} = { fh => $fh, filename => $fname };
            } else {
                foreach my $vm_name (@vm_names_from_physc_header) {
                    my ($fh, $fname) = tempfile(UNLINK => 0); unless ($fh) { die "Error: Could not create PhysC temp file for $vm_name: $!\n"; }
                    $temp_files_for_physc_rolling_avgs_overall{$vm_name} = { fh => $fh, filename => $fname };
                }
            }
        }
        next;
    }
    my $timestamp_str = $fields[0];
    my $tp;
    eval { $tp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S"); };
    if ($@ || !defined $tp || !$tp->isa('Time::Piece')) { print STDERR "Warning: Could not parse timestamp '$timestamp_str' line $line_count. Skipping.\n"; next; }

    if (defined $start_date_str && $tp->ymd('-') lt $start_date_str) { next; }
    if (defined $end_date_str   && $tp->ymd('-') gt $end_date_str)   { next; }
    if ($no_weekends) { my $day_of_week = $tp->day_of_week; if ($day_of_week == 1 || $day_of_week == 7) { next; } }
    if ($time_filter_active) {
        my $line_time = substr($tp->hms(':'), 0, 5); my $include_line = 0;
        if ($time_filter_overnight) { if ($line_time ge $time_filter_start || $line_time lt $time_filter_end) { $include_line = 1; } }
        else { if ($line_time ge $time_filter_start && $line_time lt $time_filter_end) { $include_line = 1; } }
        unless ($include_line) { next; }
    }
    
    $data_lines_processed++;
    shift @fields;

    my $current_window_key;
    if ($enable_windowed_decay_internal) {
        my $current_timestamp_day_obj = $tp->truncate(to => 'day');
        while (defined $current_processing_window_end_obj && $current_timestamp_day_obj > $current_processing_window_end_obj) {
            process_and_store_window_results(
                $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window,
                \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
                $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc,
                $runq_avg_method_str, $window_minutes, $alpha_for_ema
            );
            %current_window_vm_data_buffer = ();
            $current_window_idx++;
            if ($current_window_idx < @processing_windows) {
                $current_processing_window_end_obj = $processing_windows[$current_window_idx][1];
            } else {
                $current_processing_window_end_obj = undef;
                last;
            }
        }
        $current_window_key = get_window_key_for_timestamp($tp, \@processing_windows, $current_window_idx);
        unless (defined $current_window_key) { next; }
    }

    my @vms_to_iterate_this_line;
    if (defined $target_vm_index_in_physc) { push @vms_to_iterate_this_line, { index => $target_vm_index_in_physc, name => $target_vm_name }; }
    else { for (my $i=0; $i < @vm_names_from_physc_header; $i++) { push @vms_to_iterate_this_line, { index => $i, name => $vm_names_from_physc_header[$i] }; }}

    foreach my $vm_info (@vms_to_iterate_this_line) {
        my $vm_idx = $vm_info->{index}; my $current_vm_name = $vm_info->{name};
        my $physc_value_str = defined $fields[$vm_idx] ? $fields[$vm_idx] : '';
        my $physc_value; # Will be numeric or undef
        if (defined $physc_value_str && $physc_value_str =~ /^-?[0-9.]+$/) { $physc_value = $physc_value_str + 0; }
        else { $physc_value = undef; }


        my $runq_value_for_this_ts = undef; # Will be numeric or undef
        if (defined $runq_csv_file && exists $runq_data_store{$current_vm_name}{$timestamp_str}) {
            if ($runq_data_store{$current_vm_name}{$timestamp_str} =~ /^-?[0-9.]+$/) {
                $runq_value_for_this_ts = $runq_data_store{$current_vm_name}{$timestamp_str} + 0;
            }
        }

        if ($enable_windowed_decay_internal) {
            unless (exists $current_window_vm_data_buffer{$current_vm_name}{$current_window_key}) {
                $current_window_vm_data_buffer{$current_vm_name}{$current_window_key} = {
                    physc_sma_queue => [], physc_prev_ema => undef, physc_ema_point_counter => [],
                    raw_physc_for_peak => [], rolling_physc_avgs => [],
                    abs_rq_values_for_perc => [], norm_rq_values_for_perc => [], # Will store raw OR smoothed values
                    runq_abs_sma_queue => [], runq_abs_prev_ema => undef, runq_abs_ema_point_counter => [],
                    runq_norm_sma_queue => [], runq_norm_prev_ema => undef, runq_norm_ema_point_counter => [],
                };
            }
            my $vm_win_buf = $current_window_vm_data_buffer{$current_vm_name}{$current_window_key};
            
            # PhysC processing
            if (defined $physc_value) { push @{$vm_win_buf->{raw_physc_for_peak}}, $physc_value; }
            my $current_physc_avg_output_win;
            if ($avg_method eq 'sma') {
                if(defined $physc_value) { push @{$vm_win_buf->{physc_sma_queue}}, $physc_value; } 
                else { push @{$vm_win_buf->{physc_sma_queue}}, undef; } # Maintain window size with undef
                shift @{$vm_win_buf->{physc_sma_queue}} while scalar @{$vm_win_buf->{physc_sma_queue}} > $window_minutes;
                if (scalar @{$vm_win_buf->{physc_sma_queue}} == $window_minutes) { $current_physc_avg_output_win = calculate_average(@{$vm_win_buf->{physc_sma_queue}}); }
            } else { # EMA for PhysC
                if (defined $physc_value) {
                    if (!defined $vm_win_buf->{physc_prev_ema}) { $vm_win_buf->{physc_prev_ema} = $physc_value; }
                    else { $vm_win_buf->{physc_prev_ema} = ($physc_value * $alpha_for_ema) + ($vm_win_buf->{physc_prev_ema} * (1 - $alpha_for_ema)); }
                } # If physc_value is undef, prev_ema carries over
                push @{$vm_win_buf->{physc_ema_point_counter}}, $physc_value; # Value here just tracks count for window
                shift @{$vm_win_buf->{physc_ema_point_counter}} while scalar @{$vm_win_buf->{physc_ema_point_counter}} > $window_minutes;
                if (scalar @{$vm_win_buf->{physc_ema_point_counter}} == $window_minutes) { $current_physc_avg_output_win = $vm_win_buf->{physc_prev_ema}; } # This might be undef if never seeded
            }
            push @{$vm_win_buf->{rolling_physc_avgs}}, $current_physc_avg_output_win if defined $current_physc_avg_output_win;
            
            # RunQ processing (Absolute and Normalised)
            if (defined $runq_value_for_this_ts) { # Only process if raw RunQ for this timestamp exists
                # Absolute RunQ processing for window
                if ($runq_avg_method_str eq 'none') {
                    push @{$vm_win_buf->{abs_rq_values_for_perc}}, $runq_value_for_this_ts;
                } else {
                    my $smoothed_abs_rq;
                    if ($runq_avg_method_str eq 'sma') {
                        push @{$vm_win_buf->{runq_abs_sma_queue}}, $runq_value_for_this_ts; # Assumes $runq_value_for_this_ts is numeric here
                        shift @{$vm_win_buf->{runq_abs_sma_queue}} while scalar @{$vm_win_buf->{runq_abs_sma_queue}} > $window_minutes;
                        if (scalar @{$vm_win_buf->{runq_abs_sma_queue}} == $window_minutes) {
                            $smoothed_abs_rq = calculate_average(@{$vm_win_buf->{runq_abs_sma_queue}});
                        }
                    } elsif ($runq_avg_method_str eq 'ema') {
                        if (!defined $vm_win_buf->{runq_abs_prev_ema}) { $vm_win_buf->{runq_abs_prev_ema} = $runq_value_for_this_ts; }
                        else { $vm_win_buf->{runq_abs_prev_ema} = ($runq_value_for_this_ts * $alpha_for_ema) + ($vm_win_buf->{runq_abs_prev_ema} * (1-$alpha_for_ema)); }
                        push @{$vm_win_buf->{runq_abs_ema_point_counter}}, $runq_value_for_this_ts;
                        shift @{$vm_win_buf->{runq_abs_ema_point_counter}} while scalar @{$vm_win_buf->{runq_abs_ema_point_counter}} > $window_minutes;
                        if (scalar @{$vm_win_buf->{runq_abs_ema_point_counter}} == $window_minutes) {
                            $smoothed_abs_rq = $vm_win_buf->{runq_abs_prev_ema};
                        }
                    }
                    push @{$vm_win_buf->{abs_rq_values_for_perc}}, $smoothed_abs_rq if defined $smoothed_abs_rq;
                }

                # Normalised RunQ processing for window
                if (defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
                    my $effective_lcpus = $physc_value * $smt_value;
                    if ($effective_lcpus > $FLOAT_EPSILON) {
                        my $norm_runq_raw_val = $runq_value_for_this_ts / $effective_lcpus;
                        if ($runq_avg_method_str eq 'none') {
                            push @{$vm_win_buf->{norm_rq_values_for_perc}}, $norm_runq_raw_val;
                        } else {
                            my $smoothed_norm_rq;
                            if ($runq_avg_method_str eq 'sma') {
                                push @{$vm_win_buf->{runq_norm_sma_queue}}, $norm_runq_raw_val;
                                shift @{$vm_win_buf->{runq_norm_sma_queue}} while scalar @{$vm_win_buf->{runq_norm_sma_queue}} > $window_minutes;
                                if (scalar @{$vm_win_buf->{runq_norm_sma_queue}} == $window_minutes) {
                                    $smoothed_norm_rq = calculate_average(@{$vm_win_buf->{runq_norm_sma_queue}});
                                }
                            } elsif ($runq_avg_method_str eq 'ema') {
                                if (!defined $vm_win_buf->{runq_norm_prev_ema}) { $vm_win_buf->{runq_norm_prev_ema} = $norm_runq_raw_val; }
                                else { $vm_win_buf->{runq_norm_prev_ema} = ($norm_runq_raw_val * $alpha_for_ema) + ($vm_win_buf->{runq_norm_prev_ema} * (1-$alpha_for_ema)); }
                                push @{$vm_win_buf->{runq_norm_ema_point_counter}}, $norm_runq_raw_val;
                                shift @{$vm_win_buf->{runq_norm_ema_point_counter}} while scalar @{$vm_win_buf->{runq_norm_ema_point_counter}} > $window_minutes;
                                if (scalar @{$vm_win_buf->{runq_norm_ema_point_counter}} == $window_minutes) {
                                    $smoothed_norm_rq = $vm_win_buf->{runq_norm_prev_ema};
                                }
                            }
                            push @{$vm_win_buf->{norm_rq_values_for_perc}}, $smoothed_norm_rq if defined $smoothed_norm_rq;
                        }
                    }
                }
            } # End if defined runq_value_for_this_ts
        } else { # Standard Non-Windowed Processing
            # ... (Standard non-windowed processing logic for PhysC peak, PhysC rolling avg to temp file) ...
            my $vm_overall_peak_ref = defined($target_vm_name) ? \$vm_physc_max_peak_scalar_overall : \$vm_physc_max_peaks_list_overall[$vm_idx];
            if ($calculate_peak && defined $physc_value) { if (!defined(${$vm_overall_peak_ref}) || $physc_value > ${$vm_overall_peak_ref}) { ${$vm_overall_peak_ref} = $physc_value; } }
            my $current_avg_output_value_overall; my $temp_fh_overall; my $prev_ema_ref_overall; my $sma_queue_ref_overall;
            my $buffer_key = "_overall_vm_$current_vm_name";
            $temp_fh_overall = $temp_files_for_physc_rolling_avgs_overall{$current_vm_name}{fh};
            $prev_ema_ref_overall = \$current_window_vm_data_buffer{$buffer_key}{'physc_prev_ema'};
            $sma_queue_ref_overall = \@{$current_window_vm_data_buffer{$buffer_key}{'physc_sma_queue'}}; # Reusing structure, ensures it's an arrayref
            if ($avg_method eq 'sma') {
                if(defined $physc_value){ push @{$sma_queue_ref_overall}, $physc_value; } else {push @{$sma_queue_ref_overall}, undef;}
                shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes;
                if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = calculate_average(@{$sma_queue_ref_overall});}
            } else { # EMA
                if (defined $physc_value) { if (!defined ${$prev_ema_ref_overall}) { ${$prev_ema_ref_overall} = $physc_value; } else { ${$prev_ema_ref_overall} = ($physc_value * $alpha_for_ema) + (${$prev_ema_ref_overall} * (1 - $alpha_for_ema)); } }
                push @{$sma_queue_ref_overall}, $physc_value; # Use sma_queue as counter for EMA too
                shift @{$sma_queue_ref_overall} while scalar @{$sma_queue_ref_overall} > $window_minutes;
                if (scalar @{$sma_queue_ref_overall} == $window_minutes) { $current_avg_output_value_overall = ${$prev_ema_ref_overall}; }
            }
            if (defined $current_avg_output_value_overall && defined $temp_fh_overall) { print {$temp_fh_overall} "$current_avg_output_value_overall\n" or die "Error writing PhysC temp file for $current_vm_name: $!";}
            
            # Collect raw RunQ for later overall smoothing/percentile
            if (defined $runq_csv_file && defined $runq_value_for_this_ts && $runq_value_for_this_ts =~ /^-?[0-9.]+$/) {
                 my $current_raw_abs_rq_overall = $runq_value_for_this_ts + 0;
                 push @{$collected_runq_overall{$current_vm_name}{abs_raw}}, $current_raw_abs_rq_overall;
                 if (defined $physc_value && $physc_value >= $ACTIVE_PHYSC_THRESHOLD) {
                     my $effective_lcpus = $physc_value * $smt_value;
                     if ($effective_lcpus > $FLOAT_EPSILON) {
                         push @{$collected_runq_overall{$current_vm_name}{norm_raw}}, ($current_raw_abs_rq_overall / $effective_lcpus);
                     }
                 }
            }
        }
    }
    if ($data_lines_processed > 0 && $data_lines_processed % 10000 == 0) { print STDERR "Processed $data_lines_processed NMON data lines (matching filters)...\n"; }
}
close $physc_csv_fh;

if ($enable_windowed_decay_internal) {
    if ($current_window_idx < @processing_windows && %current_window_vm_data_buffer) {
         process_and_store_window_results(
            $processing_windows[$current_window_idx], \%current_window_vm_data_buffer, \%vm_data_by_window,
            \@vm_names_from_physc_header, $target_vm_index_in_physc, $target_vm_name,
            $percentile, $calculate_peak, $runq_csv_file, \@runq_norm_percentiles_to_calc, \@runq_abs_percentiles_to_calc,
            $runq_avg_method_str, $window_minutes, $alpha_for_ema
        );
    }
} else {
    foreach my $vm_name (keys %temp_files_for_physc_rolling_avgs_overall) {
        if (defined $temp_files_for_physc_rolling_avgs_overall{$vm_name}{fh}) {
            close $temp_files_for_physc_rolling_avgs_overall{$vm_name}{fh} or warn "Could not close temp file for $vm_name: $!";
        }
    }
    if (defined $runq_csv_file && $runq_avg_method_str ne 'none') {
        print STDERR "Calculating overall smoothed RunQ values for non-windowed mode...\n";
        foreach my $vm_name (keys %collected_runq_overall) { # Iterate populated keys
            if (exists $collected_runq_overall{$vm_name}{abs_raw} && @{$collected_runq_overall{$vm_name}{abs_raw}}) {
                my $smoothed_series_ref = calculate_rolling_average_series(
                    \@{$collected_runq_overall{$vm_name}{abs_raw}}, $runq_avg_method_str, $window_minutes, $alpha_for_ema
                );
                $collected_runq_overall{$vm_name}{abs_smoothed} = $smoothed_series_ref;
            }
            if (exists $collected_runq_overall{$vm_name}{norm_raw} && @{$collected_runq_overall{$vm_name}{norm_raw}}) {
                my $smoothed_series_ref = calculate_rolling_average_series(
                    \@{$collected_runq_overall{$vm_name}{norm_raw}}, $runq_avg_method_str, $window_minutes, $alpha_for_ema
                );
                $collected_runq_overall{$vm_name}{norm_smoothed} = $smoothed_series_ref;
            }
        }
    }
}
print STDERR "Finished reading NMON data. Processed $data_lines_processed data lines matching filters.\n";

# --- Final Result Assembly and Output ---
# (Identical to v2.27.147.4 - this section was already robust)
my @results_data_output;
print STDERR "Calculating final results...\n";
my @vms_for_final_output = defined($target_vm_name) ? ($target_vm_name) : @vm_names_from_physc_header;

foreach my $vm_name (@vms_for_final_output) {
    my $output_line_for_vm = "$vm_name:";
    my %final_metrics_for_vm;

    if ($enable_windowed_decay_internal) {
        my $p_label_main_decay = sprintf("P%.2f", $percentile); $p_label_main_decay =~ s/\.?0+$//; $p_label_main_decay = "0" if $p_label_main_decay eq "" && abs($percentile-0)<0.001;
        $p_label_main_decay = "P$p_label_main_decay" unless $p_label_main_decay =~ /^P/;
        $final_metrics_for_vm{$p_label_main_decay} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $p_label_main_decay, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val);
        if ($calculate_peak) { $final_metrics_for_vm{'Peak'} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, 'Peak', \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val); }
        if (defined $runq_csv_file) {
			  foreach my $p_val (@runq_norm_percentiles_to_calc) {
				  my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//;$p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001;
				  my $mk="NormRunQ_P$p_lbl_base"; $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");
            }
            foreach my $p_val (@runq_abs_percentiles_to_calc)  { my $p_lbl_base = sprintf("%.2f",$p_val); $p_lbl_base=~s/\.?0+$//;$p_lbl_base="0" if $p_lbl_base eq ""&&abs($p_val-0)<0.001; my $mk="AbsRunQ_P$p_lbl_base";  $final_metrics_for_vm{$mk} = get_weighted_metric_for_vm(\%vm_data_by_window, $vm_name, $mk, \@processing_windows, $actual_analysis_ref_date_obj, $decay_half_life_days_val, "%.2f");}
        }
    } else {
        my $temp_file_path_val = $temp_files_for_physc_rolling_avgs_overall{$vm_name}{filename};
        my @physc_avg_values_from_file;
        my $percentile_val_raw_overall = undef;
        my $vm_idx_overall = (defined($target_vm_name) && $target_vm_name eq $vm_name) ? $target_vm_index_in_physc : get_vm_index_by_name($vm_name, \@vm_names_from_physc_header);
        my $peak_val_raw_overall = defined($target_vm_name) ? $vm_physc_max_peak_scalar_overall : ( (defined $vm_idx_overall && defined $vm_physc_max_peaks_list_overall[$vm_idx_overall]) ? $vm_physc_max_peaks_list_overall[$vm_idx_overall] : undef);

        if (defined $temp_file_path_val && -f $temp_file_path_val && -s $temp_file_path_val) {
            open my $in_fh, '<', $temp_file_path_val or print STDERR "Warning: Could not open temp file $temp_file_path_val for $vm_name: $!\n";
            if ($in_fh) { while (my $num = <$in_fh>) { chomp $num; if ($num =~ /^-?[0-9]+(?:\.[0-9]+)?$/) { push @physc_avg_values_from_file, $num; } } close $in_fh; }
        }
        unlink $temp_file_path_val or warn "Could not delete temporary file '$temp_file_path_val': $!" if defined $temp_file_path_val && -f $temp_file_path_val;
        
        if (@physc_avg_values_from_file && defined $filter_above_perc_value) {
             my @sff = sort { $a <=> $b } @physc_avg_values_from_file; my $ft = calculate_percentile(\@sff, $filter_above_perc_value);
             if (defined $ft) {
                 my @fa = grep { defined($_) && $_ >= ($ft - $FLOAT_EPSILON) } @physc_avg_values_from_file;
                 if (@fa) { my @sf = sort { $a <=> $b } @fa; $percentile_val_raw_overall = calculate_percentile(\@sf, $percentile); }
                 else { $percentile_val_raw_overall = undef; }
             } else { if (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile); }}
        } elsif (@physc_avg_values_from_file) { my @sa = sort { $a <=> $b } @physc_avg_values_from_file; $percentile_val_raw_overall = calculate_percentile(\@sa, $percentile); }
        
        my $p_label_main_overall = sprintf("P%.2f", $percentile); $p_label_main_overall =~ s/\.?0+$//; $p_label_main_overall = "0" if $p_label_main_overall eq "" && abs($percentile-0)<0.001;
        $p_label_main_overall = "P$p_label_main_overall" unless $p_label_main_overall =~ /^P/;
        $final_metrics_for_vm{$p_label_main_overall} = defined($percentile_val_raw_overall) ? $percentile_val_raw_overall : "N/A";
        if ($calculate_peak) { $final_metrics_for_vm{'Peak'} = defined($peak_val_raw_overall) ? $peak_val_raw_overall : "N/A"; }

        if (defined $runq_csv_file && exists $collected_runq_overall{$vm_name}) {
            my $norm_data_source_ref = ($runq_avg_method_str ne 'none' && exists $collected_runq_overall{$vm_name}{norm_smoothed})
                                     ? $collected_runq_overall{$vm_name}{norm_smoothed}
                                     : (exists $collected_runq_overall{$vm_name}{norm_raw} ? \@{$collected_runq_overall{$vm_name}{norm_raw}} : undef );
            my $abs_data_source_ref  = ($runq_avg_method_str ne 'none' && exists $collected_runq_overall{$vm_name}{abs_smoothed})
                                     ? $collected_runq_overall{$vm_name}{abs_smoothed}
                                     : (exists $collected_runq_overall{$vm_name}{abs_raw} ? \@{$collected_runq_overall{$vm_name}{abs_raw}} : undef );

            if (defined $norm_data_source_ref && @{$norm_data_source_ref}) {
                my @sorted_norm = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$norm_data_source_ref};
                if (@sorted_norm) {
                    foreach my $p_val (@runq_norm_percentiles_to_calc) { my $val = calculate_percentile(\@sorted_norm, $p_val); my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"NormRunQ_P$pl"} = defined($val)?sprintf("%.2f",$val):"N/A";}
                } else {
                     foreach my $p_val (@runq_norm_percentiles_to_calc) { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"NormRunQ_P$pl"} = "N/A";}
                }
            } else {
                 foreach my $p_val (@runq_norm_percentiles_to_calc) { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"NormRunQ_P$pl"} = "N/A";}
            }
            if (defined $abs_data_source_ref && @{$abs_data_source_ref}) {
                my @sorted_abs = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$abs_data_source_ref};
                if (@sorted_abs) {
                    foreach my $p_val (@runq_abs_percentiles_to_calc) { my $val = calculate_percentile(\@sorted_abs, $p_val); my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"AbsRunQ_P$pl"} = defined($val)?sprintf("%.2f",$val):"N/A";}
                } else {
                    foreach my $p_val (@runq_abs_percentiles_to_calc) { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"AbsRunQ_P$pl"} = "N/A";}
                }
            } else {
                foreach my $p_val (@runq_abs_percentiles_to_calc) { my $pl = sprintf("P%.2f",$p_val); $pl=~s/\.?0+$//;$pl="0" if $pl eq ""&&abs($p_val-0)<0.001; $final_metrics_for_vm{"AbsRunQ_P$pl"} = "N/A";}
            }
        }
    }

    my $p_label_out = sprintf("P%.2f", $percentile); $p_label_out =~ s/\.?0+$//; $p_label_out = "0" if $p_label_out eq "" && abs($percentile-0)<0.001;
    $p_label_out = "P$p_label_out" unless $p_label_out =~ /^P/;
    my $physc_p_val = $final_metrics_for_vm{$p_label_out} // "N/A";
    if ($physc_p_val ne "N/A" && $physc_p_val =~ /^-?[0-9.]+$/) { my $r = apply_rounding($physc_p_val, $round_increment, $rounding_method); $output_line_for_vm .= " $p_label_out=" . sprintf("%.${output_dp}f", $r); }
    else { $output_line_for_vm .= " $p_label_out=N/A"; }

    if ($calculate_peak) {
        my $peak_val = $final_metrics_for_vm{'Peak'} // "N/A";
        if ($peak_val ne "N/A" && $peak_val =~ /^-?[0-9.]+$/) { my $r = apply_rounding($peak_val, $round_increment, $rounding_method); $output_line_for_vm .= " Peak=" . sprintf("%.${output_dp}f", $r); }
        else { $output_line_for_vm .= " Peak=N/A"; }
    }
    
    my @runq_metric_keys_ordered;
	 if (defined $runq_csv_file) {
		 foreach my $p_val (@runq_norm_percentiles_to_calc) {
			 my $p_num_label = sprintf("%.2f", $p_val); # e.g., "50.00"
				 $p_num_label =~ s/\.?0+$//;                # e.g., "50"
				 $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
			 push @runq_metric_keys_ordered, "NormRunQ_P$p_num_label"; # Correct: "NormRunQ_P50"
		 }

		 foreach my $p_val (@runq_abs_percentiles_to_calc)  {
			 my $p_num_label = sprintf("%.2f", $p_val); # e.g., "90.00"
				 $p_num_label =~ s/\.?0+$//;                # e.g., "90"
				 $p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
			 push @runq_metric_keys_ordered, "AbsRunQ_P$p_num_label";   # Correct: "AbsRunQ_P90"
		 }
	 }
    foreach my $key (@runq_metric_keys_ordered) {
        $output_line_for_vm .= " $key=" . ($final_metrics_for_vm{$key} // "N/A");
    }
    
    push @results_data_output, { line => $output_line_for_vm };
}

my $peak_note_out = $calculate_peak ? " (Peak Calc: Yes)" : "";
my $runq_note_out = defined($runq_csv_file) ? " (RunQ SMT: $smt_value, NormPercs: $runq_norm_perc_str, AbsPercs: $runq_abs_perc_str, RunQAvgMethod: $runq_avg_method_str)" : "";
my $rounding_note_out = ($rounding_method ne 'none') ? " (Rounded $rounding_method to $round_increment)" : "";
my $filter_note_out = $time_filter_active ? " (Time Filter: $time_filter_desc)" : "";
my $weekend_note_out = $no_weekends ? " (Weekends Excluded)" : "";
my $perc_filter_note_val_out = defined($filter_above_perc_value) ? sprintf("P%.2f", $filter_above_perc_value) : "";
if ($perc_filter_note_val_out ne "") {$perc_filter_note_val_out =~ s/\.?0+$//; $perc_filter_note_val_out = "0" if $perc_filter_note_val_out eq "" && abs($filter_above_perc_value - 0) < 0.001;}
my $perc_filter_note_out = defined($filter_above_perc_value) ? " (PhysC Perc Filter >= $perc_filter_note_val_out)" : "";
my $date_filter_note_out_final = "";
if (defined $start_date_str || defined $end_date_str) { $date_filter_note_out_final = " (Global Date Filter:"; if (defined $start_date_str) { $date_filter_note_out_final .= " Start=$start_date_str"; } if (defined $end_date_str) { $date_filter_note_out_final .= (defined($start_date_str) ? "," : "") . " End=$end_date_str"; } $date_filter_note_out_final .= ")";}
my $window_decay_note_out = $enable_windowed_decay_internal ? " (Windowed Decay: ON, Unit=$process_window_unit_str, Size=$process_window_size_val, HalfLife=${decay_half_life_days_val}d)" : "";
my $header_run_params_label_out_final = sprintf("P%.2f", $percentile); $header_run_params_label_out_final =~ s/\.?0+$//; $header_run_params_label_out_final = "0" if $header_run_params_label_out_final eq "" && abs($percentile-0)<0.001;
$header_run_params_label_out_final = "P$header_run_params_label_out_final" unless $header_run_params_label_out_final =~ /^P/;
$header_run_params_label_out_final .= ", W=$window_minutes (" . uc($avg_method);
if ($avg_method eq 'ema') { $header_run_params_label_out_final .= ", Decay=$decay_level"; }
$header_run_params_label_out_final .= ")";
if (@results_data_output) { print STDERR "\n--- Run Summary ($header_run_params_label_out_final)$peak_note_out$runq_note_out$rounding_note_out$filter_note_out$weekend_note_out$perc_filter_note_out$date_filter_note_out_final$window_decay_note_out ---\n"; }
else { print STDERR "\n--- No results generated for this run (check filters/data) ---\n"; }
foreach my $res (@results_data_output) { print STDOUT $res->{line} . "\n"; }
my $script_end_time_final_run = time();
my $duration_final_run = $script_end_time_final_run - $script_start_time;
print STDERR "\nProcessing completed in $duration_final_run seconds.\n";
exit 0;

# ==============================================================================
# Subroutines (ALL subroutines from v2.27.147.3 + calculate_rolling_average_series)
# ==============================================================================
sub parse_percentile_list {
    my ($perc_str, $arg_name) = @_;
    my @percentiles;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p !~ /^[0-9]+(?:\.[0-9]+)?$/ || $p < 0 || $p > 100)
            {
                die "Error: Invalid percentile value '$p' in --$arg_name list. Must be numeric between 0 and 100.\n";
            }
            push @percentiles, $p + 0;
        }
    }
    return @percentiles;
}

sub get_nmon_overall_date_range {
    my ($nmon_file, $global_start_filter_str, $global_end_filter_str) = @_;
    print STDERR "Scanning NMON file '$nmon_file' for overall effective date range...\n";
    open my $fh, '<:encoding(utf8)', $nmon_file or die "Error: Cannot open NMON file '$nmon_file': $!\n";
    my $min_date_obj; my $max_date_obj; my $header_skipped = 0; my $first_data_line_checked = 0;
    my $start_filter_obj; my $end_filter_obj;
    if (defined $global_start_filter_str) { eval { $start_filter_obj = Time::Piece->strptime($global_start_filter_str, "%Y-%m-%d"); }; if ($@ || (defined $global_start_filter_str && ! (defined $start_filter_obj && $start_filter_obj->isa('Time::Piece') ) ) ) { die "Error parsing global start date filter '$global_start_filter_str': $@\n"; }}
    if (defined $global_end_filter_str) { eval { $end_filter_obj = Time::Piece->strptime($global_end_filter_str, "%Y-%m-%d"); }; if ($@ || (defined $global_end_filter_str && ! (defined $end_filter_obj && $end_filter_obj->isa('Time::Piece') ) ) ) { die "Error parsing global end date filter '$global_end_filter_str': $@\n"; }}
    while (my $line = <$fh>) {
        chomp $line; $line =~ s/\r$//; next if $line =~ /^\s*$/;
        if (!$header_skipped && !$first_data_line_checked) { if ($line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i) { $header_skipped = 1; next; } $first_data_line_checked = 1; }
        elsif ($header_skipped && $line =~ /^(Time,|Date,Time,Hostname,ZZZZ)/i) { next; }
        if ($line =~ /^(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/) {
            my $timestamp_str = $1; $timestamp_str =~ s/T/ /; my $current_tp;
            eval { $current_tp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S"); };
            if ($@ || !$current_tp || !$current_tp->isa('Time::Piece')) { next; }
            my $current_date_day_obj = $current_tp->truncate(to => 'day');
            if (defined $start_filter_obj && $current_date_day_obj < $start_filter_obj) { next; }
            if (defined $end_filter_obj   && $current_date_day_obj > $end_filter_obj)   { next; }
            if (!defined $min_date_obj || !$min_date_obj->isa('Time::Piece') || $current_tp < $min_date_obj) { $min_date_obj = $current_tp; }
            if (!defined $max_date_obj || !$max_date_obj->isa('Time::Piece') || $current_tp > $max_date_obj) { $max_date_obj = $current_tp; }
        }
    } close $fh;
    if (defined $min_date_obj && $min_date_obj->isa('Time::Piece') && defined $max_date_obj && $max_date_obj->isa('Time::Piece')) {
        print STDERR "Effective NMON data range for windowing: " . $min_date_obj->datetime . " to " . $max_date_obj->datetime . "\n";
        my $ret_start = $min_date_obj->truncate(to => 'day'); my $ret_end   = $max_date_obj->truncate(to => 'day');
        unless (defined $ret_start && $ret_start->isa('Time::Piece') && defined $ret_end && $ret_end->isa('Time::Piece')) { print STDERR "Error: Truncated date objects became invalid in get_nmon_overall_date_range.\n"; return (undef, undef); }
        return ($ret_start, $ret_end);
    } else { print STDERR "Warning: Could not determine valid min/max dates from NMON file '$nmon_file' after global filters.\n"; return (undef, undef); }
}

sub generate_processing_time_windows {
    my ($period_start_obj, $period_end_obj, $unit_str, $size_val) = @_; my @windows;
    return () unless (defined $period_start_obj && defined $period_end_obj && $period_start_obj->isa('Time::Piece') && $period_end_obj->isa('Time::Piece') && $period_start_obj <= $period_end_obj);
    my $current_window_start = Time::Piece->new($period_start_obj->epoch);
    while ($current_window_start <= $period_end_obj) {
        my $current_window_end;
        if ($unit_str eq "days") { $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_DAY() * ($size_val - 1)); }
        elsif ($unit_str eq "weeks") { $current_window_end = Time::Piece->new($current_window_start->epoch) + (ONE_WEEK() * $size_val) - ONE_DAY(); }
        else { die "Unsupported window unit: $unit_str\n"; }
        if ($current_window_end > $period_end_obj) { $current_window_end = Time::Piece->new($period_end_obj->epoch); }
        my $representative_date = Time::Piece->new($current_window_end->epoch);
        push @windows, [Time::Piece->new($current_window_start->epoch), Time::Piece->new($current_window_end->epoch), $representative_date]; # Store new objects
        my $next_window_start_candidate = $current_window_end + ONE_DAY();
        last if ($next_window_start_candidate > $period_end_obj && $current_window_end >= $period_end_obj);
        $current_window_start = $next_window_start_candidate;
    } return @windows;
}

sub get_window_key_for_timestamp {
    my ($timestamp_obj, $windows_aref, $hint_idx) = @_;
    my $timestamp_day_obj = $timestamp_obj->truncate(to => 'day');
    if (defined $hint_idx && $hint_idx >=0 && $hint_idx < @{$windows_aref}) {
        my ($win_start, $win_end) = @{$windows_aref->[$hint_idx]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end) { return $windows_aref->[$hint_idx][2]->ymd('') . "_" . $hint_idx; }
    }
    for (my $i=0; $i < @{$windows_aref}; $i++) {
        my ($win_start, $win_end) = @{$windows_aref->[$i]};
        if ($timestamp_day_obj >= $win_start && $timestamp_day_obj <= $win_end) { return $windows_aref->[$i][2]->ymd('') . "_" . $i; }
    }
    return undef;
}

sub process_and_store_window_results {
    my ($window_def_ref, $current_vm_win_buf_href, $vm_overall_win_data_href,
        $all_vm_names_aref, $target_vm_idx_nullable, $target_vm_name_nullable,
        $main_physc_percentile_arg, $calc_peak_arg, $has_runq_data_arg,
        $runq_norm_p_aref_arg, $runq_abs_p_aref_arg,
        $current_runq_avg_method_arg, $current_win_minutes_arg, $current_alpha_for_ema_arg
    ) = @_;

    my ($win_start, $win_end, $win_rep_date) = @{$window_def_ref};
    my $win_idx = -1;
    for (my $i=0; $i < @processing_windows; $i++) { if ($processing_windows[$i][2]->epoch == $win_rep_date->epoch) { $win_idx = $i; last; }}
    return unless $win_idx != -1;
    my $window_key = $win_rep_date->ymd('') . "_" . $win_idx;

    my @vms_to_process_this_window_list;
    if (defined $target_vm_idx_nullable) { push @vms_to_process_this_window_list, $target_vm_name_nullable; }
    else { @vms_to_process_this_window_list = @{$all_vm_names_aref}; }

    foreach my $vm_name (@vms_to_process_this_window_list) {
        # Ensure the buffer for this specific window_key exists before trying to access it
        next unless (exists $current_vm_win_buf_href->{$vm_name} && exists $current_vm_win_buf_href->{$vm_name}{$window_key});
        my $vm_win_data = $current_vm_win_buf_href->{$vm_name}{$window_key};


        my $p_label_main = sprintf("P%.2f", $main_physc_percentile_arg); $p_label_main =~ s/\.?0+$//; $p_label_main = "0" if $p_label_main eq "" && abs($main_physc_percentile_arg-0)<0.001;
        $p_label_main = "P$p_label_main" unless $p_label_main =~ /^P/;

        if (exists $vm_win_data->{rolling_physc_avgs} && @{$vm_win_data->{rolling_physc_avgs}}) {
            my @sorted_physc_avgs = sort {$a <=> $b} grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{rolling_physc_avgs}};
            if (@sorted_physc_avgs) {
                my $physc_perc_val = calculate_percentile(\@sorted_physc_avgs, $main_physc_percentile_arg);
                $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = defined($physc_perc_val) ? $physc_perc_val : "N/A";
            } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = "N/A"; }
        } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$p_label_main} = "N/A"; }

        if ($calc_peak_arg) {
            if (exists $vm_win_data->{raw_physc_for_peak} && @{$vm_win_data->{raw_physc_for_peak}}) {
                my @defined_peaks = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{raw_physc_for_peak}};
                $vm_overall_win_data_href->{$vm_name}{$window_key}{'Peak'} = @defined_peaks ? max(@defined_peaks) : "N/A";
            } else { $vm_overall_win_data_href->{$vm_name}{$window_key}{'Peak'} = "N/A"; }
        }
        if ($has_runq_data_arg) {

            my @abs_rq_for_perc_cleaned = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{abs_rq_values_for_perc}};

				foreach my $p_val (@{$runq_abs_p_aref_arg}) {
					my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && abs($p_val-0)<0.001;
					my $p_num_label = sprintf("%.2f", $p_val); # e.g., "90.00"
					$p_num_label =~ s/\.?0+$//;                # e.g., "90"
					$p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
					my $metric_key = "AbsRunQ_P$p_num_label"; # This will be "AbsRunQ_P90"
						if (@abs_rq_for_perc_cleaned) {
							my @sorted_vals = sort {$a <=> $b} @abs_rq_for_perc_cleaned;
							my $val = calculate_percentile(\@sorted_vals, $p_val);

							$vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A";
						} else {

							$vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A";
						}
				}
            my @norm_rq_for_perc_cleaned = grep {defined $_ && $_ =~ /^-?[0-9.]+$/} @{$vm_win_data->{norm_rq_values_for_perc}};
				foreach my $p_val (@{$runq_norm_p_aref_arg}) {
					my $p_lbl = sprintf("P%.2f", $p_val); $p_lbl =~ s/\.?0+$//; $p_lbl = "0" if $p_lbl eq "" && abs($p_val-0)<0.001;
					my $p_num_label = sprintf("%.2f", $p_val); # e.g., "50.00"
						$p_num_label =~ s/\.?0+$//;                # e.g., "50"
						$p_num_label = "0" if $p_num_label eq "" && abs($p_val-0)<0.001;
					my $metric_key = "NormRunQ_P$p_num_label"; # This will be "NormRunQ_P50"
						if (@norm_rq_for_perc_cleaned) {
							my @sorted_vals = sort {$a <=> $b} @norm_rq_for_perc_cleaned;
							my $val = calculate_percentile(\@sorted_vals, $p_val);
							$vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = defined($val) ? sprintf("%.2f", $val) : "N/A";
						} else { $vm_overall_win_data_href->{$vm_name}{$window_key}{$metric_key} = "N/A"; }
				}
        }
    }
}

sub get_weighted_metric_for_vm { # This subroutine was missing
    my ($vm_data_by_window_href, $vm_name, $metric_key,
        $processing_windows_aref, $analysis_ref_obj_arg, $decay_hl_days_arg, $sprintf_fmt_optional) = @_;

    my @metric_window_values;
    if (exists $vm_data_by_window_href->{$vm_name})
    {
        foreach my $win_key (sort keys %{$vm_data_by_window_href->{$vm_name}})
        {
            if (exists $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} &&
                defined $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} &&
                $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key} ne "N/A" )
            {
                my ($win_date_str_part, $win_idx_part) = ($win_key =~ /^(\d{8})_(\d+)$/);
                if (defined $win_idx_part && $win_idx_part < @{$processing_windows_aref})
                {
                    my $rep_date_obj = $processing_windows_aref->[$win_idx_part][2];
                    unless (defined $rep_date_obj && $rep_date_obj->isa('Time::Piece'))
                    {
                        print STDERR "Warning: Representative date for window key '$win_key' is invalid for VM '$vm_name', metric '$metric_key'. Skipping this window point.\n";
                        next;
                    }
                    push @metric_window_values, {
                        value => $vm_data_by_window_href->{$vm_name}{$win_key}{$metric_key},
                        date  => $rep_date_obj
                    };
                }
                else
                {
                    print STDERR "Warning: Could not accurately map window key '$win_key' to a processing window definition for VM '$vm_name', metric '$metric_key'. Skipping this window point.\n";
                }
            }
        }
    } 

}

    if (@metric_window_values)
    {
        my $weighted_val_str = calculate_recency_weighted_average(
            \@metric_window_values, $analysis_ref_obj_arg, $decay_hl_days_arg
        );
        if (defined $sprintf_fmt_optional && defined $weighted_val_str && $weighted_val_str ne "N/A" && $weighted_val_str =~ /^-?[0-9.]+$/)
        {
            return sprintf($sprintf_fmt_optional, $weighted_val_str + 0);
        }
        return $weighted_val_str;
    }
    return "N/A";
}


sub calculate_recency_weighted_average {
    my ($windowed_data_ref, $analysis_ref_obj_arg, $half_life_days_arg) = @_;
    my $sum_weighted_values = 0; my $sum_weights = 0;
    return "N/A" if (!defined $analysis_ref_obj_arg || !$analysis_ref_obj_arg->isa('Time::Piece'));
    return "N/A" if (!defined $half_life_days_arg || $half_life_days_arg <= 0);
    my $lambda = log(2) / $half_life_days_arg;
    foreach my $dp_ref (@{$windowed_data_ref}) {
        my $value_str = $dp_ref->{value};
        next if (!defined $value_str || $value_str eq "N/A" || $value_str !~ /^-?[0-9.]+$/);
        my $value = $value_str + 0;
        my $date_obj = $dp_ref->{date};
        next if (!defined $date_obj || !$date_obj->isa('Time::Piece'));
        my $date_obj_day = $date_obj->truncate(to => 'day');
        my $analysis_ref_day = $analysis_ref_obj_arg->truncate(to => 'day');
        my $days_diff_seconds = $analysis_ref_day->epoch - $date_obj_day->epoch;
        my $days_diff = $days_diff_seconds / ONE_DAY(); # Corrected
        $days_diff = 0 if $days_diff < 0;
        my $weight = exp(-$lambda * $days_diff);
        $sum_weighted_values += $value * $weight;
        $sum_weights += $weight;
    }
    if ($sum_weights > 1e-9) {
        return sprintf("%.4f", $sum_weighted_values / $sum_weights);
    } else { return "N/A"; }
}

sub get_vm_index_by_name {
    my ($vm_name_to_find, $vm_names_list_ref) = @_;
    for (my $i=0; $i < @{$vm_names_list_ref}; $i++) {
        if ($vm_names_list_ref->[$i] eq $vm_name_to_find) {
            return $i;
        }
    }
    return undef;
}

sub calculate_average { my @values = @_; my @defined_values = grep { defined($_) && $_ ne '' && $_ =~ /^-?[0-9.]+$/ } @values; my $count = scalar @defined_values; return undef if $count == 0; my $sum = sum0(@defined_values); return $sum / $count; }
sub calculate_percentile { my ($data_ref, $p) = @_; my @data_input = @{$data_ref}; my @data = grep { defined($_) && $_ =~ /^-?[0-9]+(?:\.[0-9]+)?$/ } @data_input; my $n = scalar @data; return undef if $n == 0; @data = sort { $a <=> $b } @data; return $data[0] if $n == 1; my $rank_fractional = ($p / 100) * ($n - 1); my $k = int($rank_fractional); my $d = $rank_fractional - $k; if ($p == 0) { return $data[0]; } if ($p == 100) { return $data[$n-1]; } if ($k >= $n - 1) { return $data[$n - 1]; } elsif ($k < 0) { return $data[0]; } else { my $val_k = $data[$k]; my $val_k_plus_1 = ($k + 1 < $n) ? $data[$k + 1] : $data[$k]; return $val_k + $d * ($val_k_plus_1 - $val_k); }}
sub apply_rounding { my ($value, $increment, $method) = @_; return $value unless (defined $value && $value =~ /^-?[0-9]+(?:\.[0-9]+)?$/); return $value if $method eq 'none' || !defined $increment || $increment <= $FLOAT_EPSILON; my $rounded_value; if ($method eq 'standard') { $rounded_value = int( ($value / $increment) + ( ($value >= 0) ? 0.5 : -0.5) ) * $increment; } elsif ($method eq 'up') { $rounded_value = ceil( $value / $increment ) * $increment; } else { $rounded_value = $value; } return $rounded_value; }
sub get_decimal_places { my ($number_str) = @_; $number_str = sprintf("%.15f", $number_str) if ($number_str =~ /e/i); if ($number_str =~ /\.(\d+)$/) { return length($1); } else { return 0; }}
sub usage { my $script_name = $0; $script_name =~ s{.*/}{}; my $valid_decays_usage = join("|", sort keys %EMA_ALPHAS);
    return <<END_USAGE;
Usage: $script_name --physc-data <file> [options]

Analyses NMON PhysC and optionally RunQ data.
If --enable-windowed-decay is used, applies recency weighting to windowed results.

Core Input & Averaging Method (used within each window if decay enabled):
  --physc-data, -pc <file> : Path to input CSV file with PhysC data (required).
  --avg-method <method>    : Averaging method for PhysC: 'sma' or 'ema'. (Default: $DEFAULT_AVG_METHOD)
  --decay <level>          : If 'ema', specifies decay level: $valid_decays_usage. (Default: $DEFAULT_DECAY_LEVEL)
                           Also used for RunQ EMA if --runq-avg-method=ema.
  -w, --window <minutes>     : Window for SMA (PhysC or RunQ); conceptual span/stabilisation trigger for EMA.
                           (Default: $DEFAULT_WINDOW_MINUTES min). Also used for RunQ if smoothing enabled.

RunQ Data Input (Optional):
  --runq-data, -rq <file>  : Path to input CSV file with RunQ data.
  --smt <N>                : SMT level for RunQ normalisation (Default: $DEFAULT_SMT).
  --runq-norm-perc <list>  : Comma-separated percentiles for Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERC").
  --runq-abs-perc <list>   : Comma-separated percentiles for Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERC").
  --runq-avg-method <none|sma|ema> : Averaging method for RunQ data before percentile.
                               (Default: $DEFAULT_RUNQ_AVG_METHOD). Uses global -w/--decay settings.

Filtering Options (Applied BEFORE windowing if decay enabled):
  -s, --startdate <YYYY-MM-DD> : Ignore data before this date (overall filter).
  -ed, --enddate <YYYY-MM-DD>  : Ignore data after this date (overall filter).
  -startt <HH:MM> / -endt <HH:MM> : Daily time filter.
  -online / -batch           : Shortcut daily time filters.
  -no-weekends               : Exclude data from Saturdays and Sundays.
  -vm, --lpar <name>         : Analyse only the specified VM/LPAR name.

PhysC Calculation Options:
  -p, --percentile <value>   : Final percentile of PhysC (0-100) (Default: $DEFAULT_PERCENTILE).
                               If windowed decay, this is the percentile calculated per window.
  -k, --peak                 : Calculate peak PhysC value. (If windowed, weighted peak of window peaks).
  --filter-above-perc <N>    : Optional. Filter rolling PhysC values before PXX calc. (Applied per window if decay enabled).

Windowed Recency Decay (Optional - nfit performs all windowing internally):
  --enable-windowed-decay     : Enable internal windowed processing with recency decay.
  --process-window-unit <days|weeks> : Unit for processing window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT).
  --process-window-size <N>   : Size of each window in specified units (Default: $DEFAULT_PROCESS_WINDOW_SIZE).
  --decay-half-life-days <N>  : Half-life in days for recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS).
  --analysis-reference-date <YYYY-MM-DD> : "Current" date for recency calculation
                                (Default: Date of last record in filtered NMON PhysC data).
Rounding Options:
  -r[=increment] / -u[=increment] : Round results (Default increment: $DEFAULT_ROUND_INCREMENT).

Other:
  -h, --help                 : Display this help message.
  -v, --version              : Display script version.
END_USAGE
}
