#!/usr/bin/env perl

# NAME     : nfit-profile
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' multiple times with user-defined profiles.
#            Applies RunQ modifiers, generates hints, logs rationale, and aggregates to CSV.
# REQUIRES : Perl, nfit script (v2.28.0.4+), Time::Piece, List::Util, IO::File, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);
use Time::Piece;
use List::Util qw(sum min max); # sum0 is available from List::Util 1.33+
use IO::File;
use version;

# --- Store original ARGV for logging ---
my @original_argv = @ARGV;

# --- Capture nfit-profile.pl start time ---
my $PROFILE_SCRIPT_START_TIME_EPOCH = time();
my $PROFILE_SCRIPT_START_TIME_STR = localtime($PROFILE_SCRIPT_START_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");

# --- Version ---
my $SCRIPT_VERSION = '2.25.152.0';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90"; # Global default for nfit-profile if not in profile's flags
my $DEFAULT_RUNQ_ABS_PERCS  = "90";    # Global default for nfit-profile if not in profile's flags
my $DEFAULT_NFIT_RUNQ_AVG_METHOD = "ema";

# Windowed Decay Defaults (for when nfit-profile instructs nfit to use its internal decay)
my $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT = 30;

# Heuristic Thresholds (for sizing hints and RunQ modifiers)
my $PATTERN_RATIO_THRESHOLD = 2.0;     # For O vs B pattern determination
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;   # For "Very Peaky" shape
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;   # For "Moderately Peaky" shape
my $LIMIT_THRESHOLD_PERC = 0.98;       # P99W1 vs MaxCPU for pressure detection

# RunQ Modifier Thresholds (for calculate_runq_modified_physc)
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 2.0; # NormRunQ P90 above this may indicate workload pressure
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 1.8;       # AbsRunQ P90 / (MaxCPU * SMT) above this indicates RunQ pressure
my $RUNQ_ADDITIVE_TOLERANCE_FACTOR = 1.8;               # Tolerate AbsRunQ up to this Factor x Base_Profile_PhysC's LCPU capacity

# Max_Additive_CPU Sliding Scale Thresholds (caps additive CPU based on current entitlement)
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;    # If Ent < 1.0, max add = 1.0 core
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;   # If Ent < 2.0, max add = 100% of Ent
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;  # If Ent < 4.0, max add = 75% of Ent
my $MAX_ADD_PERC_VAL_ELSE = 0.5;                             # Else, max add = 50% of Ent

# RunQ Volatility Confidence Factor Thresholds & Values (adjusts additive CPU based on P90/P50 RunQ ratio)
my $VOLATILITY_SPIKY_THRESHOLD = 0.5;    my $VOLATILITY_SPIKY_FACTOR = 0.70;    # Very stable/spiky, less confidence in adding CPU
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85; # Moderately stable
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0; # Full confidence if RunQ saturation is high

# --- Advanced Efficiency Adjustment Tunable Parameters ---
# Guard Rail for High Existing Constraint (Efficiency Reduction Skip)
my $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD = 0.90; # If Base PhysC > 90% of MaxCPU
my $RUNQ_PRESSURE_FOR_CONSTRAINT_GUARD_FACTOR = 0.80;      # And RunQ Pressure > (this factor * saturation_threshold)

# Dynamic Blending Weights for Efficient Target (P_efficient_target_raw vs. BasePhysC)
my $NORM_P50_LOW_THRESH_FOR_BLEND1 = 0.25;       # If NormP50 < this, give more weight to raw target
my $BLEND_WEIGHT_BASE_FOR_LOW_P50_1 = 0.60;      #   60% Base / 40% Raw Target
my $NORM_P50_MODERATE_THRESH_FOR_BLEND2 = 0.40;  # If NormP50 < this (but >= BLEND1), moderate blend
my $BLEND_WEIGHT_BASE_FOR_LOW_P50_2 = 0.75;      #   75% Base / 25% Raw Target (original idea)
# If NormP50 >= MODERATE_THRESH_FOR_BLEND2 (but still low enough for efficiency consideration),
# lean more heavily on BasePhysC by default (e.g., 85% Base / 15% Target)
my $BLEND_WEIGHT_BASE_DEFAULT_LOW_P50 = 0.85;

# Volatility-Sensitive Cap for MAX_EFFICIENCY_REDUCTION_PERCENTAGE
# These thresholds are for Volatility Ratio (P90/P50)
my $VOLATILITY_MODERATE_LOW_CAP_THRESH = 1.2;  # Volatility above this starts to reduce the reduction cap
my $VOLATILITY_MODERATE_HIGH_CAP_THRESH = 1.8; # Volatility above this reduces cap more significantly
# Factors to scale down MAX_EFFICIENCY_REDUCTION_PERCENTAGE
my $REDUCTION_CAP_SCALE_FOR_MODERATE_VOLATILITY = 0.66; # e.g., 15% * 0.66 = ~10% max cut
my $REDUCTION_CAP_SCALE_FOR_MODERATE_HIGH_VOLATILITY = 0.33; # e.g., 15% * 0.33 = ~5% max cut

# --- Enhanced Efficiency Factor Constants (for calculate_runq_modified_physc) ---
my $VOLATILITY_CAUTION_THRESHOLD = 2.5; # If NormRunQ P90/P50 ratio >= this, skip efficiency reduction
my $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION = 0.5; # NormRunQ P50 must be below this to consider efficiency
my $MAX_EFFICIENCY_REDUCTION_PERCENTAGE  = 0.15; # Max % a profile can be reduced by efficiency logic
my $MIN_P50_DENOMINATOR_FOR_VOLATILITY = 0.1;    # Min P50 value to avoid division by zero in volatility calc
my $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC = 0.75; # Base, SMT-dependent adjustments in calc sub

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80; # Reduction factor for additive CPU if VM is in a non-default pool

my $LOG_FILE_PATH = "/tmp/nfit-profile.log"; # Default log file path

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak"; # Standardized name for the peak metric column in output

# --- Argument Parsing ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;                     # For nfit's -r (round to nearest)
my $roundup_arg;                   # For nfit's -u (round up)
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS; # Global default for nfit-profile itself
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;  # Global default for nfit-profile itself
my $match_runq_perc_to_profile = 0; # NEW: Flag to enable matching RunQ percentile to profile's PhysC percentile
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit"; # Default path to nfit script
my $nfit_enable_windowed_decay = 0;        # Flag to instruct nfit to use its internal decay
my $nfit_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT;
my $nfit_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT;
my $nfit_decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT;
my $nfit_analysis_reference_date_str;
my $nfit_runq_avg_method_str = $DEFAULT_NFIT_RUNQ_AVG_METHOD; # 'none', 'sma', 'ema' for nfit's RunQ processing

GetOptions(
    'physc-data|pc=s'         => \$physc_data_file,
    'runq-data|rq=s'          => \$runq_data_file_arg,
    'config=s'                => \$vm_config_file_arg,
    'profiles-config=s'       => \$profiles_config_file_arg,
    'startdate|s=s'           => \$start_date_str,
    'vm|lpar=s'               => \$target_vm_name,
    'round|r:f'               => \$round_arg,
    'roundup|u:f'             => \$roundup_arg,
    'default-smt|smt=i'       => \$default_smt_arg,
    'runq-norm-percentiles=s' => \$runq_norm_perc_list_str,    # Global default list for NormRunQ
    'runq-abs-percentiles=s'  => \$runq_abs_perc_list_str,     # Global default list for AbsRunQ
    'match-runq-perc-to-profile' => \$match_runq_perc_to_profile, # NEW FLAG
    'help|h'                  => \$help,
    'nfit-path=s'             => \$nfit_script_path,
    'version|v'               => \$show_version,
    'nfit-enable-windowed-decay'     => \$nfit_enable_windowed_decay,
    'nfit-process-window-unit=s'     => \$nfit_window_unit_str,
    'nfit-process-window-size=i'     => \$nfit_window_size_val,
    'nfit-decay-half-life-days=i'    => \$nfit_decay_half_life_days_val,
    'nfit-analysis-reference-date=s' => \$nfit_analysis_reference_date_str,
    'nfit-runq-avg-method=s'         => \$nfit_runq_avg_method_str,
) or die usage_wrapper();

# --- Validation ---
my $nfit_ver = "N/A"; # Store nfit version
if ($show_version)
{
    print STDERR "nfit-profile version $SCRIPT_VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver_output = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver) = ($nfit_ver_output =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        if (defined $parsed_nfit_ver)
        {
            $nfit_ver = $parsed_nfit_ver;
            print STDERR "Uses nfit version: $nfit_ver\n";
            # Check nfit version compatibility for certain features
            my $required_nfit_ver_for_windowing = "2.27.0";
            my $required_nfit_ver_for_runq_avg_and_decay = "2.28.0.4";

            if ($nfit_enable_windowed_decay && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_windowing))
            {
                print STDERR "Warning: --nfit-enable-windowed-decay requires nfit version $required_nfit_ver_for_windowing or higher. Your nfit version ($nfit_ver) may not support this.\n";
            }
            if (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none' && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_runq_avg_and_decay))
            {
                 print STDERR "Warning: --nfit-runq-avg-method (sma/ema) may require nfit features from version $required_nfit_ver_for_runq_avg_and_decay or higher. Your nfit version ($nfit_ver) behavior might differ for RunQ processing, especially if --runq-decay is intended.\n";
            }
        }
        else
        {
            print STDERR "Could not determine nfit version from output: $nfit_ver_output\n";
            if ($nfit_enable_windowed_decay || (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none'))
            {
                print STDERR "Warning: Advanced nfit features are enabled but nfit version cannot be verified.\n";
            }
        }
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}

if ($help || !$physc_data_file)
{
    print STDERR usage_wrapper();
    exit 0;
}
if (! -f $physc_data_file)
{
    die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n";
}
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg)
{
    die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n";
}
if ($default_smt_arg <= 0)
{
    die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n";
}
if (! -x $nfit_script_path)
{
    die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n";
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}

# Validations for nfit's windowed decay options, if enabled by nfit-profile
if ($nfit_enable_windowed_decay)
{
    if ($nfit_window_unit_str ne "days" && $nfit_window_unit_str ne "weeks")
    {
        die "Error: --nfit-process-window-unit must be 'days' or 'weeks'.\n";
    }
    if ($nfit_window_size_val < 1)
    {
        die "Error: --nfit-process-window-size must be at least 1.\n";
    }
    if ($nfit_decay_half_life_days_val < 1)
    {
        die "Error: --nfit-decay-half-life-days must be at least 1.\n";
    }
    if (defined $nfit_analysis_reference_date_str && $nfit_analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
    {
        die "Error: Invalid --nfit-analysis-reference-date format. Use YYYY-MM-DD.\n";
    }
    print STDERR "nfit's internal windowed decay processing is enabled via nfit-profile.\n";
}

# Validate nfit's RunQ averaging method, if specified
if (defined $nfit_runq_avg_method_str)
{
    $nfit_runq_avg_method_str = lc($nfit_runq_avg_method_str);
    unless ($nfit_runq_avg_method_str eq 'none' || $nfit_runq_avg_method_str eq 'sma' || $nfit_runq_avg_method_str eq 'ema')
    {
        die "Error: --nfit-runq-avg-method must be 'none', 'sma', or 'ema'. Got '$nfit_runq_avg_method_str'.\n";
    }
    print STDERR "Instructing nfit to use RunQ averaging method: $nfit_runq_avg_method_str.\n";
}

# --- Open Log File ---
my $LOG_FH = IO::File->new($LOG_FILE_PATH, '>')
    or warn "Error: Cannot open rationale log file '$LOG_FILE_PATH' for writing: $!. Rationale logging will be skipped.\n";

if ($LOG_FH)
{
    $LOG_FH->autoflush(1); # Ensure immediate writing to log
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nFit Profile Rationale Log\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nfit-profile.pl Run Started: $PROFILE_SCRIPT_START_TIME_STR\n";
    print {$LOG_FH} "nfit-profile.pl Version  : $SCRIPT_VERSION\n";

    # Log nfit version used (attempt again if not already fetched by --version flag)
    if ($nfit_ver eq "N/A" && -x $nfit_script_path)
    {
        my $nfit_ver_output_log = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver_log) = ($nfit_ver_output_log =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        $nfit_ver = $parsed_nfit_ver_log // "Unknown (parse failed)";
    }
    print {$LOG_FH} "nfit.pl Version Used     : $nfit_ver\n";

    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Invocation:\n";
    my @quoted_original_argv_log = map { $_ =~ /\s/ ? qq/"$_"/ : $_ } @original_argv;
    print {$LOG_FH} "  $0 " . join(" ", @quoted_original_argv_log) . "\n";
    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Key Global Settings:\n";
    print {$LOG_FH} "  - PhysC Data File          : $physc_data_file\n";
    print {$LOG_FH} "  - RunQ Data File           : " . ($runq_data_file_arg // "Not Provided") . "\n";
    print {$LOG_FH} "  - Match RunQ Perc to Profile : " . ($match_runq_perc_to_profile ? "Enabled" : "Disabled (Using AbsRunQ_P90 default for additive logic)") . "\n"; # Log new option
}

# --- Load Profile Definitions ---
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else # Attempt to find default profiles config
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE"; # Try in script's root
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
if ($LOG_FH) { print {$LOG_FH} "  - Profiles Config File     : $profiles_config_path_to_load\n"; }
@profiles = load_profile_definitions($profiles_config_path_to_load);
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}

# This profile's CPU value is used for MaxCPU pressure checks,
# and its RunQ metrics will now be used for global RunQ pressure hints.
my $MANDATORY_PEAK_PROFILE_FOR_HINT = "P-99W1";

# --- Ensure the Mandatory P-99W1 Profile is Defined ---
# This check occurs after profiles are loaded.
my $mandatory_profile_is_present = 0;
foreach my $profile_entry (@profiles)
{
    if (defined $profile_entry->{name} && $profile_entry->{name} eq $MANDATORY_PEAK_PROFILE_FOR_HINT)
    {
        $mandatory_profile_is_present = 1;
        last;
    }
}

unless ($mandatory_profile_is_present)
{
    die "ERROR: Mandatory profile \"$MANDATORY_PEAK_PROFILE_FOR_HINT\" is not defined in the profiles configuration file: '$profiles_config_path_to_load'.\n" .
        "       This profile is essential for core pressure detection logic in nfit-profile.\n" .
        "       Please add a profile named \"$MANDATORY_PEAK_PROFILE_FOR_HINT\" to your profiles configuration.\n";
}

print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";

# --- Locate and Load VM Configuration Data ---
# This data provides SMT, MaxCPU, Entitlement, etc., per VM.
my $vm_config_file_path = undef;
my $vm_config_found = 0;
my %vm_config_data;         # Stores parsed VM config: $vm_config_data{hostname}{key} = value
my %vm_config_col_idx;      # Maps column names (lowercase) to their index in the CSV
my $vm_config_header_count = 0; # Number of columns in VM config header

if (defined $vm_config_file_arg) # User specified a VM config file
{
    if (-f $vm_config_file_arg)
    {
        $vm_config_file_path = $vm_config_file_arg;
        $vm_config_found = 1;
        print STDERR "Using specified VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n";
    }
}
else # No VM config file specified, try default locations
{
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE";  # Default path: script_dir/etc/
    my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE"; # Alternative path: script_dir/
    if (-f $dp_etc)
    {
        $vm_config_file_path = $dp_etc;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    elsif (-f $dp_root)
    {
        $vm_config_file_path = $dp_root;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n";
    }
}
if ($LOG_FH) { print {$LOG_FH} "  - VM Config File           : " . ($vm_config_file_path // "Not Provided/Default Attempted") . "\n"; }

if ($vm_config_found)
{
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>; # Read header line
    unless (defined $hdr)
    {
        die "Error: Could not read header from VM config '$vm_config_file_path'\n";
    }
    chomp $hdr;
    $hdr =~ s/\r$//;        # Remove CR if present (Windows line endings)
    $hdr =~ s/^\x{FEFF}//;  # Remove BOM if present (UTF-8 Byte Order Mark)
    my @rhdrs = split /,/, $hdr;
    $vm_config_header_count = scalar @rhdrs;
    my %hmap; # Map lowercase header name to index
    for my $i (0 .. $#rhdrs)
    {
        my $cn = $rhdrs[$i];
        $cn =~ s/^\s*"?|"?\s*$//g; # Trim spaces and quotes from column name
        if ($cn ne '')
        {
            $hmap{lc($cn)} = $i; # Store lowercase column name
        }
    }

    # Check for required columns
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'}; # Check if SMT column exists
    unless (exists $hmap{'maxcpu'})
    {
        warn "Warning: 'maxcpu' column not found in VM config. Final MaxCPU capping logic will be affected.\n";
    }
    if ($has_smt_col)
    {
        print STDERR "Found 'SMT' column in VM configuration file.\n";
    }
    else
    {
        print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n";
    }

    foreach my $rc (@req_cols)
    {
        unless (exists $hmap{$rc})
        {
            die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n";
        }
        $vm_config_col_idx{$rc} = $hmap{$rc};
    }
    if ($has_smt_col) # If SMT column exists, store its index
    {
        $vm_config_col_idx{'smt'} = $hmap{'smt'};
    }

    # Read data lines from VM config
    while (my $ln = <$cfg_fh>)
    {
        chomp $ln;
        $ln =~ s/\r$//;
        next if $ln =~ /^\s*$/; # Skip empty lines

        # Attempt to parse CSV with quoted fields (handles commas within quotes)
        my @rvals = ($ln =~ /"([^"]*)"/g);
        if (scalar @rvals != $vm_config_header_count)
        { # Fallback to simple comma split if quote parsing fails or count mismatches
            @rvals = split /,/, $ln;
            if (scalar @rvals != $vm_config_header_count)
            {
                warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n";
                next;
            }
            # Trim whitespace for values from simple split
            $_ =~ s/^\s+|\s+$//g for @rvals;
        }
        # Else, if quote parsing worked, values in @rvals are already unquoted and trimmed by regex.

        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ]; # Get hostname
        if (defined $hn && $hn ne '')
        {
            my $smt_v = $default_smt_arg; # Default SMT value
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '')
            {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/) # Extract trailing digits for SMT value (e.g., "SMT4" -> 4)
                {
                    $smt_v = $1;
                    if ($smt_v <= 0) # Validate SMT
                    {
                        warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                        $smt_v = $default_smt_arg;
                    }
                }
                else
                {
                    warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                }
            }

            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            # Validate MaxCPU value
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0)
            {
                $max_cpu_val = 0; # Default to 0 if invalid, meaning no effective MaxCPU cap from config
            }

            # Store parsed VM config data
            $vm_config_data{$hn} = {
                serial      => $rvals[$vm_config_col_idx{'serial'}],
                systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name   => $rvals[$vm_config_col_idx{'procpool_name'}],
                pool_id     => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}],
                maxcpu      => ($max_cpu_val + 0), # Store as number
                smt         => $smt_v,
            };
        }
        else # Hostname missing or empty
        {
            warn "Warning: Missing hostname on VM config line $. Skipping.\n";
        }
    }
    close $cfg_fh;
    print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
}
else # VM config file not found or not specified
{
     print STDERR "Warning: VM configuration file not loaded. MaxCPU capping logic will be affected, and SMT will use default.\n";
}

# --- Construct Common Flags for nfit ---
# These flags are common to ALL nfit runs initiated by nfit-profile.
# Note: RunQ percentile flags (--runq-norm-perc, --runq-abs-perc) are now handled PER PROFILE run.
my $common_nfit_flags_base = "-k --physc-data \"$physc_data_file\""; # -k for terse output from nfit
if (defined $runq_data_file_arg)
{
    $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
    # Global nfit-profile CLI --runq-norm-percentiles and --runq-abs-percentiles are defaults,
    # but the actual lists passed to nfit will be constructed per profile.
    if (defined $nfit_runq_avg_method_str) # Pass nfit's RunQ averaging method if specified
    {
        $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
    }
}
if (defined $start_date_str) # Global start date for all nfit runs
{
    $common_nfit_flags_base .= " -s $start_date_str";
}

# Common rounding flags (passed to nfit for its output formatting)
my $rounding_flags_for_nfit = ""; # These are applied by nfit itself
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/) # Check if round_arg has a value (e.g. -r=0.1)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/) # Check if roundup_arg has a value (e.g. -u=0.1)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit; # Add rounding to common flags if specified

# Common nfit windowing/decay flags (if nfit-profile is instructing nfit to use its internal decay)
my $nfit_windowing_decay_flags = "";
if ($nfit_enable_windowed_decay)
{
    $nfit_windowing_decay_flags .= " --enable-windowed-decay";
    $nfit_windowing_decay_flags .= " --process-window-unit \"$nfit_window_unit_str\"";
    $nfit_windowing_decay_flags .= " --process-window-size $nfit_window_size_val";
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
$common_nfit_flags_base .= $nfit_windowing_decay_flags; # Add windowing/decay to common flags if enabled

# Log common flags (updated to reflect that runq percentiles are now per-profile)
if ($LOG_FH)
{
    print {$LOG_FH} "  - nfit Common Base Flags   : $common_nfit_flags_base (RunQ percentiles determined per profile)\n";
    print {$LOG_FH} "  - nfit Windowed Decay Opts : " . ($nfit_windowing_decay_flags ne "" ? $nfit_windowing_decay_flags : "Not Enabled") . "\n";
    print {$LOG_FH} "  - nfit RunQ Avg Method     : $nfit_runq_avg_method_str\n";
    print {$LOG_FH} "  - Default SMT for Profile  : $default_smt_arg\n";
    print {$LOG_FH} "======================================================================\n\n";
    print {$LOG_FH} "===== Per-VM / Per-Profile RunQ Adjustment Details =====\n\n";
}

# --- Main Logic: Run nfit Profiles ---
my %results_table; # Stores PhysC values from nfit for each profile: $results_table{vm_name}{profile_name}
my @vm_order;      # To maintain CSV output order consistent with first nfit run that reports VMs
my %vm_seen;       # Tracks VMs seen to populate @vm_order correctly
my %primary_runq_metrics_captured_for_vm; # Tracks if global P50/P90 RunQ metrics captured for hints
my %source_profile_for_global_runq; # Which profile's output sourced the global RunQ P50/P90 for hints
my %per_profile_runq_metrics; # Stores ALL RunQ metrics (e.g. AbsRunQ_P80, AbsRunQ_P98) from EACH profile's nfit run
                              # Structure: $per_profile_runq_metrics{vm_name}{profile_name}{runq_metric_key}
my %parsed_growth_adj_values; # Stores GrowthAdj from nfit output
my $FLOAT_EPSILON          = 1e-9;

print STDERR "nfit-profile version $SCRIPT_VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles) # Iterate through each profile defined in nfit.profiles.cfg
{
    my $profile_name = $profile->{name};
    my $profile_runq_behavior = $profile->{runq_behavior} // 'default'; # Default RunQ modifier behavior if not in config

    # Determine Profile's PhysC Percentile (e.g., value X from -p X in profile's flags)
    # This is used for:
    # 1. Extracting the correct PhysC metric from nfit's output (e.g., P98=value).
    # 2. Optionally matching the AbsRunQ percentile if --match-runq-perc-to-profile is set.
    my $profile_physc_perc_val_num;
    if ($profile->{flags} =~ /(?:-p|--percentile)\s+([0-9.]+)/)
    {
        $profile_physc_perc_val_num = $1 + 0; # Store as number
    }

    # --- Construct nfit command with dynamically determined RunQ percentile flags for THIS profile run ---
    my $profile_specific_flags_for_nfit_run = $profile->{flags}; # Start with flags from profile config
    my $nfit_runq_related_flags_for_command = ""; # This will hold the final --runq-...-perc flags for this nfit call

    if (defined $runq_data_file_arg) # Only add/modify RunQ flags if RunQ data is globally available
    {
        # 1. Handle Normalised RunQ Percentiles for this nfit call
        #    nfit-profile needs NormRunQ_P50 and NormRunQ_P90 for its heuristics.
        my @norm_percs_to_explicitly_ensure = (50, 90);
        
        my @profile_norm_perc_parts; # Store parts of --runq-norm-perc from profile's nfit_flags
        my $flags_copy_for_norm_parsing = $profile->{flags}; # Parse from original profile flags
        while ($flags_copy_for_norm_parsing =~ /--runq-norm-perc\s+(?:\"([^\"]*)\"|\'([^\']*)\'|([^\s]+))/g)
        {
            my $list_str = $1 // $2 // $3; # $1 for "value", $2 for 'value', $3 for value (unquoted)
            push @profile_norm_perc_parts, split(/,\s*/, $list_str);
        }
        my %seen_norm_config_parts; # De-duplicate parts parsed from config
        @profile_norm_perc_parts = grep { $_ ne '' && !$seen_norm_config_parts{$_}++ } @profile_norm_perc_parts;
        my $norm_perc_list_from_profile_config = join(",", @profile_norm_perc_parts);

        # If profile config had no --runq-norm-perc, use the global nfit-profile.pl default from CLI args
        if ($norm_perc_list_from_profile_config eq "")
        {
            $norm_perc_list_from_profile_config = $runq_norm_perc_list_str;
        }
        
        # Collate what profile/global default specified, with what we explicitly need
        my @final_norm_percs_for_nfit_call = parse_and_collate_percentiles(
            $norm_perc_list_from_profile_config, 
            @norm_percs_to_explicitly_ensure
        );
        
        $profile_specific_flags_for_nfit_run =~ s/--runq-norm-perc\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s]+)//g; # Remove all original occurrences
        if (@final_norm_percs_for_nfit_call)
        {
            $nfit_runq_related_flags_for_command .= " --runq-norm-perc \"" . join(",", @final_norm_percs_for_nfit_call) . "\"";
        }

        # 2. Handle Absolute RunQ Percentiles for this nfit call
        #    nfit-profile needs AbsRunQ_P90 as a default/fallback.
        #    If matching, it also needs AbsRunQ_PX (where X is profile's PhysC percentile).
        my @abs_percs_to_explicitly_ensure = (90); # CRITICAL: Always ensure P90 for AbsRunQ
        if ($match_runq_perc_to_profile && defined $profile_physc_perc_val_num)
        {
            push @abs_percs_to_explicitly_ensure, $profile_physc_perc_val_num; # Add profile's PhysC perc if matching
        }

        my @profile_abs_perc_parts; # Store parts of --runq-abs-perc from profile's nfit_flags
        my $flags_copy_for_abs_parsing = $profile->{flags}; # Parse from original profile flags
        while ($flags_copy_for_abs_parsing =~ /--runq-abs-perc\s+(?:\"([^\"]*)\"|\'([^\']*)\'|([^\s]+))/g)
        {
            my $list_str = $1 // $2 // $3;
            push @profile_abs_perc_parts, split(/,\s*/, $list_str);
        }
        my %seen_abs_config_parts; # De-duplicate parts parsed from config
        @profile_abs_perc_parts = grep { $_ ne '' && !$seen_abs_config_parts{$_}++ } @profile_abs_perc_parts;
        my $abs_perc_list_from_profile_config = join(",", @profile_abs_perc_parts);

        # If profile config had no --runq-abs-perc, use the global nfit-profile.pl default from CLI args
        if ($abs_perc_list_from_profile_config eq "")
        {
            $abs_perc_list_from_profile_config = $runq_abs_perc_list_str;
        }

        # Collate what profile/global default specified, with what we explicitly need
        my @final_abs_percs_for_nfit_call = parse_and_collate_percentiles(
            $abs_perc_list_from_profile_config, 
            @abs_percs_to_explicitly_ensure
        );

        $profile_specific_flags_for_nfit_run =~ s/--runq-abs-perc\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s]+)//g; # Remove all original occurrences
        if (@final_abs_percs_for_nfit_call)
        {
            $nfit_runq_related_flags_for_command .= " --runq-abs-perc \"" . join(",", @final_abs_percs_for_nfit_call) . "\"";
        }
    } # End if (defined $runq_data_file_arg)
    
    # $common_nfit_flags_base already had global runq perc lists removed earlier during its construction.
    # So, no need to remove them again here from $common_nfit_flags_base.

    print STDERR "Running profile: $profile_name ($profile_specific_flags_for_nfit_run $nfit_runq_related_flags_for_command";
    print STDERR " ; RunQBehavior: $profile_runq_behavior" if $profile_runq_behavior ne 'default';
    print STDERR ")...\n";

    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg"; # Default SMT for this nfit call
    my $nfit_vm_flag_for_current_run = ""; # VM filter for this nfit call (if global --vm is set)

    if (defined $target_vm_name) # If a global VM target is set for nfit-profile
    {
        $nfit_vm_flag_for_current_run = " -vm \"$target_vm_name\"";
        # Override SMT for nfit call if VM config has a specific SMT for the target VM
        if ($vm_config_found && exists $vm_config_data{$target_vm_name} && defined $vm_config_data{$target_vm_name}{'smt'})
        {
            $nfit_smt_flag_for_current_run = "--smt " . $vm_config_data{$target_vm_name}{'smt'};
        }
    }
    
    # Assemble the final command for nfit.pl for this specific profile
    # $profile_specific_flags_for_nfit_run has had its original runq percentile flags removed.
    # $nfit_runq_related_flags_for_command contains the new, consolidated runq percentile flags.
    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags_for_nfit_run $nfit_runq_related_flags_for_command";
    
    # For debugging the exact command being run when troubleshooting:
    # print STDERR "DEBUG: nfit command for profile '$profile_name': $command\n";

    my $output = `$command`;      # Execute nfit.pl
    my $exit_status = $? >> 8; # Get nfit's exit status

    if ($exit_status != 0) # If nfit.pl failed
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Command was: $command. Output: $output. Skip.\n";
        if ($LOG_FH)
        {
             print {$LOG_FH} "ERROR: nfit.pl execution FAILED for profile '$profile_name' on VM(s) '". ($target_vm_name // "All") ."'.\n";
             print {$LOG_FH} "  Command: $command\n";
             print {$LOG_FH} "  Exit Status: $exit_status\n";
             my $short_output = substr($output, 0, 1000) . (length($output) > 1000 ? "..." : ""); # Log first 1KB of output
             print {$LOG_FH} "  Output (first 1000 chars): $short_output\n";
        }
        next; # Skip to the next profile in the loop
    }

    # Parse nfit output lines
    my @output_lines = split /\n/, $output;
    foreach my $line (@output_lines)
    {
        chomp $line;
        # Example nfit output line: VM_NAME: P95=1.23 Peak=2.34 NormRunQ_P50=0.1 NormRunQ_P90=0.5 AbsRunQ_P90=10
        if ($line =~ /^(.+?):\s*(.*)$/) # Regex to capture VM name and its metrics string
        {
            my $vm_name_from_nfit = $1;
            my $metrics_str = $2;

            unless ($vm_seen{$vm_name_from_nfit}++) # If first time seeing this VM this run
            {
                push @vm_order, $vm_name_from_nfit; # Add to ordered list for consistent CSV output
            }
            
            # Initialize storage for this VM's primary RunQ metrics (for global hints) if not already done
            $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit} //= {
                'NormRunQ_P50' => 0, # Flag: 0 = not captured, 1 = captured
                'NormRunQ_P90' => 0,
                'AbsRunQ_P90'  => 0, # This specifically refers to the global/hint AbsRunQ_P90
            };

            # --- Extract the profile's main PhysC percentile value (e.g., P98 value for a -p 98 profile) ---
            # The profile's -p flag (e.g., -p 98) determines the primary metric nfit reports (e.g., P98=value).
            # $profile_physc_perc_val_num was determined at the start of this profile's loop.
            if (defined $profile_physc_perc_val_num)
            {
                my $expected_metric_key_base = sprintf("%.2f", $profile_physc_perc_val_num); # Format like "98.00"
                $expected_metric_key_base =~ s/\.?0+$//;                                     # Clean to "98"
                $expected_metric_key_base = "0" if $expected_metric_key_base eq "" && abs($profile_physc_perc_val_num - 0) < 0.001;
                my $expected_metric_key = "P$expected_metric_key_base"; # e.g., "P98"
                
                if ($metrics_str =~ /\Q$expected_metric_key\E=([0-9.NA\/ -]+?)(?:\s+|$)/) # \Q \E for literal match
                {
                    my $p_value_val = $1;
                    $p_value_val =~ s/^\s+|\s+$//g; # Trim spaces
                    $results_table{$vm_name_from_nfit}{$profile_name} = $p_value_val; # Store this PhysC value for the profile
                }
            }

            # --- Extract Peak PhysC value if nfit calculated it ---
            if ($metrics_str =~ /Peak=([0-9.NA\/ -]+?)(?:\s+|$)/)
            {
                my $peak_value = $1;
                $peak_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name_from_nfit}{$PEAK_PROFILE_NAME} = $peak_value; # Store under generic "Peak" name
            }

            # --- Extract ALL RunQ metrics reported by nfit for this profile run ---
            # Store them in %per_profile_runq_metrics. This allows access to AbsRunQ_P80, AbsRunQ_P98 etc. later.
            # Also, capture NormRunQ_P50, NormRunQ_P90, AbsRunQ_P90 for global hints ONCE per VM.
            my %first_capture_target_keys_for_hinting = ( # Metrics needed for generate_sizing_hint
                'NormRunQ_P50' => 1,
                'NormRunQ_P90' => 1,
                'AbsRunQ_P90'  => 1, # For the global hint, we still use P90 from the first available source
            );

            # Regex to find all RunQ metrics in the nfit output line
            while ($metrics_str =~ /(NormRunQ_P\d+\.?\d*|AbsRunQ_P\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/g)
            {
                my ($rq_metric_name, $rq_value) = ($1, $2);
                $rq_value =~ s/^\s+|\s+$//g; # Trim spaces

                # Store ALL runq metrics from this profile's nfit run into the per-profile hash
                $per_profile_runq_metrics{$vm_name_from_nfit}{$profile_name}{$rq_metric_name} = $rq_value;

                # For global hint generation, capture specific RunQ metrics only once per VM,
                # typically from the first profile that provides them.
                if (exists $first_capture_target_keys_for_hinting{$rq_metric_name})
                {
                    if (!$primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name})
                    {
                        # Store in results_table for easy access by generate_sizing_hint
                        $results_table{$vm_name_from_nfit}{$rq_metric_name} = $rq_value;
                        $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name} = 1; # Mark as captured
                        $source_profile_for_global_runq{$vm_name_from_nfit} //= $profile_name; # Note which profile sourced it
                    }
                }
            }

            # --- Extract GrowthAdj value for this VM and Profile ---
            my $current_growth_adj_val_from_nfit = "0.0000"; 
            if ($metrics_str =~ /GrowthAdj=([0-9.NA\/ -]+?)(?:\s+|$)/)
            {
                $current_growth_adj_val_from_nfit = $1;
                $current_growth_adj_val_from_nfit =~ s/^\s+|\s+$//g; # Trim spaces
            }
            $parsed_growth_adj_values{$vm_name_from_nfit}{$profile_name} = $current_growth_adj_val_from_nfit;
            # --- END NEW GrowthAdj Extraction ---
        }
        elsif ($line ne '') # Non-empty line that doesn't match VM: metrics format
        {
            warn "Warning: Could not parse VM name from nfit output line for profile '$profile_name': $line\n";
        }
    } # End foreach output line from nfit
} # End foreach profile
print STDERR "Finished nfit profile runs. Generating CSV output and rationale log...\n";

# --- Generate CSV Output ---
my @output_header_cols_csv;
# Define the order of columns for the CSV output
@output_header_cols_csv = (
    "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT",
    "Serial", "SystemType", "Pool Name", "Pool ID", $PEAK_PROFILE_NAME
);
# Add profile names as column headers (these will contain the RunQ-modified PhysC values)
push @output_header_cols_csv, map { $_->{name} } @profiles;
# Add entitlement and formula placeholder columns
push @output_header_cols_csv, ("Current - ENT", "NFIT - ENT", "NETT", "NETT%");
print STDOUT join(",", map { quote_csv($_) } @output_header_cols_csv) . "\n"; # Print CSV header

my $excel_row_num_counter = 1; # Excel rows are 1-based; header is row 1, so first data row is 2.

# Iterate through VMs in the order they were first seen to maintain consistency
foreach my $vm_name (@vm_order)
{
    $excel_row_num_counter++; # Increment for current data row number in Excel sheet.

    my @data_row_csv; # Holds data for the current VM's CSV row
    my $cfg_csv = $vm_config_data{$vm_name}; # VM's config data from config-all.csv (if loaded)
    
    # Determine SMT and MaxCPU to use for this VM's calculations/reporting
    my $smt_used_for_vm_csv = (defined $cfg_csv && defined $cfg_csv->{smt}) ? $cfg_csv->{smt} : $default_smt_arg;
    my $max_cpu_for_vm_csv  = (defined $cfg_csv && defined $cfg_csv->{maxcpu} && $cfg_csv->{maxcpu} > 0) ? $cfg_csv->{maxcpu} : 0;
    
    # --- Generate Sizing Hint ---
    my $hint_norm_runq_p90_str = $results_table{$vm_name}{'NormRunQ_P90'} // "N/A";
    my $hint_abs_runq_p90_str  = $results_table{$vm_name}{'AbsRunQ_P90'}  // "N/A";

    my ($hint_type_tier_csv, $hint_pattern_shape_csv, $hint_pressure_bool_csv, $pressure_detail_str_csv, $global_pressure_log_details_str, $p99w1_vm_has_abs_runq_pressure, $p99w1_vm_has_norm_runq_pressure) =
        generate_sizing_hint(
            'results_ref'              => \%results_table, 
            'vm'                       => $vm_name,
            'config_ref'               => $cfg_csv,        
            'max_cpu_for_vm_numeric'        => $max_cpu_for_vm_csv,
            'smt_used_for_vm_numeric'       => $smt_used_for_vm_csv,
            'per_profile_runq_metrics_ref'  => \%per_profile_runq_metrics # Pass the global hash
        );
    my $pressure_bool_str_csv = $hint_pressure_bool_csv ? "True" : "False";

    # --- Log Global Pressure Assessment Details for Sizing Hint ---
    if ($LOG_FH)
    {
        print {$LOG_FH} "----------------------------------------------------------------------\n";
        print {$LOG_FH} "Global Sizing Hint Pressure Assessment (VM: $vm_name)\n";
        # The $global_pressure_log_details_str already starts with "Section G..."
        print {$LOG_FH} $global_pressure_log_details_str . "\n";
        # No need for an extra trailing line of dashes if the string itself is well-formed.
        # The next major log section will be the per-profile ones.
    }
    
    # Add VM, TIER, Hint, Pattern etc. columns to CSV row
    # As per user feedback: TIER (column B) is user-populated/empty from script,
    # Hint (column C) gets the $hint_type_tier_csv (e.g. "G3").
    push @data_row_csv, $vm_name,                   # VM (Column A)
                        "",                         # TIER (Column B, empty from script as per user feedback)
                        $hint_type_tier_csv,        # Hint (Column C, e.g., "G3")
                        $hint_pattern_shape_csv,    # Pattern (Column D)
                        $pressure_bool_str_csv,     # Pressure
                        $pressure_detail_str_csv,   # PressureDetail
                        $smt_used_for_vm_csv;       # SMT

    # Add VM config details
    push @data_row_csv, (defined $cfg_csv ? $cfg_csv->{serial} : ""), 
                        (defined $cfg_csv ? $cfg_csv->{systemtype} : ""), 
                        (defined $cfg_csv ? $cfg_csv->{pool_name} : ""), 
                        (defined $cfg_csv ? $cfg_csv->{pool_id} : "");
    # Add Peak PhysC value
    push @data_row_csv, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // "");
    
    # --- Calculate and Add RunQ-Modified PhysC value for each profile column ---
    foreach my $profile_being_adjusted_ref (@profiles) 
    {
        my $profile_name_being_adjusted = $profile_being_adjusted_ref->{name};
        my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name_being_adjusted};
        my $adjusted_value_str = "N/A"; 
        my $current_profile_runq_behavior = $profile_being_adjusted_ref->{runq_behavior} // 'default';
        my $debug_info_for_log = { AbsRunQKeyUsed => 'AbsRunQ_P90 (default/key unknown)' };
        my $abs_runq_p_value_to_use_for_calc = "N/A";
        my $abs_runq_key_actually_used = "AbsRunQ_P90";
        my $current_profile_physc_perc_val_num;

        if ($profile_being_adjusted_ref->{flags} =~ /(?:-p|--percentile)\s+([0-9.]+)/) {
            $current_profile_physc_perc_val_num = $1 + 0;
        }

        if ($match_runq_perc_to_profile && defined $current_profile_physc_perc_val_num) {
            my $target_perc_label = sprintf("%.2f", $current_profile_physc_perc_val_num);
            $target_perc_label =~ s/\.?0+$//;
            $target_perc_label = "0" if $target_perc_label eq "" && abs($current_profile_physc_perc_val_num - 0) < 0.001;
            my $potential_key = "AbsRunQ_P" . $target_perc_label;

            if (exists $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{$potential_key}) {
                $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{$potential_key};
                $abs_runq_key_actually_used = $potential_key;
            } else {
                if ($LOG_FH) {
                    print {$LOG_FH} "WARNING VM '$vm_name', Profile '$profile_name_being_adjusted': Matched key '$potential_key' for AbsRunQ not found. Falling back to AbsRunQ_P90.\n";
                }
                if (exists $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"}) {
                    $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"};
                } else {
                     if ($LOG_FH) {
                         print {$LOG_FH} "WARNING VM '$vm_name', Profile '$profile_name_being_adjusted': Fallback AbsRunQ_P90 also not found.\n";
                     }
                }
            }
        } else {
            if (exists $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"}) {
                $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"};
            } else {
                 if ($LOG_FH) {
                     print {$LOG_FH} "INFO VM '$vm_name', Profile '$profile_name_being_adjusted': AbsRunQ_P90 not found (matching disabled or profile -p not determined).\n";
                 }
            }
        }
        $debug_info_for_log->{AbsRunQKeyUsed} = $abs_runq_key_actually_used;
        my $this_profile_norm_p50 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P50'} // "N/A";
        my $this_profile_norm_p90 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P90'} // "N/A";

        if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/) {
            my $raw_physc_profile_value = $raw_physc_profile_value_str + 0;
            my $is_non_default_pool = (defined $cfg_csv && defined $cfg_csv->{pool_name} && lc($cfg_csv->{pool_name}) ne 'defaultpool' && $cfg_csv->{pool_name} ne '');
            
            my ($runq_modified_physc_for_profile, $calc_debug_info_ref) = calculate_runq_modified_physc(
                $raw_physc_profile_value,
                $this_profile_norm_p50,
                $this_profile_norm_p90,
                $abs_runq_p_value_to_use_for_calc,
                $abs_runq_key_actually_used,
                $smt_used_for_vm_csv,
                (defined $cfg_csv ? $cfg_csv->{entitlement} : "0"),
                $max_cpu_for_vm_csv,
                $is_non_default_pool,
                $current_profile_runq_behavior,
                $p99w1_vm_has_abs_runq_pressure,
                $p99w1_vm_has_norm_runq_pressure
            );
            %$debug_info_for_log = ( %$debug_info_for_log, %$calc_debug_info_ref );
            $debug_info_for_log->{AbsRunQKeyUsed} = $abs_runq_key_actually_used;
            my $effective_nfit_flags_for_dp_calc = $rounding_flags_for_nfit . " " . $profile_being_adjusted_ref->{flags};
            my $current_profile_output_dp = get_nfit_output_dp_from_flags($effective_nfit_flags_for_dp_calc);
            my $current_sprintf_format = "%." . $current_profile_output_dp . "f";
            $adjusted_value_str = sprintf($current_sprintf_format, $runq_modified_physc_for_profile);
        } else {
            $adjusted_value_str = $raw_physc_profile_value_str // "N/A";
            $debug_info_for_log->{ReasonForNoModification} = "Base PhysC for profile '$profile_name_being_adjusted' was N/A or not numeric.";
            $debug_info_for_log->{FinalAdjustedPhysC} = $adjusted_value_str;
        }
        push @data_row_csv, $adjusted_value_str;
        my $nfit_growth_adj_for_log = $parsed_growth_adj_values{$vm_name}{$profile_name_being_adjusted} // "0.0000 (not parsed)";

        if ($LOG_FH) {
            log_profile_rationale(
                $LOG_FH, $vm_name,
                $profile_name_being_adjusted,
                $raw_physc_profile_value_str,
                $profile_name_being_adjusted,
                $abs_runq_p_value_to_use_for_calc,
                $this_profile_norm_p50,
                $this_profile_norm_p90,
                $cfg_csv,
                $smt_used_for_vm_csv,
                $max_cpu_for_vm_csv,
                $current_profile_runq_behavior,
                $debug_info_for_log,
                $adjusted_value_str,
                $nfit_growth_adj_for_log
            );
        }
    } # End foreach profile_being_adjusted_ref
    
    # Add current entitlement and formula placeholders to CSV row
    my $current_ent_display_csv_out = (defined $cfg_csv && defined $cfg_csv->{entitlement}) ? $cfg_csv->{entitlement} : "";
    if ($current_ent_display_csv_out ne "" && $current_ent_display_csv_out =~ /^-?[0-9.]+$/) {
        $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out);
    }

    # Generate the dynamic Excel formula
    my $nfit_ent_formula_str = generate_nfit_ent_formula($excel_row_num_counter, scalar(@profiles));

    # 'Current_ENT' is the column after all profiles. Index = 12 + num_profiles + 1
    # 'NFIT_ENT_UserFormula' is the column after 'Current_ENT'. Index = 12 + num_profiles + 2
    my $idx_current_ent_col_this_row_actual = 12 + scalar(@profiles) + 1;
    my $idx_nfit_ent_formula_col_this_row_actual = 12 + scalar(@profiles) + 2;

    my $cell_letter_current_ent_actual = get_excel_col_name($idx_current_ent_col_this_row_actual);
    my $cell_letter_nfit_ent_formula_actual = get_excel_col_name($idx_nfit_ent_formula_col_this_row_actual);

    my $cell_ref_current_ent_actual = $cell_letter_current_ent_actual . $excel_row_num_counter;
    my $cell_ref_nfit_ent_formula_actual = $cell_letter_nfit_ent_formula_actual . $excel_row_num_counter;

    # Formula for NETT_UserFormula: =(Current_ENT_cell - NFIT_ENT_UserFormula_cell)
    my $nett_user_formula_str = sprintf("=(%s-%s)", $cell_ref_nfit_ent_formula_actual, $cell_ref_current_ent_actual);

    # Formula for NETT_Perc_UserFormula: =IFERROR((NFIT_ENT_UserFormula_cell - Current_ENT_cell) / Current_ENT_cell, "")
    # This shows change (NFIT - Current) as a percentage of Current.
    # Using "" for errors (e.g., division by zero if Current_ENT is 0).
    my $nett_perc_user_formula_str = sprintf("=IFERROR((%s-%s)/%s,\"\")", $cell_ref_nfit_ent_formula_actual, $cell_ref_current_ent_actual, $cell_ref_current_ent_actual);
    
    push @data_row_csv, $current_ent_display_csv_out, 
                        $nfit_ent_formula_str,          # NFIT_Formula
                        $nett_user_formula_str,         # NETT_UserFormula
                        $nett_perc_user_formula_str;    # NETT_Perc_UserFormula
    
    print STDOUT join(",", map { quote_csv($_) } @data_row_csv) . "\n"; # Print the complete CSV row for the VM
} # End foreach vm_name

# --- Collect unique serials that were part of the output ---
my %serials_in_output_map;
if (%vm_config_data && @vm_order) { # Ensure vm_config_data was loaded and there are VMs to process
    foreach my $vm_name_in_order (@vm_order) {
        if (exists $vm_config_data{$vm_name_in_order} && 
            defined $vm_config_data{$vm_name_in_order}{serial} && 
            $vm_config_data{$vm_name_in_order}{serial} ne '') {
            $serials_in_output_map{$vm_config_data{$vm_name_in_order}{serial}} = 1;
        }
    }
}
my @sorted_unique_serials_list = sort keys %serials_in_output_map;

# --- Add the CSV Footer with Summary Formulas ---
if (@vm_order) { # Only print footer if there was data
    print_csv_footer($excel_row_num_counter, $physc_data_file, scalar(@profiles), \@sorted_unique_serials_list);
}

# --- Script Footer ---
print STDERR "CSV output generated successfully.\n";
if ($nfit_enable_windowed_decay) # If nfit was instructed to use its internal decay
{
    print STDERR "Note: nfit was instructed to use internal windowed decay processing.\n";
}
if ($LOG_FH) # If logging was enabled and successful
{
    my $PROFILE_SCRIPT_END_TIME_EPOCH = time();
    my $PROFILE_SCRIPT_END_TIME_STR = localtime($PROFILE_SCRIPT_END_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");
    my $PROFILE_SCRIPT_DURATION = $PROFILE_SCRIPT_END_TIME_EPOCH - $PROFILE_SCRIPT_START_TIME_EPOCH;

    print {$LOG_FH} "\n----------------------------------------------------------------------\n";
    print {$LOG_FH} "nfit-profile.pl Run Ended  : $PROFILE_SCRIPT_END_TIME_STR\n";
    print {$LOG_FH} "Total Duration             : $PROFILE_SCRIPT_DURATION seconds\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "End of Rationale Log.\n";
    print {$LOG_FH} "======================================================================\n";
    close $LOG_FH;
    print STDERR "Rationale log written to: $LOG_FILE_PATH\n";
}

exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================

# --- get_excel_col_name ---
# Converts a 1-based column index to an Excel column name (e.g., 1 -> A, 27 -> AA).
sub get_excel_col_name {
    my ($idx) = @_;
    my $name = '';
    die "Column index must be positive" if (!defined $idx || $idx <= 0);
    while ($idx > 0) {
        my $mod = ($idx - 1) % 26;
        $name = chr(65 + $mod) . $name;
        $idx = int(($idx - $mod - 1) / 26); # Corrected logic for 1-based index progression
    }
    return $name;
}

# --- generate_nfit_ent_formula ---
# Generates the dynamic Excel formula for the "NFIT_ENT_UserFormula" column.
sub generate_nfit_ent_formula {
    my ($excel_row_num, $num_profiles) = @_;

    # First profile column is M (13th column).
    # Peak (L) is the 12th column. Profiles start after Peak.
    my $first_profile_excel_col_letter = get_excel_col_name(12 + 1);
    my $last_profile_excel_col_letter = get_excel_col_name(12 + $num_profiles);

    # The fixed array string for the MATCH function, as provided by the user.
    my $tier_match_array_str_for_formula = '{"P","G1","G2","G3","G4","O1","O2","O3","O4","B1","B2","B3","B4"}';

    # Dynamic column index for 'Current_ENT'.
    # 12 fixed leading columns (A-L) + num_profiles columns + 1 (for Current_ENT itself).
    my $entitlement_column_index = 12 + $num_profiles + 1;

    # Using "A:AZ" as the VLOOKUP range as requested for stability.
    my $vlookup_range_for_peer_ent = "A:AZ";

    my $formula_body = sprintf(
        'IF(ISNUMBER(SEARCH("PowerHA Standby", I%d)),VLOOKUP(VLOOKUP(A%d, PowerHA!A:B, 2, FALSE),%s, %d, FALSE) * $L$258, CEILING(INDEX(%s%d:%s%d, MATCH(B%d, %s, 0)), 0.05))',
        $excel_row_num,                            # For I%d (SystemType)
        $excel_row_num,                            # For A%d (VM Name for inner VLOOKUP)
        $vlookup_range_for_peer_ent,               # Range for outer VLOOKUP (e.g., A:AZ)
        $entitlement_column_index,                 # Dynamic column index for Current_ENT of the peer
        $first_profile_excel_col_letter, $excel_row_num, # For M%d (start of profile data range)
        $last_profile_excel_col_letter,  $excel_row_num, # For e.g. Y%d (end of profile data range)
        $excel_row_num,                            # For C%d (Hint column, containing the tier string like "G3")
        $tier_match_array_str_for_formula          # For {"P","G1",...} array
    );
    return "=" . $formula_body; # Excel formulas start with "="
}

# --- print_csv_footer ---
# Prints the summary footer section with labels and Excel formulas.
# Make sure Time::Piece is used if not already at the top of your script for strftime
# use Time::Piece; # Already in the full script you provided.
# use List::Util qw(sum min max); # Already in the full script.
# Ensure get_excel_col_name and quote_csv are defined elsewhere or within this sub's scope.
sub print_csv_footer {
    my ($last_data_row, $nmon_physc_file, $num_profiles, $sorted_unique_serials_list_ref) = @_;

    my @sorted_unique_serials = @$sorted_unique_serials_list_ref;
    my $count_of_unique_serials = scalar(@sorted_unique_serials);
    # If there are no unique serials, we still might want to print headers for the section,
    # and the UNIQUE formula (which will result in #CALC! or empty in Excel).
    # The loops for formulas should gracefully handle count = 0 for SUM ranges.
    # Or, ensure at least one iteration for the UNIQUE formula itself.
    my $loop_count_for_serials = ($count_of_unique_serials == 0) ? 1 : $count_of_unique_serials;


    # --- Calculate dynamic column letters based on script's output structure ---
    my $col_serial_letter = get_excel_col_name(8);       # Serial is 8th column (H)
    my $col_system_type_letter = get_excel_col_name(9);  # SystemType is 9th column (I)
    my $idx_current_ent = 12 + $num_profiles + 1;
    my $col_current_ent_letter = get_excel_col_name($idx_current_ent);
    my $idx_nfit_ent_user_formula = 12 + $num_profiles + 2;
    my $col_nfit_ent_user_formula_letter = get_excel_col_name($idx_nfit_ent_user_formula);

    # --- Get NMON physc data file modification timestamp ---
    my $file_timestamp_str = "N/A";
    if (defined $nmon_physc_file && -f $nmon_physc_file) {
        my $mtime_epoch = (stat($nmon_physc_file))[9];
        if (defined $mtime_epoch) { # Ensure mtime_epoch is defined
            $file_timestamp_str = localtime($mtime_epoch)->strftime("%Y-%m-%d %H:%M:%S");
        } else {
            $file_timestamp_str = "Timestamp N/A (stat fetch failed for $nmon_physc_file)";
        }
    } else {
        $file_timestamp_str = "Timestamp N/A (File not found or not provided)";
    }

    # --- Define starting row for footer elements ---
    print STDOUT "\n"; # Blank line after main data
    my $footer_start_row = $last_data_row + 2;

    my $row_data_age = $footer_start_row;
    my $row_timestamp = $footer_start_row + 1;
    my $row_as_is_nfit_labels = $footer_start_row + 3; # After another blank line
    my $row_ent_col_headers = $footer_start_row + 4;
    my $row_unique_serials_start = $footer_start_row + 5;

    my $empty = "";
    my @csv_row;

    # --- Row 1 of Footer: Data Age ---
    # Column letters for where the SUM, DELTA, PERC formulas for this row will RESIDE
    my $col_letter_data_age_sum_current_incl = get_excel_col_name(23); # W
    my $col_letter_data_age_sum_nfit_incl = get_excel_col_name(24);    # X
    my $col_letter_data_age_delta_incl = get_excel_col_name(25);       # Y
    my $col_letter_data_age_perc_incl = get_excel_col_name(26);        # Z

    my $formula_sum_current_ent_incl_sby = sprintf("=SUM(%s2:%s%d)", $col_current_ent_letter, $col_current_ent_letter, $last_data_row);
    my $formula_sum_nfit_ent_incl_sby = sprintf("=SUM(%s2:%s%d)", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row);
    my $formula_delta_incl_sby = sprintf("=%s%d-%s%d", $col_letter_data_age_sum_nfit_incl, $row_data_age, $col_letter_data_age_sum_current_incl, $row_data_age);
    my $formula_perc_incl_sby = sprintf("=IFERROR(%s%d/%s%d,\"\")", $col_letter_data_age_delta_incl, $row_data_age, $col_letter_data_age_sum_current_incl, $row_data_age);

    @csv_row = ($empty) x 22; # Pad up to the column before the first formula/label
    $csv_row[0] = "Data Age"; # Column A
    $csv_row[21] = "Incl. SBY"; # Column V
    push @csv_row, $formula_sum_current_ent_incl_sby, $formula_sum_nfit_ent_incl_sby, $formula_delta_incl_sby, $formula_perc_incl_sby;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Row 2 of Footer: Timestamp ---
    # Column letters for this row's SUM, DELTA, PERC formulas (can be same as above if aligned)
    my $col_letter_ts_sum_current_excl = $col_letter_data_age_sum_current_incl; # W
    my $col_letter_ts_sum_nfit_excl    = $col_letter_data_age_sum_nfit_incl;    # X
    my $col_letter_ts_delta_excl       = $col_letter_data_age_delta_incl;       # Y
    my $col_letter_ts_perc_excl        = $col_letter_data_age_perc_incl;        # Z

    my $formula_sum_current_ent_excl_sby = sprintf("=SUMIFS(%s\$2:%s\$%d, %s\$2:%s\$%d, \"<>*PowerHA Standby*\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row);
    my $formula_sum_nfit_ent_excl_sby = sprintf("=SUMIFS(%s\$2:%s\$%d, %s\$2:%s\$%d, \"<>*PowerHA Standby*\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row);
    my $formula_delta_excl_sby = sprintf("=%s%d-%s%d", $col_letter_ts_sum_nfit_excl, $row_timestamp, $col_letter_ts_sum_current_excl, $row_timestamp);
    my $formula_perc_excl_sby = sprintf("=IFERROR(%s%d/%s%d,\"\")", $col_letter_ts_delta_excl, $row_timestamp, $col_letter_ts_sum_current_excl, $row_timestamp);
    
    @csv_row = ($empty) x 22;
    $csv_row[0] = $file_timestamp_str;
    $csv_row[21] = "Excl. SBY";
    push @csv_row, $formula_sum_current_ent_excl_sby, $formula_sum_nfit_ent_excl_sby, $formula_delta_excl_sby, $formula_perc_excl_sby;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Blank Row ---
    print STDOUT "\n"; # Corresponds to e.g. Excel row 256

    # --- Row: AS-IS NFIT Labels --- (e.g., Excel row 257 / my $row_as_is_nfit_labels)
    @csv_row = ($empty) x 23; # Ensure enough columns
    $csv_row[17] = "AS-IS"; # Column R
    $csv_row[18] = "NFIT";  # Column S
    $csv_row[20] = "AS-IS"; # Column U (for Largest PowerHA AS-IS)
    $csv_row[21] = "NFIT";  # Column V (for Largest PowerHA NFIT)
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Row: ENT Column Headers and other labels --- (e.g., Excel row 258 / my $row_ent_col_headers)
    @csv_row = ($empty) x 22; # Adjust total size based on max column used
    $csv_row[0] = "ENT"; $csv_row[1] = "ENT-NOVIO"; $csv_row[2] = "ENT-HA"; $csv_row[3] = "ENT-NFIT";
    $csv_row[4] = "NFIT-ENT-NO-VIO"; $csv_row[5] = "NFIT-ENT-NO-POWERHA-STANDBY";
    $csv_row[6] = "NFIT-ENT-NO-POWERHA-SBY-NO-VIO"; $csv_row[7] = "NFIT-ENT-POWERHA-SBY-AS-IS";
    $csv_row[8] = "NFIT-ENT-POWERHA-SBY-AS-IS-NOVIO";
    $csv_row[12] = "PowerHA SBY% TGT"; $csv_row[13] = "0.25"; # Cols M, N
    
    my $largest_frame_formula_as_is = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,rows,FILTER(HSTACK(sys,ent),NOT(type=\"VIO Server\")),uniqSys,UNIQUE(INDEX(rows,,1)),sums,BYROW(uniqSys,LAMBDA(s,SUM(FILTER(INDEX(rows,,2),INDEX(rows,,1)=s)))),XLOOKUP(MAX(sums),sums,uniqSys))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row);
    my $largest_frame_formula_nfit = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,rows,FILTER(HSTACK(sys,ent),NOT(type=\"VIO Server\")),uniqSys,UNIQUE(INDEX(rows,,1)),sums,BYROW(uniqSys,LAMBDA(s,SUM(FILTER(INDEX(rows,,2),INDEX(rows,,1)=s)))),XLOOKUP(MAX(sums),sums,uniqSys))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row);
    my $largest_powerha_formula_as_is = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,pharows,FILTER(HSTACK(sys,ent),ISNUMBER(SEARCH(\"PowerHA Primary\",type))),uniqSysPHA,UNIQUE(INDEX(pharows,,1)),sumsPHA,BYROW(uniqSysPHA,LAMBDA(s,SUM(FILTER(INDEX(pharows,,2),INDEX(pharows,,1)=s)))),XLOOKUP(MAX(sumsPHA),sumsPHA,uniqSysPHA,\"\"))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row); # Added if_not_found for XLOOKUP
    my $largest_powerha_formula_nfit = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,pharows,FILTER(HSTACK(sys,ent),ISNUMBER(SEARCH(\"PowerHA Primary\",type))),uniqSysPHA,UNIQUE(INDEX(pharows,,1)),sumsPHA,BYROW(uniqSysPHA,LAMBDA(s,SUM(FILTER(INDEX(pharows,,2),INDEX(pharows,,1)=s)))),XLOOKUP(MAX(sumsPHA),sumsPHA,uniqSysPHA,\"\"))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Added if_not_found

    $csv_row[16] = "Largest Frame"; # Col Q
    $csv_row[17] = $largest_frame_formula_as_is; # Col R
    $csv_row[18] = $largest_frame_formula_nfit;  # Col S
    $csv_row[19] = "Largest PowerHA"; # Col T
    $csv_row[20] = $largest_powerha_formula_as_is; # Col U
    $csv_row[21] = $largest_powerha_formula_nfit; # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Per-Serial Summary Rows --- (e.g., starting Excel row 259 / my $row_unique_serials_start)
    for (my $i = 0; $i < $loop_count_for_serials; $i++) {
        my $current_formula_row = $row_unique_serials_start + $i;
        my @csv_row_serial_summary;

        if ($i == 0) {
            my $formula_unique_serials = sprintf("=UNIQUE(%s\$2:%s\$%d)", $col_serial_letter, $col_serial_letter, $last_data_row);
            push @csv_row_serial_summary, $formula_unique_serials;
        } else {
            push @csv_row_serial_summary, $empty; # Column A empty for subsequent rows, UNIQUE spills
        }

        # Formulas for columns B-J
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row); # Col B
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col C
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col D
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row); # Col E
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col F
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>*PowerHA Standby*\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col G
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>*PowerHA Standby*\", \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col H
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMPRODUCT((\$%s\$2:\$%s\$%d=A%d)*IF(ISNUMBER(SEARCH(\"PowerHA Standby\",\$%s\$2:\$%s\$%d)),\$%s\$2:\$%s\$%d,\$%s\$2:\$%s\$%d)),\"\")", $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Col I
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMPRODUCT((\$%s\$2:\$%s\$%d=A%d)*(\$%s\$2:\$%s\$%d<>\"VIO Server\")*IF(ISNUMBER(SEARCH(\"PowerHA Standby\",\$%s\$2:\$%s\$%d)),\$%s\$2:\$%s\$%d,\$%s\$2:\$%s\$%d)),\"\")", $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Col J
        
        if ($i == 0) { # Add right-hand side elements only for the first row of this block
            my $num_main_formulas = scalar(@csv_row_serial_summary);
            my $padding_needed = 16 - $num_main_formulas; # Target Col Q (17th)
            push @csv_row_serial_summary, ($empty) x $padding_needed if $padding_needed > 0;

            my $col_R_header_cell = get_excel_col_name(18) . $row_ent_col_headers; # R258
            my $col_S_header_cell = get_excel_col_name(19) . $row_ent_col_headers; # S258
            my $col_U_header_cell = get_excel_col_name(21) . $row_ent_col_headers; # U258

            push @csv_row_serial_summary, "Largest Frame ENT (Excl. VIO)"; # Col Q
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_R_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col R
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_S_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col S
            push @csv_row_serial_summary, "Largest PowerHA ENT"; # Col T
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_U_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col U
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_U_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col V
        }
        print STDOUT join(",", map { quote_csv($_) } @csv_row_serial_summary) . "\n";
    }

    # --- Rows after per-serial summary (Frame Evac, etc.) ---
    my $actual_row_unique_serials_end = $row_unique_serials_start + $loop_count_for_serials - 1;
    my $row_after_serials_block = $row_unique_serials_start + $loop_count_for_serials;


    # Determine cell references for "Largest Frame AS-IS/NFIT result" and "Largest PHA AS-IS/NFIT result"
    # These are from the row $row_ent_col_headers, columns R, S, U, V respectively.
    my $cell_largest_frame_asis_val = get_excel_col_name(18) . $row_ent_col_headers; # R<row_ent_col_headers>
    my $cell_largest_frame_nfit_val = get_excel_col_name(19) . $row_ent_col_headers; # S<row_ent_col_headers>
    my $cell_largest_pha_asis_val   = get_excel_col_name(21) . $row_ent_col_headers; # U<row_ent_col_headers>
    my $cell_largest_pha_nfit_val   = get_excel_col_name(22) . $row_ent_col_headers; # V<row_ent_col_headers>

    # Row: Frame Evac - Max Required
    @csv_row = ($empty) x 22; # Pad to ensure correct column alignment
    $csv_row[16] = "Frame Evac - Max Required"; # Col Q
    $csv_row[17] = sprintf("=MAX(%s,%s)", $cell_largest_frame_asis_val, $cell_largest_pha_asis_val); # Col R
    $csv_row[21] = sprintf("=MAX(%s,%s)", $cell_largest_frame_nfit_val, $cell_largest_pha_nfit_val); # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # Row: Frame Evac - Required per frame
    # This refers to the results from the "Frame Evac - Max Required" line just printed.
    my $current_print_row_for_evac_max = $row_after_serials_block; # The row number where the above line was printed
                                                                  # This needs to be $row_after_serials_block if printed sequentially without gaps
    my $cell_max_req_as_is_val = get_excel_col_name(18) . $current_print_row_for_evac_max; # R<current_print_row>
    my $cell_max_req_nfit_val  = get_excel_col_name(22) . $current_print_row_for_evac_max; # V<current_print_row>

    @csv_row = ($empty) x 22;
    $csv_row[16] = "Frame Evac - Required per frame"; # Col Q
    $csv_row[17] = sprintf("=IFERROR(%s/COUNTA(UNIQUE(\$%s\$2:\$%s\$%d)),\"N/A\")", $cell_max_req_as_is_val, $col_serial_letter, $col_serial_letter, $last_data_row); # Col R
    $csv_row[21] = sprintf("=IFERROR(%s/COUNTA(UNIQUE(\$%s\$2:\$%s\$%d)),\"N/A\")", $cell_max_req_nfit_val, $col_serial_letter, $col_serial_letter, $last_data_row); # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";
    
    # Adjust row number for Total row if Frame Evac rows were printed
    my $row_for_total_sum = $current_print_row_for_evac_max + 2; # Skip one line after last Frame Evac

    # --- Total Row for Per-Serial Summary ---
    @csv_row = ();
    push @csv_row, "Total"; # Col A
    for my $col_idx (2..10) { # Columns B to J
        my $col_letter = get_excel_col_name($col_idx);
        if ($count_of_unique_serials > 0) {
            push @csv_row, sprintf("=SUM(%s%d:%s%d)", $col_letter, $row_unique_serials_start, $col_letter, $actual_row_unique_serials_end);
        } else { # No unique serials, sum is 0 or empty
            push @csv_row, "0"; 
        }
    }
    # Pad if necessary
    my $current_cols = scalar(@csv_row);
    push @csv_row, ($empty) x (22 - $current_cols) if 22 > $current_cols;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";
}

# --- log_profile_rationale (NEW: Highly Detailed Efficiency Logging for Planners) ---
# Logs the detailed rationale for how a profile's PhysC value was adjusted (or not).
# Includes inputs, intermediate calculation steps, and the final result.
sub log_profile_rationale
{
    my ($fh, $vm_name, $profile_being_adjusted,
        $raw_physc_for_profile,
        # This next argument is the name of the profile that sourced the RunQ metrics.
        # For per-profile RunQ logic, it's the same as $profile_being_adjusted.
        $runq_metrics_source_profile_name_for_this_calc,
        $abs_runq_value_used_for_calc, # This is the *value* of the AbsRunQ percentile used
        $normP50_for_this_calc, $normP90_for_this_calc,
        $vm_cfg_ref, $smt_val, $lpar_max_cpu_cfg_val_from_config,
        $profile_rq_behavior,
        $calc_debug_info_ref,              # Hash ref with detailed calculation steps, including AbsRunQKeyUsed
                                           # and new detailed fields for efficiency calculation.
        $final_csv_value_for_profile,
        $nfit_growth_adj_str               # GrowthAdj value from nfit
    ) = @_;

    return unless $fh; # Do nothing if log file handle is not valid

    my $na = 'N/A'; # Consistent N/A string for display
    # Determine the key of the AbsRunQ metric that was actually used, for clear logging.
    my $abs_runq_key_reported_in_log = $calc_debug_info_ref->{AbsRunQKeyUsed} // 'AbsRunQ_P90 (key unknown/default)';

    # --- Print Header for this VM/Profile section in the log ---
    print {$fh} "----------------------------------------------------------------------\n";
    printf {$fh} "VM Name                 : %s\n", $vm_name;
    printf {$fh} "Profile Adjusted        : %s\n", $profile_being_adjusted;
    print {$fh} "----------------------------------------------------------------------\n\n";

    # --- Section A: Inputs for RunQ Adjustment (Remains as previously defined) ---
    print {$fh} "Section A: Inputs for RunQ Adjustment\n";

    # --- Clarify nfit's Growth Adjustment on the input PhysC value ---
    my $nfit_growth_adj_numeric = 0.0;
    my $base_physc_from_nfit_before_its_growth = $raw_physc_for_profile; # Assume this is the nfit PXX output

    if (defined $nfit_growth_adj_str && $nfit_growth_adj_str =~ /^-?[0-9.]+$/ && ($nfit_growth_adj_str + 0) > $FLOAT_EPSILON)
    {
        $nfit_growth_adj_numeric = $nfit_growth_adj_str + 0;
        if (defined $raw_physc_for_profile && $raw_physc_for_profile ne $na && $raw_physc_for_profile =~ /^-?[0-9.]+$/)
        {
            # Calculate what nfit's value was *before* its own growth adjustment
            my $calculated_nfit_pre_growth = ($raw_physc_for_profile + 0) - $nfit_growth_adj_numeric;
            $base_physc_from_nfit_before_its_growth = sprintf("%.4f", $calculated_nfit_pre_growth);
        }
        printf {$fh} "  1. Base PhysC (from nfit's %s) : %s cores \t(INCLUDES GrowthAdj: +%.4f)\n", $profile_being_adjusted, ($raw_physc_for_profile // $na), $nfit_growth_adj_numeric;
        printf {$fh} "     (Implied base value before growth: ~%s cores)\n", $base_physc_from_nfit_before_its_growth;
    }
    else
    {
        my $parsed_adj = (defined $nfit_growth_adj_str && $nfit_growth_adj_str =~ /^-?[0-9.]+$/) ? ($nfit_growth_adj_str+0) : 0.0;
        printf {$fh} "  1. Base PhysC (from nfit's %s) : %s cores \t(nfit GrowthAdj was %.4f or N/A)\n", $profile_being_adjusted, ($raw_physc_for_profile // $na), $parsed_adj;
    }
    # --- END NEW Growth Info ---

    printf {$fh} "  2. RunQ Metrics for this Adjustment (sourced from this profile's ['%s'] nfit run):\n", $runq_metrics_source_profile_name_for_this_calc;
    printf {$fh} "     - AbsRunQ (%-13s) : %s threads\n", $abs_runq_key_reported_in_log, ($abs_runq_value_used_for_calc // $na);
    printf {$fh} "     - NormRunQ P50            : %s\n", ($normP50_for_this_calc // $na);
    printf {$fh} "     - NormRunQ P90            : %s\n", ($normP90_for_this_calc // $na);
    print {$fh} "  3. VM Configuration:\n";
    printf {$fh} "     - SMT                     : %s\n", ($smt_val // $na);
    my $entitlement_display = (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} && $vm_cfg_ref->{entitlement} ne '') ? $vm_cfg_ref->{entitlement} : $na;
    printf {$fh} "     - Current Entitlement     : %s cores\n", $entitlement_display;
    my $lpar_max_cpu_display = ($lpar_max_cpu_cfg_val_from_config > 0) ? sprintf("%.2f", $lpar_max_cpu_cfg_val_from_config) : $na;
    printf {$fh} "     - LPAR MaxCPU             : %s cores\n", $lpar_max_cpu_display;
    my $is_non_default_pool_log = (defined $vm_cfg_ref && defined $vm_cfg_ref->{pool_name} && lc($vm_cfg_ref->{pool_name}) ne 'defaultpool' && $vm_cfg_ref->{pool_name} ne '') ? "Yes" : "No";
    printf {$fh} "     - In Non-Default Pool     : %s\n", $is_non_default_pool_log;
    printf {$fh} "  4. Profile RunQ Behavior    : %s\n\n", ($profile_rq_behavior // $na);

    # --- Check if modification was skipped early (e.g., Base PhysC was N/A) ---
    if (defined $calc_debug_info_ref->{'ReasonForNoModification'} && $calc_debug_info_ref->{'ReasonForNoModification'} ne '')
    {
        printf {$fh} "RunQ Modification Skipped: %s\n", $calc_debug_info_ref->{'ReasonForNoModification'};
        printf {$fh} "Final Value for Profile '%s': %s cores (same as Base PhysC due to skip)\n\n", $profile_being_adjusted, ($raw_physc_for_profile // $na);
        return; # No further rationale to log for this profile
    }

    # --- Section B: RunQ-Driven CPU Adjustment Calculation Details ---
    print {$fh} "Section B: RunQ-Driven CPU Adjustment Calculation\n";
    # --- Subsection B.1: Efficiency Adjustment (NEW DETAILED LOGIC) ---
    printf {$fh} "  1. Efficiency Adjustment (Profile RunQ Behavior: %s):\n", ($profile_rq_behavior // $na);
    printf {$fh} "     ---------------------------------------------------------\n";

    # Condition to print detailed analytical breakdown:
    # - EffFactorReason must indicate an analytical path was taken.
    # - Key intermediate values like EffPEfficientTarget (blended target) and initial condition checks should be defined.
    if ( $calc_debug_info_ref->{'EffFactorReason'} =~ /^Analytical/ &&
         defined $calc_debug_info_ref->{'EffPEfficientTarget'} && # Blended target
         defined $calc_debug_info_ref->{'EffCondNormP50Met'} &&
         defined $calc_debug_info_ref->{'EffCondVolatilityMet'} )
    {
        # --- Print detailed analytical breakdown ---
        printf {$fh} "     a. Initial Condition Checks for Efficiency Reduction Path:\n";
        # Guard rail checks (like additive_only, bursting, high constraint) are assumed to have been handled
        # by calculate_runq_modified_physc setting a non-"Analytical:" EffFactorReason if they caused a skip.
        my $eff_cond_norm_p50_met_str = $calc_debug_info_ref->{'EffCondNormP50Met'} ? "YES (Low P50)" : "NO (P50 not low enough)";
        printf {$fh} "        - NormRunQ P50             : %-5s (Condition: < %.2f for consideration? %s)\n",
                     ($normP50_for_this_calc // $na),
                     $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION,
                     $eff_cond_norm_p50_met_str;

        my $eff_cond_volatility_met_str = $calc_debug_info_ref->{'EffCondVolatilityMet'} ? "YES (Not excessively volatile)" : "NO (Too volatile - analytical path for reduction likely skipped)";
        printf {$fh} "        - Workload Volatility      : %-5s (NormP90_%.2f / NormP50_%.2f. Condition: < %.2f to proceed? %s)\n",
                     ($calc_debug_info_ref->{'EffVolatilityRatio'} // $na),
                     ($normP90_for_this_calc eq $na ? 0.0 : ($normP90_for_this_calc+0)),
                     ($normP50_for_this_calc eq $na ? 0.0 : ($normP50_for_this_calc+0)),
                     $VOLATILITY_CAUTION_THRESHOLD,
                     $eff_cond_volatility_met_str;
        print {$fh} "\n";

        printf {$fh} "     b. Calculating Raw Efficient PhysC Target (Theoretical Minimum if RunQ was at Target Norm):\n";
        printf {$fh} "        - Base PhysC for Profile   : %s cores\n", ($calc_debug_info_ref->{'EffPBase'} // $na);
        printf {$fh} "        - AbsRunQ Metric Used      : %s (value: %s threads)\n", $abs_runq_key_reported_in_log, ($abs_runq_value_used_for_calc // $na);
        printf {$fh} "        - SMT Value                : %s\n", ($calc_debug_info_ref->{'EffSMTValue'} // $na);
        printf {$fh} "        - Target NormRunQ for SMT%-2s: %.2f (internal heuristic for optimal queue/LCPU)\n",
                     ($calc_debug_info_ref->{'EffSMTValue'} // $na),
                     ($calc_debug_info_ref->{'EffTargetNormRunQ'} // $na);
        printf {$fh} "        - Calculated Raw Efficient PhysC Target = AbsRunQ / (SMT * Target NormRunQ)\n";
        printf {$fh} "                                        = %s / (%s * %.2f) = %s cores\n",
                     ($abs_runq_value_used_for_calc // $na),
                     ($calc_debug_info_ref->{'EffSMTValue'} // $na),
                     ($calc_debug_info_ref->{'EffTargetNormRunQ'} // $na),
                     ($calc_debug_info_ref->{'EffPEfficientTargetRaw'} // $na);
        print {$fh} "\n";

        printf {$fh} "     c. Blending Raw Target with Observed Base PhysC (Applying Confidence):\n";
        printf {$fh} "        - Blending Weights         : %.0f%% Base PhysC / %.0f%% Raw Target\n",
                     defined $calc_debug_info_ref->{'EffBlendWeightBase'} ? (($calc_debug_info_ref->{'EffBlendWeightBase'} // 0) * 100) : 0,
                     defined $calc_debug_info_ref->{'EffBlendWeightTarget'} ? (($calc_debug_info_ref->{'EffBlendWeightTarget'} // 0) * 100) : 0;
        printf {$fh} "        - Blending Rationale       : %s\n", ($calc_debug_info_ref->{'EffBlendReason'} // $na);
        printf {$fh} "        - Blended Efficient Target = (Base PhysC * Weight) + (Raw Target * Weight)\n";
        printf {$fh} "                                 = (%s * %.2f) + (%s * %.2f) = %s cores\n",
                     ($calc_debug_info_ref->{'EffPBase'} // $na),
                     ($calc_debug_info_ref->{'EffBlendWeightBase'} // 0.0),
                     ($calc_debug_info_ref->{'EffPEfficientTargetRaw'} // $na),
                     ($calc_debug_info_ref->{'EffBlendWeightTarget'} // 0.0),
                     ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na); # This is the blended target
        print {$fh} "\n";

        printf {$fh} "     d. Determining Potential CPU Reduction (Based on Blended Target):\n";
        my $eff_comp_base_vs_target_met_str = defined($calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'})
                                            ? ($calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'} ? "YES" : "NO") : $na;
        printf {$fh} "        - Comparison               : Base PhysC (%s) > Blended Efficient Target (%s)? %s\n",
                     ($calc_debug_info_ref->{'EffPBase'} // $na),
                     ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na),
                     $eff_comp_base_vs_target_met_str;

        if (defined $calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'} && $calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'})
        {
            printf {$fh} "        - Potential CPU Reduction  : %s - %s = %s cores\n",
                         ($calc_debug_info_ref->{'EffPBase'} // $na),
                         ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na),
                         ($calc_debug_info_ref->{'EffPotentialReduction'} // $na);
            printf {$fh} "        - Max Reduction Cap %%      : %.1f%% (Reason: %s)\n",
                         ($calc_debug_info_ref->{'EffMaxAllowableReductionPerc'} eq $na ? ($MAX_EFFICIENCY_REDUCTION_PERCENTAGE*100) : ($calc_debug_info_ref->{'EffMaxAllowableReductionPerc'} +0) ),
                         ($calc_debug_info_ref->{'EffReductionCapReason'} // $na);
            printf {$fh} "        - Max Allowable Reduction  : %s cores (Base PhysC * Max Reduction Cap %%)\n",
                         ($calc_debug_info_ref->{'EffMaxAllowableReductionCores'} // $na);
            printf {$fh} "        - Actual CPU Reduction     : %s cores (min of Potential and Max Allowable)\n",
                         ($calc_debug_info_ref->{'EffActualReductionCores'} // $na);
        }
        else
        {
            printf {$fh} "        - No potential for reduction based on Blended Target, or reduction was zero.\n";
        }
        print {$fh} "\n";

        printf {$fh} "     e. Final Efficiency Factor Calculation:\n";
        printf {$fh} "        - Calculated Efficiency Factor: (Base PhysC - Actual Reduction) / Base PhysC\n";
        # Ensure EffPBase is numeric and non-zero for division display
        my $eff_p_base_val_for_div = ($calc_debug_info_ref->{'EffPBase'} ne $na && ($calc_debug_info_ref->{'EffPBase'} + 0) != 0)
                                   ? ($calc_debug_info_ref->{'EffPBase'} + 0)
                                   : 1.0; # Use 1.0 to avoid division by zero in display if base is 0/NA
        my $eff_p_base_display_for_div = ($eff_p_base_val_for_div == 1.0 && ($calc_debug_info_ref->{'EffPBase'} eq $na || ($calc_debug_info_ref->{'EffPBase'} + 0) == 0))
                                       ? "$eff_p_base_val_for_div (adjusted for display to avoid div by zero)"
                                       : ($calc_debug_info_ref->{'EffPBase'} // $na);

        printf {$fh} "                                      (%s - %s) / %s = %s\n",
                     ($calc_debug_info_ref->{'EffPBase'} // $na),
                     ($calc_debug_info_ref->{'EffActualReductionCores'} // "0.0000"),
                     $eff_p_base_display_for_div,
                     ($calc_debug_info_ref->{'EffCalculatedFactor'} // $na);
        printf {$fh} "        - Final Efficiency Factor Applied: %s\n", ($calc_debug_info_ref->{'EffFinalFactorApplied'} // $na);
        printf {$fh} "\n     Summary of Efficiency Adjustment: %s\n", $calc_debug_info_ref->{'EffFactorReason'};
    }
    else # Efficiency was skipped by a guard, or didn't proceed far enough for detailed analytical log.
    {
        # Print the simplified overall reason
        printf {$fh} "     - Efficiency Factor       : %s\n", ($calc_debug_info_ref->{'EffFactor'} // "1.00");
        printf {$fh} "     - Reason                  : %s\n", ($calc_debug_info_ref->{'EffFactorReason'} // "Details not available or efficiency adjustment skipped/not applicable.");
    }
    printf {$fh} "     ---------------------------------------------------------\n";
    printf {$fh} "     => PhysC after Efficiency  : %s cores\n\n", ($calc_debug_info_ref->{'BaseAdjustedPhysC'} // $na);


    # --- Pressure Assessment, Additive CPU, Capping (Sections B.2, B.3, B.4, C, D) ---
    # This part remains the same as the previously working version for these sections.
    # It will use $abs_runq_value_used_for_calc and $abs_runq_key_reported_in_log correctly.
    print {$fh} "  2. Pressure Assessment (based on RunQ Metrics for profile '$profile_being_adjusted'):\n";
    my $runq_pressure_val_numeric_from_debug = ($calc_debug_info_ref->{'RunQPressure_P90_Val'} ne $na && $calc_debug_info_ref->{'RunQPressure_P90_Val'} =~ /^-?[0-9.]+$/)
                                          ? ($calc_debug_info_ref->{'RunQPressure_P90_Val'} + 0)
                                          : undef;
    my $runq_pressure_interpretation = $na;
    my $runq_pressure_calc_display_str = $na;

    my $abs_runq_num_for_display_log = ($abs_runq_value_used_for_calc ne $na && $abs_runq_value_used_for_calc =~ /^-?[0-9.]+$/)
                                  ? ($abs_runq_value_used_for_calc + 0)
                                  : undef;
    my $max_cpu_num_for_display_log = ($lpar_max_cpu_cfg_val_from_config > 0) ? $lpar_max_cpu_cfg_val_from_config : 0;
    my $smt_num_for_display_log = ($smt_val > 0) ? $smt_val : 0;

    if (defined $abs_runq_num_for_display_log && $max_cpu_num_for_display_log > 0 && $smt_num_for_display_log > 0)
    {
        $runq_pressure_calc_display_str = sprintf("%.2f (%s) / (%.2f * %d)",
                                              $abs_runq_num_for_display_log,
                                              $abs_runq_key_reported_in_log,
                                              $max_cpu_num_for_display_log,
                                              $smt_num_for_display_log);
    }

    if (defined $runq_pressure_val_numeric_from_debug)
    {
        if ($runq_pressure_val_numeric_from_debug > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD) { $runq_pressure_interpretation = "HIGH PRESSURE"; }
        elsif ($runq_pressure_val_numeric_from_debug > 0.70) { $runq_pressure_interpretation = "MODERATE"; }
        else { $runq_pressure_interpretation = "LOW"; }
    }

    printf {$fh} "     - RunQ Pressure (Absolute Queue vs LPAR Max Capacity):\n";
    printf {$fh} "         Value                   : %-8s (Calculated as: %s = %s)\n",
                 ($calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na),
                 $runq_pressure_calc_display_str,
                 ($calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na);
    printf {$fh} "         Interpretation          : %s (Flag threshold: > %.2f)\n", $runq_pressure_interpretation, $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD;
    printf {$fh} "         IsRunQPressure Flag     : %s\n", ($calc_debug_info_ref->{'IsRunQPressure'} // $na);

    my $norm_p90_val_for_display_log = ($normP90_for_this_calc ne $na && $normP90_for_this_calc =~ /^-?[0-9.]+$/) ? ($normP90_for_this_calc + 0) : undef;
    my $workload_pressure_interpretation = $na;
    if (defined $norm_p90_val_for_display_log)
    {
        if ($norm_p90_val_for_display_log > 1.5) { $workload_pressure_interpretation = "HIGH QUEUING per active LCPU"; }
        elsif ($norm_p90_val_for_display_log > 1.0) { $workload_pressure_interpretation = "MODERATE QUEUING per active LCPU"; }
        else { $workload_pressure_interpretation = "OPTIMAL/LOW QUEUING per active LCPU"; }
    }

    printf {$fh} "     - Workload Pressure (Normalized Queue vs Active CPUs):\n";
    printf {$fh} "         NormRunQ P90 Value      : %s (from profile '%s')\n", ($normP90_for_this_calc // $na), $profile_being_adjusted;
    printf {$fh} "         Interpretation          : %s (Flag threshold: > %.2f)\n", $workload_pressure_interpretation, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD;
    printf {$fh} "         Workload Pressure Reason: %s\n", ($calc_debug_info_ref->{'WorkloadPressureReason'} // $na);
    printf {$fh} "         IsWorkloadPressure Flag : %s\n", ($calc_debug_info_ref->{'IsWorkloadPressure'} // $na);

    my $is_rq_pressure_bool_log = ($calc_debug_info_ref->{'IsRunQPressure'} // "False") eq "True";
    my $is_wl_pressure_bool_log = ($calc_debug_info_ref->{'IsWorkloadPressure'} // "False") eq "True";
    my $apply_additive_log = $is_rq_pressure_bool_log || $is_wl_pressure_bool_log;
    printf {$fh} "     >> Additive Logic Applies  : %s\n\n", ($apply_additive_log ? "Yes" : "No");

    my $final_additive_val_log_str = $calc_debug_info_ref->{'FinalAdditive'} // "0.0000";
    if ($apply_additive_log)
    {
        printf {$fh} "  3. Additive CPU Calculation:\n";
        my $base_physc_for_add_log = $calc_debug_info_ref->{'BasePhysC'} // $na;
        if ($base_physc_for_add_log ne $na && $base_physc_for_add_log =~ /^-?[0-9.]+$/)
        {
            printf {$fh} "     - Base PhysC for Additive : %.4f cores (Raw PhysC of profile '%s')\n", ($base_physc_for_add_log+0), $profile_being_adjusted;
        }
        else
        {
            printf {$fh} "     - Base PhysC for Additive : %s (Raw PhysC of profile '%s')\n", $base_physc_for_add_log, $profile_being_adjusted;
        }
        printf {$fh} "     - Effective LCPUsAtBase   : %-8s threads (Base PhysC * SMT)\n", ($calc_debug_info_ref->{'EffectiveLCPUsAtBase'} // $na);
        printf {$fh} "     - Excess Threads          : %-8s threads (AbsRunQ %s vs. Tolerated Run-Queue Capacity)\n",
                     ($calc_debug_info_ref->{'ExcessThreads'} // $na),
                     $abs_runq_key_reported_in_log;
        printf {$fh} "     - Raw Additive CPU        : %-8s cores (Excess Threads / SMT)\n", ($calc_debug_info_ref->{'RawAdditive'} // $na);
        printf {$fh} "     - Max Additive Cap        : %-8s cores (Derived from Entitlement: %s)\n", ($calc_debug_info_ref->{'MaxAdditiveCap'} // $na), $entitlement_display;
        printf {$fh} "     - Capped Raw Additive     : %-8s cores (Min(Raw Additive, Max Cap))\n", ($calc_debug_info_ref->{'CappedRawAdditive'} // $na);
        printf {$fh} "     - Volatility Factor       : %s (Reason: %s)\n", ($calc_debug_info_ref->{'VoltFactor'} // $na), ($calc_debug_info_ref->{'VoltFactorReason'} // $na);
        printf {$fh} "     - Pool Factor             : %s\n", ($calc_debug_info_ref->{'PoolFactor'} // $na);
        printf {$fh} "     - Final Additive CPU      : %-8s cores\n\n", ($final_additive_val_log_str eq $na ? $na : sprintf "%.4f", $final_additive_val_log_str);
    }
    else
    {
        printf {$fh} "  3. Additive CPU Calculation : Skipped (No significant pressure detected or other condition prevented additive logic).\n\n";
    }

    printf {$fh} "  4. CPU Recommendation (Pre LPAR MaxCPU Cap):\n";
    my $pre_cap_rec_val_log_str = $calc_debug_info_ref->{'PreMaxCpuCapRec'} // $na;
    printf {$fh} "     - Pre-Cap Value           : %-8s cores (PhysC after Efficiency + Final Additive)\n\n", ($pre_cap_rec_val_log_str eq $na ? $na : sprintf "%.4f", $pre_cap_rec_val_log_str);

    print {$fh} "Section C: LPAR MaxCPU Capping\n";
    printf {$fh} "  1. LPAR MaxCPU (from config)  : %s cores\n", $lpar_max_cpu_display;
    printf {$fh} "  2. Entitlement (for multiplier): %s cores\n", $entitlement_display;
    my $fm_val_log = $calc_debug_info_ref->{'ForecastMultiplier'};
    if (defined $fm_val_log && $fm_val_log ne $na && $fm_val_log =~ /^-?[0-9.]+$/)
    {
         printf {$fh} "  3. Forecast Multiplier        : %.2f\n", ($fm_val_log+0);
    }
    else
    {
         printf {$fh} "  3. Forecast Multiplier        : %s\n", ($fm_val_log // $na);
    }
    my $eff_max_cap_val_log_str = $calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na;
    printf {$fh} "  4. Effective MaxCPU Cap       : %-8s cores (LPAR MaxCPU * Forecast Multiplier)\n", ($eff_max_cap_val_log_str eq $na ? $na : sprintf "%.4f", $eff_max_cap_val_log_str);
    printf {$fh} "  5. Is Capped by MaxCPU?       : %s\n\n", ($calc_debug_info_ref->{'CappedByMaxCPU'} // $na);

    print {$fh} "Section D: Final Result for Profile '$profile_being_adjusted'\n";
    if ($nfit_growth_adj_numeric > $FLOAT_EPSILON)
    {
         printf {$fh} "  - Input from nfit (PXX value)            : %s cores (was ~%s + %.4f GrowthAdj from nfit)\n", 
            ($raw_physc_for_profile // $na), 
            $base_physc_from_nfit_before_its_growth, 
            $nfit_growth_adj_numeric;
    }
    else
    {
         printf {$fh} "  - Input from nfit (PXX value)            : %s cores (nfit GrowthAdj was effectively zero)\n", ($raw_physc_for_profile // $na);
    }

    printf {$fh} "  - nfit-profile Internal Modifiers Reason : %s\n", ($calc_debug_info_ref->{EffFactorReason} // "Efficiency N/A") . "; Additive: " . ($calc_debug_info_ref->{FinalAdditive} // "0.0000");
    printf {$fh} "  => Final Value Written to CSV by nfit-profile : %s cores\n", ($final_csv_value_for_profile // $na);
    print {$fh} "\n";
}

# --- Helper subroutine to parse and collate percentile lists for nfit calls ---
# Takes an existing list of percentiles (as a comma-separated string) and an array
# of numeric percentiles that must be ensured to be present in the final list.
# Returns a sorted, unique array of percentile strings, formatted for nfit.
sub parse_and_collate_percentiles
{
    my ($existing_perc_list_str, @ensure_these_percs_numeric) = @_;
    my %final_percs_map; # Use a hash to store unique percentiles to avoid duplicates

    # Add percentiles from the existing string (e.g., from profile flags or global nfit-profile default)
    if (defined $existing_perc_list_str && $existing_perc_list_str ne '')
    {
        my @raw_list = split /,\s*/, $existing_perc_list_str;
        foreach my $p_str (@raw_list)
        {
            next if $p_str eq ''; # Skip empty strings that might result from split (e.g. "80,,90")
            
            # Validate if it looks like a percentile number, then format it consistently for nfit
            if ($p_str =~ /^[0-9.]+$/ && $p_str >= 0 && $p_str <= 100)
            {
                my $p_label = sprintf("%.2f", $p_str + 0); # Normalize format (e.g., "90.00")
                $p_label =~ s/\.?0+$//;                    # Clean trailing ".00" (e.g., "90")
                $p_label = "0" if $p_label eq "" && abs(($p_str+0) - 0) < 0.001; # Handle case of "0.00" -> "0"
                $final_percs_map{$p_label} = 1; # Add to hash (value 1 is arbitrary, key is what matters)
            }
            else
            {
                # If it's not a simple number, it might be an invalid value.
                # nfit.pl will ultimately validate it. For now, include as is.
                # Alternatively, one could issue a warning here:
                # warn "Warning: Non-standard percentile string '$p_str' found in list '$existing_perc_list_str'. Passing to nfit as is.\n";
                $final_percs_map{$p_str} = 1; 
            }
        }
    }

    # Add percentiles that must be ensured (e.g., P90 for AbsRunQ, P50/P90 for NormRunQ)
    foreach my $p_num (@ensure_these_percs_numeric)
    {
        my $p_label = sprintf("%.2f", $p_num); # Format, e.g., 90 -> "90.00", 98.5 -> "98.50"
        $p_label =~ s/\.?0+$//;                # Clean to "90", "98.5"
        $p_label = "0" if $p_label eq "" && abs($p_num - 0) < 0.001; # "0.00" -> "0"
        $final_percs_map{$p_label} = 1; # Add/overwrite in hash to ensure it's present
    }
    
    # Return a numerically sorted list of unique percentile strings
    my @sorted_keys = sort {
        # Robust sort: treat as numbers if possible, otherwise string compare
        my $is_a_num = ($a =~ /^[0-9.]+$/); # Check if $a looks like a number
        my $is_b_num = ($b =~ /^[0-9.]+$/); # Check if $b looks like a number
        if ($is_a_num && $is_b_num) { return ($a+0) <=> ($b+0); } # Both are numbers, numeric sort
        elsif ($is_a_num) { return -1; } # Numbers come before non-numbers
        elsif ($is_b_num) { return 1;  } # Non-numbers come after numbers
        else { return $a cmp $b; }       # Both are non-numbers (e.g. invalid values), string compare
    } keys %final_percs_map; # Get unique keys from hash and sort them
    
    return @sorted_keys;
}

# --- quote_csv ---
# Ensures a string is properly quoted for CSV output, escaping internal double quotes.
sub quote_csv
{
    my ($field) = @_;
    if (!defined $field) # Handle undefined fields as empty strings
    {
        $field = '';
    }
    $field =~ s/"/""/g; # Escape any double quotes within the field by doubling them
    return qq/"$field"/; # Enclose the entire field in double quotes
}

# --- load_profile_definitions ---
# Loads profile configurations from the specified INI-like file.
# Each section [Profile Name] defines a profile.
# Keys: nfit_flags (mandatory), runq_modifier_behavior (optional, default: 'default').
sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef; # Name of the current [Profile] being parsed
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath
        or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//;    # Remove comments starting with #
        $line =~ s/\s*;.*//;    # Remove comments starting with ; (alternative comment)
        $line =~ s/^\s+|\s+$//g; # Trim leading/trailing whitespace
        next if $line eq '';    # Skip empty lines or lines that became empty after comment removal

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/) # Matches section header like [Profile Name]
        {
            # Before starting a new section, check if the previous one was potentially incomplete
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags} && # Flags are mandatory
                (!defined $loaded_profiles_list[-1]{runq_behavior} || $loaded_profiles_list[-1]{runq_behavior} eq 'default') )
            {
                 my $is_incomplete = 1;
                 # A profile needs flags to be valid. If flags were somehow defined but this check missed it,
                 # this might be overly cautious, but missing flags is the primary concern.
                 if (defined $loaded_profiles_list[-1]{flags})
                 {
                    $is_incomplete = 0;
                 }
                 if ($is_incomplete)
                 {
                    warn "Warning: Profile section '[$current_section_name]' in '$filepath' (ending before line $line_number) appears incomplete (missing nfit_flags). Skipping this potentially malformed entry.\n";
                    pop @loaded_profiles_list; # Remove the incomplete profile
                 }
            }

            $current_section_name = $1; # Capture profile name from section header
            $current_section_name =~ s/^\s+|\s+$//g; # Trim spaces from profile name
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef; # Reset current section context
                next;
            }
            # Initialize the new profile with its name and default runq_behavior. Flags added later.
            push @loaded_profiles_list, { name => $current_section_name, flags => undef, runq_behavior => 'default' };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/) # Matches key-value pair like nfit_flags = ...
        {
            my $key = lc($1); # Key name (lowercase for case-insensitivity)
            my $value = $2;   # Value
            $key =~ s/^\s+|\s+$//g;   # Trim spaces from key
            $value =~ s/^\s+|\s+$//g; # Trim spaces from value

            # Ensure we are adding to the currently parsed profile
            if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
            {
                if ($key eq 'nfit_flags')
                {
                    if (defined $loaded_profiles_list[-1]{flags}) # Check for duplicate flags
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one defined.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                elsif ($key eq 'runq_modifier_behavior')
                {
                     if (defined $loaded_profiles_list[-1]{runq_behavior} && $loaded_profiles_list[-1]{runq_behavior} ne 'default')
                    { # Check for duplicate runq_behavior definition
                        warn "Warning: Duplicate 'runq_modifier_behavior' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one defined.\n";
                    }
                    # Validate the value for runq_modifier_behavior
                    if ($value eq 'additive_only' || $value eq 'default')
                    {
                        $loaded_profiles_list[-1]{runq_behavior} = $value;
                    }
                    else
                    {
                        warn "Warning: Invalid value '$value' for 'runq_modifier_behavior' in profile '[$current_section_name]' (line $line_number). Using default. Allowed: additive_only, default.\n";
                        $loaded_profiles_list[-1]{runq_behavior} = 'default'; # Fallback to default if invalid value
                    }
                }
                # Add other potential profile-specific keys here if needed in the future
                # else { warn "Warning: Unknown key '$key' in profile '[$current_section_name]' ..."; }
            }
            else # Key-value pair found outside a valid section or for a mismatched section
            {
                 warn "Warning: Key-value pair '$key=$value' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping.\n";
            }
        }
        elsif ($line ne '') # Non-empty line that doesn't match section or key-value format
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    } # End while loop reading file
    close $fh;

    # Final validation of loaded profiles: ensure all valid profiles have 'nfit_flags'
    my @valid_profiles;
    foreach my $p_ref (@loaded_profiles_list)
    {
        if (defined $p_ref->{flags} && $p_ref->{flags} ne '')
        {
            # runq_behavior is already defaulted or set during parsing
            push @valid_profiles, $p_ref;
        }
        else # Profile is missing the mandatory 'nfit_flags'
        {
            warn "Warning: Profile '[" . $p_ref->{name} . "]' in '$filepath' is missing mandatory 'nfit_flags' definition. Removing this profile from processing.\n";
        }
    }
    return @valid_profiles;
}

# --- calculate_runq_modified_physc (with enhanced efficiency logic and detailed debug output) ---
# Calculates the final PhysC value for a profile after applying efficiency factors
# and RunQ-driven additive CPU adjustments.
# Takes the raw PhysC from nfit, RunQ metrics, SMT, entitlement, MaxCPU, etc.
# Returns the adjusted PhysC value and a hash of debug information for logging.
sub calculate_runq_modified_physc
{
    my (
        $selected_tier_physc_value_str,
        $norm_runq_p50_str,
        $norm_runq_p90_str,
        $abs_runq_p_value_str,
        $abs_runq_key_for_debug,
        $smt_used,
        $current_entitlement_str,
        $max_cpu_config_str,
        $is_in_non_default_pool,
        $profile_runq_behavior_setting,
        $p99w1_overall_vm_has_abs_runq_pressure,
        $p99w1_overall_vm_has_norm_runq_pressure 
    ) = @_;

    my %debug_info;
    my $na_str = "N/A";

    # --- Initialize all debug fields to sensible defaults or N/A ---
    $debug_info{AbsRunQKeyUsed} = $abs_runq_key_for_debug // 'N/A (key not provided)';
    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // $na_str;
    $profile_runq_behavior_setting //= 'default';

    my $base_physc = ($selected_tier_physc_value_str ne $na_str && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/)
                   ? ($selected_tier_physc_value_str + 0)
                   : undef;

    # Efficiency related fields - meticulously initialized
    $debug_info{'EffFactorReason'} = "Efficiency calculation not initiated or skipped by initial guards.";
    $debug_info{'EffFactor'} = "1.00"; # This will be the final sprintf'd version
    $debug_info{'EffCondNormP50Met'} = undef; # Boolean: NormP50 low enough?
    $debug_info{'EffCondVolatilityMet'} = undef; # Boolean: Volatility acceptable?
    $debug_info{'EffVolatilityRatio'} = $na_str;
    $debug_info{'EffPBase'} = (defined $base_physc) ? sprintf("%.4f", $base_physc) : $na_str;
    $debug_info{'EffSMTValue'} = $smt_used // $na_str;
    $debug_info{'EffTargetNormRunQ'} = $na_str;
    $debug_info{'EffPEfficientTargetRaw'} = $na_str; # Raw target before blending
    $debug_info{'EffBlendReason'} = "Blending not applied or not applicable.";
    $debug_info{'EffBlendWeightBase'} = $na_str;   # e.g., 0.75
    $debug_info{'EffBlendWeightTarget'} = $na_str; # e.g., 0.25
    $debug_info{'EffPEfficientTarget'} = $na_str; # This will be the blended target
    $debug_info{'EffComparisonBaseVsTargetMet'} = undef; # Boolean: Base > Blended Target?
    $debug_info{'EffPotentialReduction'} = $na_str;
    $debug_info{'EffMaxAllowableReductionPerc'} = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * 100; # Default cap %
    $debug_info{'EffReductionCapReason'} = "Default reduction cap applied.";
    $debug_info{'EffMaxAllowableReductionCores'} = $na_str;
    $debug_info{'EffActualReductionCores'} = $na_str;
    $debug_info{'EffCalculatedFactor'} = "1.0000"; # Raw, unformatted factor
    $debug_info{'EffFinalFactorApplied'} = "1.00"; # Formatted, final factor used

    # General fields
    $debug_info{'BaseAdjustedPhysC'} = defined($base_physc) ? sprintf("%.4f", $base_physc) : $na_str; # PhysC after efficiency
    $debug_info{'RunQPressure_P90_Val'} = $na_str; $debug_info{'IsRunQPressure'} = "False";
    $debug_info{'IsWorkloadPressure'} = "False"; $debug_info{'WorkloadPressureReason'} = "Conditions not met or N/A inputs";
    $debug_info{'EffectiveLCPUsAtBase'} = $na_str; $debug_info{'ExcessThreads'} = $na_str;
    $debug_info{'RawAdditive'} = "0.0000"; $debug_info{'MaxAdditiveCap'} = "0.0000"; $debug_info{'CappedRawAdditive'} = "0.0000";
    $debug_info{'VoltFactorReason'} = "Default (no overriding condition met or additive not applied)";
    $debug_info{'VoltFactor'} = "1.00";
    $debug_info{'PoolFactor'} = "1.00";
    $debug_info{'FinalAdditive'} = "0.0000";
    $debug_info{'PreMaxCpuCapRec'} = $debug_info{'BaseAdjustedPhysC'};
    $debug_info{'LPARMaxCPUConfig'} = ($max_cpu_config_str ne "" && $max_cpu_config_str =~ /^[0-9.]+$/ && ($max_cpu_config_str+0) > 0)
                                   ? ($max_cpu_config_str+0) : $na_str;
    $debug_info{'EntitlementForForecast'} = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/)
                                         ? ($current_entitlement_str + 0) : 0;
    $debug_info{'ForecastMultiplier'} = $na_str; $debug_info{'EffectiveMaxCPUCap'} = $na_str;
    $debug_info{'CappedByMaxCPU'} = $na_str;
    $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BasePhysC'}; # Default final is same as base
    $debug_info{'ReasonForNoModification'} = "";

    my $curr_ent_numeric = $debug_info{'EntitlementForForecast'};
    # EffPBase is the numeric version of base_physc for calculations within efficiency logic
    my $eff_p_base_numeric = defined($base_physc) ? $base_physc : undef;
    $debug_info{'EffPBase'} = defined($eff_p_base_numeric) ? sprintf("%.4f", $eff_p_base_numeric) : $na_str;


    unless (defined $base_physc)
    {
        $debug_info{'ReasonForNoModification'} = "BasePhysC for profile not numeric or N/A";
        $debug_info{'FinalAdjustedPhysC'} = $selected_tier_physc_value_str // $na_str;
        return ($selected_tier_physc_value_str // $na_str, \%debug_info);
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne $na_str && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne $na_str && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_runq_p_numeric  = ($abs_runq_p_value_str  ne $na_str && $abs_runq_p_value_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p_value_str + 0)  : undef;
    my $max_cpu_for_lpar_numeric = ($debug_info{'LPARMaxCPUConfig'} ne $na_str) ? $debug_info{'LPARMaxCPUConfig'} : 0;

    # --- Step 1: Enhanced Efficiency Factor Logic (with Guards, Blending, Volatility Cap) ---
    my $efficiency_factor_numeric = 1.00; # Default: no reduction
    $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor_numeric);
    $debug_info{'EffFactorReason'} = "Default (No reduction applied or eligible).";
    my $analytical_efficiency_path_attempted = 0; # Flag to track if we entered the core analytical logic

    # REFINED GUARD: Prevent efficiency reduction if P-99W1's RunQ metrics indicate pressure.
    # Guard 1: P-99W1's RunQ pressure
    if ( (defined $p99w1_overall_vm_has_abs_runq_pressure && $p99w1_overall_vm_has_abs_runq_pressure) ||
         (defined $p99w1_overall_vm_has_norm_runq_pressure && $p99w1_overall_vm_has_norm_runq_pressure) )
    {
        $debug_info{'EffFactorReason'} = sprintf(
            "Skipped Efficiency Reduction: VM's %s profile shows RunQ pressure (Abs P-99W1 pressure: %s, Norm P-99W1 pressure: %s).",
            $MANDATORY_PEAK_PROFILE_FOR_HINT,
            $p99w1_overall_vm_has_abs_runq_pressure ? "TRUE" : "FALSE",
            $p99w1_overall_vm_has_norm_runq_pressure ? "TRUE" : "FALSE"
        );
        # $efficiency_factor_numeric remains 1.00, no reduction applied due to this guard.
    }

    # Guard 2: Profile Behavior
    elsif ($profile_runq_behavior_setting eq 'additive_only') {
        $debug_info{'EffFactorReason'} = "Skipped: Profile runq_behavior=additive_only";
    }
    # Guard 3: Bursting Condition
    elsif (defined $curr_ent_numeric && $curr_ent_numeric > 0 && defined $eff_p_base_numeric && $eff_p_base_numeric > $curr_ent_numeric) {
        $debug_info{'EffFactorReason'} = sprintf("Skipped: Base PhysC (%.4f) > Entitlement (%.2f)", $eff_p_base_numeric, $curr_ent_numeric);
    }
    # Guard 4: High Existing Constraint (Base PhysC near MaxCPU AND RunQ Pressure high)
    elsif ($max_cpu_for_lpar_numeric > 0 && defined $eff_p_base_numeric && $eff_p_base_numeric > ($max_cpu_for_lpar_numeric * $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD)) {
        my $temp_runq_pressure_val = 0;
        if (defined $abs_runq_p_numeric && $smt_used > 0) {
            $temp_runq_pressure_val = $abs_runq_p_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
        }
        if ($temp_runq_pressure_val > ($RUNQ_PRESSURE_P90_SATURATION_THRESHOLD * $RUNQ_PRESSURE_FOR_CONSTRAINT_GUARD_FACTOR)) {
            $debug_info{'EffFactorReason'} = sprintf("Skipped: High existing constraint. Base PhysC (%.4f) > %.0f%% of MaxCPU (%.2f) AND RunQ Pressure (%.2f) is high.",
                                                     $eff_p_base_numeric, $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD*100, $max_cpu_for_lpar_numeric, $temp_runq_pressure_val);
        } else {
            $analytical_efficiency_path_attempted = 1;
        }
    } else {
        $analytical_efficiency_path_attempted = 1;
    }

    if ($analytical_efficiency_path_attempted && defined $norm_p50_numeric && defined $norm_p90_numeric && defined $abs_runq_p_numeric && $smt_used > 0 && defined $eff_p_base_numeric)
    {
        $debug_info{'EffCondNormP50Met'} = ($norm_p50_numeric < $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION);

        my $effective_p50_for_volatility = ($norm_p50_numeric > 0.0001)
                                         ? max($norm_p50_numeric, $MIN_P50_DENOMINATOR_FOR_VOLATILITY)
                                         : $MIN_P50_DENOMINATOR_FOR_VOLATILITY;
        my $volatility_ratio = (defined $norm_p90_numeric && $effective_p50_for_volatility > 0.0001)
                               ? ($norm_p90_numeric / $effective_p50_for_volatility)
                               : 1.0;
        $debug_info{'EffVolatilityRatio'} = sprintf("%.2f", $volatility_ratio);
        $debug_info{'EffCondVolatilityMet'} = ($volatility_ratio < $VOLATILITY_CAUTION_THRESHOLD);

        # Guard 4: High Workload Volatility
        if (!$debug_info{'EffCondVolatilityMet'}) {
             $debug_info{'EffFactorReason'} = sprintf("Skipped: Workload volatile (NormP90/P50 ratio %.2f >= %.2f). No analytical reduction.", $volatility_ratio, $VOLATILITY_CAUTION_THRESHOLD);
        }
        # Condition: NormP50 Low
        elsif (!$debug_info{'EffCondNormP50Met'}) {
             $debug_info{'EffFactorReason'} = sprintf("Skipped: NormRunQ P50 (%.2f) not below threshold (%.2f) for efficiency consideration. No analytical reduction.",
                                                     $norm_p50_numeric, $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION);
        }
        else # All preliminary analytical checks passed, proceed
        {
            my $target_norm_runq_eff_calc = $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC;
            if ($smt_used >= 8) { $target_norm_runq_eff_calc = 0.80; }
            elsif ($smt_used >= 4) { $target_norm_runq_eff_calc = 0.75; }
            else { $target_norm_runq_eff_calc = 0.60; }
            $debug_info{'EffTargetNormRunQ'} = sprintf("%.2f", $target_norm_runq_eff_calc);

            my $p_efficient_target_raw = ($smt_used * $target_norm_runq_eff_calc > 0.0001)
                                       ? ($abs_runq_p_numeric / ($smt_used * $target_norm_runq_eff_calc))
                                       : $eff_p_base_numeric + 1;
            $debug_info{'EffPEfficientTargetRaw'} = sprintf("%.4f", $p_efficient_target_raw);

            my $base_physc_weight = $BLEND_WEIGHT_BASE_DEFAULT_LOW_P50;
            my $efficient_target_weight = 1.0 - $base_physc_weight;
            my $blending_details_str = sprintf("Default low P50 blend (%.0f%% Base / %.0f%% Target).", $base_physc_weight*100, $efficient_target_weight*100);

            if ($norm_p50_numeric < $NORM_P50_LOW_THRESH_FOR_BLEND1) {
                $base_physc_weight = $BLEND_WEIGHT_BASE_FOR_LOW_P50_1;
                $efficient_target_weight = 1.0 - $base_physc_weight;
                $blending_details_str = sprintf("NormP50 (%.2f) < %.2f, using more aggressive blend (%.0f%% Base / %.0f%% Target).",
                                                $norm_p50_numeric, $NORM_P50_LOW_THRESH_FOR_BLEND1, $base_physc_weight*100, $efficient_target_weight*100);
            } elsif ($norm_p50_numeric < $NORM_P50_MODERATE_THRESH_FOR_BLEND2) {
                $base_physc_weight = $BLEND_WEIGHT_BASE_FOR_LOW_P50_2;
                $efficient_target_weight = 1.0 - $base_physc_weight;
                $blending_details_str = sprintf("NormP50 (%.2f) < %.2f, using moderate blend (%.0f%% Base / %.0f%% Target).",
                                                $norm_p50_numeric, $NORM_P50_MODERATE_THRESH_FOR_BLEND2, $base_physc_weight*100, $efficient_target_weight*100);
            }
            $debug_info{'EffBlendWeightBase'} = sprintf("%.2f", $base_physc_weight);
            $debug_info{'EffBlendWeightTarget'} = sprintf("%.2f", $efficient_target_weight);
            $debug_info{'EffBlendReason'} = $blending_details_str;

            my $blended_efficient_target = ($eff_p_base_numeric * $base_physc_weight) + ($p_efficient_target_raw * $efficient_target_weight);
            $debug_info{'EffPEfficientTarget'} = sprintf("%.4f", $blended_efficient_target);

            $debug_info{'EffComparisonBaseVsTargetMet'} = ($eff_p_base_numeric > $blended_efficient_target);

            if ($debug_info{'EffComparisonBaseVsTargetMet'})
            {
                my $potential_reduction_cores = $eff_p_base_numeric - $blended_efficient_target;
                $debug_info{'EffPotentialReduction'} = sprintf("%.4f", $potential_reduction_cores);

                my $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE;
                my $reduction_cap_reason_template = "Volatility (%.2f) low, using full reduction cap of %.1f%%.";

                if ($volatility_ratio > $VOLATILITY_MODERATE_HIGH_CAP_THRESH) {
                    $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * $REDUCTION_CAP_SCALE_FOR_MODERATE_HIGH_VOLATILITY;
                    $reduction_cap_reason_template = "Volatility (%.2f) moderately high (>%.2f), reduction cap limited to %.1f%%.";
                    $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $VOLATILITY_MODERATE_HIGH_CAP_THRESH, $current_max_reduction_perc_val * 100);
                } elsif ($volatility_ratio > $VOLATILITY_MODERATE_LOW_CAP_THRESH) {
                    $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * $REDUCTION_CAP_SCALE_FOR_MODERATE_VOLATILITY;
                    $reduction_cap_reason_template = "Volatility (%.2f) moderate (>%.2f), reduction cap limited to %.1f%%.";
                    $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $VOLATILITY_MODERATE_LOW_CAP_THRESH, $current_max_reduction_perc_val * 100);
                } else {
                     $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $current_max_reduction_perc_val * 100);
                }
                $debug_info{'EffMaxAllowableReductionPerc'} = $current_max_reduction_perc_val * 100;

                my $max_allowable_reduction_cores = $eff_p_base_numeric * $current_max_reduction_perc_val;
                $debug_info{'EffMaxAllowableReductionCores'} = sprintf("%.4f", $max_allowable_reduction_cores);
                my $actual_reduction_cores = min($potential_reduction_cores, $max_allowable_reduction_cores);
                # Ensure actual reduction is not negative if potential reduction somehow was (should not happen if Base > BlendedTarget)
                $actual_reduction_cores = max(0, $actual_reduction_cores);
                $debug_info{'EffActualReductionCores'} = sprintf("%.4f", $actual_reduction_cores);

                if ($actual_reduction_cores > 0.0001)
                {
                    my $new_physc_after_reduction = $eff_p_base_numeric - $actual_reduction_cores;
                    $efficiency_factor_numeric = ($eff_p_base_numeric > 0.0001) ? ($new_physc_after_reduction / $eff_p_base_numeric) : 1.00;
                    
                    my $min_expected_eff_factor = 1 - $current_max_reduction_perc_val;
                    if ($efficiency_factor_numeric < ($min_expected_eff_factor - 0.001) ) {$efficiency_factor_numeric = $min_expected_eff_factor;}
                    $efficiency_factor_numeric = 1.00 if $efficiency_factor_numeric > 1.00; # Should not be > 1
                    $efficiency_factor_numeric = max(0, $efficiency_factor_numeric); # Ensure not negative

                    $debug_info{'EffCalculatedFactor'} = sprintf("%.4f", $efficiency_factor_numeric);
                    $debug_info{'EffFinalFactorApplied'} = sprintf("%.2f", $efficiency_factor_numeric);
                    $debug_info{'EffFactorReason'} = sprintf("Analytical (using blended target & dynamic cap): Reduction of %.4f cores applied.", $actual_reduction_cores);
                }
                else
                {
                    $debug_info{'EffFinalFactorApplied'} = "1.00"; # No reduction, factor is 1.00
                    $debug_info{'EffCalculatedFactor'} = "1.0000";
                    $debug_info{'EffFactorReason'} = sprintf("Analytical (using blended target & dynamic cap): Base_PhysC %.4f, Blended_Target %.4f. Calculated reduction (%.4f) negligible or zero. No adjustment from this path.",
                                                             $eff_p_base_numeric, $blended_efficient_target, $actual_reduction_cores // 0.0);
                }
            }
            else # Base PhysC not greater than blended target
            {
                 $debug_info{'EffFinalFactorApplied'} = "1.00";
                 $debug_info{'EffCalculatedFactor'} = "1.0000";
                 $debug_info{'EffFactorReason'} = sprintf("Analytical: Base_PhysC %.4f not greater than Blended_Efficient_Target_PhysC %.4f. No reduction. Blending Reason: %s",
                                                         $eff_p_base_numeric, $blended_efficient_target, $blending_details_str);
            }
        } # End of main analytical efficiency block
    }
    elsif ($analytical_efficiency_path_attempted && $debug_info{'EffFactorReason'} eq "Efficiency calculation not initiated or skipped by initial guards.")
    {
        $debug_info{'EffFactorReason'} = "Key metrics (NormP50/P90, AbsRunQ) N/A for full analytical efficiency check. No efficiency adjustment applied.";
    }
    # If $analytical_efficiency_path_attempted was false, the original skip reason from guards remains.

    $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor_numeric);

    my $base_adjusted_physc = (defined $eff_p_base_numeric ? $eff_p_base_numeric : 0) * $efficiency_factor_numeric;
    $debug_info{'BaseAdjustedPhysC'} = sprintf("%.4f", $base_adjusted_physc);
    # --- End of Enhanced Efficiency Factor Logic ---

    # Proceed with pressure and additive logic only if essential metrics are available
    unless (defined $abs_runq_p_numeric && $smt_used > 0 && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) )
    {
        $debug_info{'ReasonForNoModification'} = ($debug_info{'ReasonForNoModification'} eq "") 
            ? "Missing essential RunQ or contextual metrics for further modifier logic after efficiency step." 
            : $debug_info{'ReasonForNoModification'}; # Preserve earlier reason if any
        $debug_info{'VoltFactorReason'} = "Skipped: " . ($debug_info{'ReasonForNoModification'} || "Essential metrics N/A for additive logic");
        $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BaseAdjustedPhysC'}; # Value after efficiency is final
        return ($base_adjusted_physc, \%debug_info);
    }

    # --- Step 2: Pressure Assessment (RunQ and Workload) ---
    my $runq_pressure_p_val = 0;
    if ($max_cpu_for_lpar_numeric > 0 && $smt_used > 0)
    {
        $runq_pressure_p_val = $abs_runq_p_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
    }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p_val);
    my $is_runq_pressure = ($runq_pressure_p_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False";

    my $is_workload_pressure_calc = 0;
    my $workload_pressure_reason_str_calc = "Workload pressure conditions not met or inputs N/A.";
    my $min_absrunq_for_workload_pressure_check = $smt_used;

    if (defined $norm_p90_numeric)
    {
        if ($norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
        {
            if (defined $abs_runq_p_numeric && $abs_runq_p_numeric >= $min_absrunq_for_workload_pressure_check)
            {
                $is_workload_pressure_calc = 1;
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f) AND AbsRunQ (%s=%.2f) >= SMT-based min threshold (%.2f)",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $debug_info{AbsRunQKeyUsed}, $abs_runq_p_numeric,
                                                      $min_absrunq_for_workload_pressure_check);
            }
            else
            {
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f), BUT AbsRunQ (%s=%.2f) < SMT-based min threshold (%.2f). Workload Pressure NOT flagged.",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $debug_info{AbsRunQKeyUsed}, $abs_runq_p_numeric // $na_str,
                                                      $min_absrunq_for_workload_pressure_check);
            }
        }
        else
        {
            $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) <= threshold (%.2f)",
                                                  $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
        }
    }
    else
    {
        $workload_pressure_reason_str_calc = "NormRunQ P90 N/A";
    }
    $debug_info{'IsWorkloadPressure'} = $is_workload_pressure_calc ? "True" : "False";
    $debug_info{'WorkloadPressureReason'} = $workload_pressure_reason_str_calc;

    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure_calc);

    # --- Step 3: Additive CPU Calculation ---
    my $additive_cpu = 0.0;
    my $raw_additive_cpu = 0.0;
    my $max_additive_cap_sliding = 0.0;
    my $capped_raw_additive_val = 0.0;
    my $volatility_confidence_factor = 1.0;
    my $pool_confidence_factor = 1.0;

    if ($apply_additive_logic)
    {
        # Effective LCPUs at the original base PhysC (before any efficiency adjustment)
        my $effective_lcpus_at_original_base = (defined $eff_p_base_numeric ? $eff_p_base_numeric : 0) * $smt_used;
        $debug_info{'EffectiveLCPUsAtBase'} = sprintf("%.4f", $effective_lcpus_at_original_base);

        my $capacity_threshold_for_excess = $RUNQ_ADDITIVE_TOLERANCE_FACTOR * $effective_lcpus_at_original_base;
        my $excess_threads = (defined $abs_runq_p_numeric ? $abs_runq_p_numeric : 0) - $capacity_threshold_for_excess;

        if ($excess_threads > 0)
        {
            $debug_info{'ExcessThreads'} = sprintf("%.4f (AbsRunQ %s %.2f > Tolerated Capacity %.2f based on %.1f x %.4f LCPUs)",
                                                   $excess_threads,
                                                   $debug_info{AbsRunQKeyUsed}, ($abs_runq_p_numeric // 0.0),
                                                   $capacity_threshold_for_excess,
                                                   $RUNQ_ADDITIVE_TOLERANCE_FACTOR,
                                                   $effective_lcpus_at_original_base);
            $raw_additive_cpu = $excess_threads / $smt_used if $smt_used > 0;

            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1)      { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; }
            else                                             { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }

            $capped_raw_additive_val = min($raw_additive_cpu, $max_additive_cap_sliding);

            if ($is_runq_pressure)
            {
                $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR;
                $debug_info{'VoltFactorReason'} = sprintf("RunQPressure Saturation (Factor set to %.2f)", $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR);
            }
            elsif ($is_workload_pressure_calc && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01)
            {
                my $volatility_ratio_for_factor = ($norm_p50_numeric > 0.01)
                                                 ? ($norm_p90_numeric / $norm_p50_numeric)
                                                 : 999; # Assign high ratio if P50 is very low (spiky)
                if ($volatility_ratio_for_factor < $VOLATILITY_SPIKY_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; }
                elsif ($volatility_ratio_for_factor < $VOLATILITY_MODERATE_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; }
                else { $volatility_confidence_factor = 1.0; }
                $debug_info{'VoltFactorReason'} = sprintf("Calculated (NormRQ P90/P50 ratio %.2f for WorkloadPressure -> Factor %.2f)", $volatility_ratio_for_factor, $volatility_confidence_factor);
            }
            else
            {
                 $debug_info{'VoltFactorReason'} = "Additive logic applied, but conditions for specific Volatility Factor adjustment not met (e.g., WorkloadPressure False or P50/P90 N/A for ratio). Using default factor.";
            }
            $additive_cpu = $capped_raw_additive_val * $volatility_confidence_factor;
            if ($is_in_non_default_pool && $additive_cpu > 0)
            {
                $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR;
                $additive_cpu *= $pool_confidence_factor;
            }
        }
        else
        {
            $debug_info{'ExcessThreads'} = sprintf("0.0000 (No excess above tolerated capacity of %.2f; AbsRunQ %s was %.2f)",
                                                   $capacity_threshold_for_excess,
                                                   $debug_info{AbsRunQKeyUsed}, ($abs_runq_p_numeric // $na_str));
            $raw_additive_cpu = 0.0;
            $capped_raw_additive_val = 0.0;
            $additive_cpu = 0.0;
            $debug_info{'VoltFactorReason'} = "No excess threads, so no additive CPU calculated.";
        }
    }
    else
    {
        $debug_info{'ExcessThreads'} = "N/A (Additive logic not applied as no significant pressure detected)";
        $debug_info{'VoltFactorReason'} = "Additive logic not applied.";
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu);
    $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding);
    $debug_info{'CappedRawAdditive'} = sprintf("%.4f", $capped_raw_additive_val);
    $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor);
    $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor);
    $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);

    # --- Step 4: Recommendation before MaxCPU Capping ---
    my $calculated_demand = $base_adjusted_physc + $additive_cpu;
    my $runq_modified_rec = $calculated_demand;
    $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    # --- Step 5: Final MaxCPU capping logic ---
    my $forecast_multiplier_val = 1.25;
    if ($curr_ent_numeric < 0.5)    { $forecast_multiplier_val = 2.5; }
    elsif ($curr_ent_numeric < 1.0) { $forecast_multiplier_val = 2.0; }
    elsif ($curr_ent_numeric < 2.0) { $forecast_multiplier_val = 1.75; }
    elsif ($curr_ent_numeric < 4.0) { $forecast_multiplier_val = 1.5; }
    $debug_info{'ForecastMultiplier'} = $forecast_multiplier_val;

    my $effective_max_cpu_cap_val = ($max_cpu_for_lpar_numeric > 0) ? ($max_cpu_for_lpar_numeric * $forecast_multiplier_val) : undef;
    $debug_info{'EffectiveMaxCPUCap'} = defined($effective_max_cpu_cap_val) ? sprintf("%.4f", $effective_max_cpu_cap_val) : $na_str;

    if (defined $effective_max_cpu_cap_val && $calculated_demand > $effective_max_cpu_cap_val)
    {
        $runq_modified_rec = $effective_max_cpu_cap_val;
        $debug_info{'CappedByMaxCPU'} = "True";
    }
    else
    {
      $debug_info{'CappedByMaxCPU'} = (defined $effective_max_cpu_cap_val) ? "False" : "N/A (No LPAR MaxCPU for cap check or MaxCPU not exceeded)";
    }

    if ($runq_modified_rec < 0) { $runq_modified_rec = 0; } # Ensure final recommendation is not negative
    $debug_info{'FinalAdjustedPhysC'} = sprintf("%.4f", $runq_modified_rec);

    return ($runq_modified_rec, \%debug_info);
}

# --- generate_sizing_hint (Unified Global Pressure Detection with Logging Rationale) ---
# Generates a sizing tier hint, pattern, and overall pressure indication for a VM.
# Also returns a detailed rationale string for its pressure assessment, AND
# specific boolean flags for P-99W1's RunQ pressure conditions.
sub generate_sizing_hint
{
    my %args = @_;
    my $results_ref                  = $args{'results_ref'};
    my $vm                           = $args{'vm'};
    my $config_ref                   = $args{'config_ref'};
    my $max_cpu_for_vm_numeric       = $args{'max_cpu_for_vm_numeric'} // 0;
    my $smt_used_for_vm_numeric      = $args{'smt_used_for_vm_numeric'} // 0;
    my $per_profile_runq_metrics_ref = $args{'per_profile_runq_metrics_ref'};

    # $MANDATORY_PEAK_PROFILE_FOR_HINT should be globally available or passed.
    # Example: my $MANDATORY_PEAK_PROFILE_FOR_HINT = "P-99W1"; (defined outside)

    my $na_str_hint = "N/A";
    my @global_pressure_rationale_lines;

    # ... (initial part of rationale logging: Inputs like MaxCPU, SMT etc. - as in previous version) ...
    push @global_pressure_rationale_lines, sprintf("  Input LPAR MaxCPU              : %.2f cores", $max_cpu_for_vm_numeric);
    push @global_pressure_rationale_lines, sprintf("  Input SMT for VM               : %d", $smt_used_for_vm_numeric);


    # --- VIO Server Check ---
    if (defined $config_ref &&
        defined $config_ref->{'systemtype'} &&
        $config_ref->{'systemtype'} =~ /VIO Server/i)
    {
        my $vio_rationale = join("\n", @global_pressure_rationale_lines);
        $vio_rationale .= "\n  VM identified as VIO Server. Standard pressure checks skipped for hint.\n  Hint set to P / VIO Server.";
        # Return dummy FALSE for P-99W1 specific RunQ pressures for VIOs
        return ("P", "VIO Server", 0, "VIO Server - Manual/Peak Sizing", $vio_rationale, 0, 0);
    }

    # --- Profile Value Parsing (Pattern/Peakiness & P-99W1 PhysC) ---
    my $o3_val_str = $results_ref->{$vm}{'O3-95W15'} // "0";
    my $o3_val_num = ($o3_val_str ne $na_str_hint && $o3_val_str =~ /^-?[0-9.]+\z/) ? ($o3_val_str + 0) : 0;
    my $b3_val_str = $results_ref->{$vm}{'B3-95W15'} // "0";
    my $b3_val_num = ($b3_val_str ne $na_str_hint && $b3_val_str =~ /^-?[0-9.]+\z/) ? ($b3_val_str + 0) : 0;
    my $g3_val_str = $results_ref->{$vm}{'G3-95W15'} // "0";
    my $g3_val_num = ($g3_val_str ne $na_str_hint && $g3_val_str =~ /^-?[0-9.]+\z/) ? ($g3_val_str + 0) : 0;
    my $p99w1_physc_val_str = $results_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT} // $na_str_hint;
    my $p99w1_physc_val_num = ($p99w1_physc_val_str ne $na_str_hint && $p99w1_physc_val_str =~ /^-?[0-9.]+\z/)
                           ? ($p99w1_physc_val_str + 0)
                           : 0;
    push @global_pressure_rationale_lines, sprintf("  Input %s PhysC Value  : %s (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_physc_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);

    # (Pattern and Peakiness logic - unchanged)
    my $suggested_pattern = "G";
    if ($b3_val_num > 0.01 && $o3_val_num > ($b3_val_num * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "O"; }
    elsif ($o3_val_num > 0.01 && $b3_val_num > ($o3_val_num * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "B"; }
    my $peakiness_ratio = ($g3_val_num > 0.001) ? ($p99w1_physc_val_num / $g3_val_num) : 0;
    my $shape_descriptor = "Steady";
    if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Very Peaky"; }
    elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Moderately Peaky"; }


    # --- Unified Pressure Detection ---
    my $pressure_detected_maxcpu_limit = 0;
    # Specific P-99W1 RunQ pressure flags to be returned
    my $p99w1_has_absolute_runq_pressure = 0;
    my $p99w1_has_normalized_runq_pressure = 0;
    my @pressure_points;

    # Fetch P-99W1's specific RunQ metrics
    my $p99w1_abs_runq_p90_val_str = $na_str_hint;
    my $p99w1_norm_runq_p90_val_str = $na_str_hint;
    # ... (logic to fetch $p99w1_abs_runq_p90_val_str and $p99w1_norm_runq_p90_val_str as before) ...
    # ... (logging of these input RunQ values to @global_pressure_rationale_lines as before) ...
    if (defined $per_profile_runq_metrics_ref &&
        exists $per_profile_runq_metrics_ref->{$vm} &&
        exists $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT})
    {
        my $p99w1_runq_metrics = $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT};
        $p99w1_abs_runq_p90_val_str = $p99w1_runq_metrics->{'AbsRunQ_P90'} // $na_str_hint;
        $p99w1_norm_runq_p90_val_str = $p99w1_runq_metrics->{'NormRunQ_P90'} // $na_str_hint;
    }
    push @global_pressure_rationale_lines, sprintf("  Input %s AbsRunQ P90    : %s threads (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);
    push @global_pressure_rationale_lines, sprintf("  Input %s NormRunQ P90   : %s (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_norm_runq_p90_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);
    push @global_pressure_rationale_lines, "";


    # 1. MaxCPU Limit Pressure
    # ... (logic as before, sets $pressure_detected_maxcpu_limit, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, "MaxCPU"; happens if $pressure_detected_maxcpu_limit = 1;) ...
    push @global_pressure_rationale_lines, sprintf("  1. MaxCPU Limit Pressure Check (%s PhysC vs LPAR MaxCPU):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for MaxCPU check)
    my $maxcpu_limit_calc_threshold = ($max_cpu_for_vm_numeric > 0) ? ($max_cpu_for_vm_numeric * $LIMIT_THRESHOLD_PERC) : 0;
    my $maxcpu_condition_met_str = "FALSE";
    if ($max_cpu_for_vm_numeric > 0 && $p99w1_physc_val_num >= $maxcpu_limit_calc_threshold)
    {
        $pressure_detected_maxcpu_limit = 1;
        $maxcpu_condition_met_str = "TRUE";
        push @pressure_points, "MaxCPU";
    }
    push @global_pressure_rationale_lines, sprintf("     - %s PhysC Value        : %.2f", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_physc_val_num);
    push @global_pressure_rationale_lines, sprintf("     - LPAR MaxCPU             : %.2f", $max_cpu_for_vm_numeric);
    push @global_pressure_rationale_lines, sprintf("     - Threshold (>= %.0f%%)      : %.2f cores", $LIMIT_THRESHOLD_PERC * 100, $maxcpu_limit_calc_threshold);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met           : (%.2f >= %.2f) -> %s", $p99w1_physc_val_num, $maxcpu_limit_calc_threshold, $maxcpu_condition_met_str);
    push @global_pressure_rationale_lines, sprintf("     - MaxCPU Pressure Flag    : %s", $maxcpu_condition_met_str);
    push @global_pressure_rationale_lines, "";


    # 2. Absolute RunQ Pressure (using P-99W1's AbsRunQ_P90)
    # ... (logic as before, sets $p99w1_has_absolute_runq_pressure, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, ... happens if $p99w1_has_absolute_runq_pressure = 1;) ...
    my $p99w1_abs_runq_p90_num = ($p99w1_abs_runq_p90_val_str ne $na_str_hint && $p99w1_abs_runq_p90_val_str =~ /^-?[0-9.]+$/) ? ($p99w1_abs_runq_p90_val_str + 0) : undef;
    my $calculated_abs_runq_pressure_ratio = 0;
    my $lpar_max_lcpu_capacity = ($max_cpu_for_vm_numeric > 0 && $smt_used_for_vm_numeric > 0) ? ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric) : 0;
    push @global_pressure_rationale_lines, sprintf("  2. Absolute RunQ Pressure Check (%s AbsRunQ P90 vs LPAR Capacity):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for AbsRunQ check)
    if (defined $p99w1_abs_runq_p90_num && $lpar_max_lcpu_capacity > 0)
    {
        $calculated_abs_runq_pressure_ratio = $p99w1_abs_runq_p90_num / $lpar_max_lcpu_capacity;
    }
    my $absrunq_cond_met_str = "FALSE";
    if ($calculated_abs_runq_pressure_ratio > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD)
    {
        $p99w1_has_absolute_runq_pressure = 1; # Set the specific flag
        $absrunq_cond_met_str = "TRUE";
        push @pressure_points, sprintf("RunQAbs_%s(P90=%.2f)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $calculated_abs_runq_pressure_ratio);
    }
    push @global_pressure_rationale_lines, sprintf("     - %s AbsRunQ P90      : %s threads", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - LPAR Max LCPU Capacity  : (%.2f MaxCPU * %d SMT) = %.2f threads", $max_cpu_for_vm_numeric, $smt_used_for_vm_numeric, $lpar_max_lcpu_capacity);
    push @global_pressure_rationale_lines, sprintf("     - Calculated Ratio        : %.4f", $calculated_abs_runq_pressure_ratio);
    push @global_pressure_rationale_lines, sprintf("     - Threshold               : > %.2f", $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met           : (%.4f > %.2f) -> %s", $calculated_abs_runq_pressure_ratio, $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD, $absrunq_cond_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s Specific Absolute RunQ Pressure Flag: %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $absrunq_cond_met_str);
    push @global_pressure_rationale_lines, "";


    # 3. Normalized Workload Pressure (using P-99W1's NormRunQ_P90)
    # ... (logic as before, sets $p99w1_has_normalized_runq_pressure, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, ... happens if $p99w1_has_normalized_runq_pressure = 1;) ...
    my $p99w1_norm_runq_p90_num = ($p99w1_norm_runq_p90_val_str ne $na_str_hint && $p99w1_norm_runq_p90_val_str =~ /^-?[0-9.]+$/) ? ($p99w1_norm_runq_p90_val_str + 0) : undef;
    my $min_abs_runq_for_norm_check = $smt_used_for_vm_numeric > 0 ? $smt_used_for_vm_numeric : 1.0;
    push @global_pressure_rationale_lines, sprintf("  3. Normalized Workload Pressure Check (%s NormRunQ P90):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for NormRunQ check)
    my $normrunq_cond1_met_str = (defined $p99w1_norm_runq_p90_num && $p99w1_norm_runq_p90_num > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD) ? "TRUE" : "FALSE";
    my $normrunq_cond2_met_str = (defined $p99w1_abs_runq_p90_num && $p99w1_abs_runq_p90_num >= $min_abs_runq_for_norm_check) ? "TRUE" : "FALSE";
    my $normrunq_overall_cond_met_str = "FALSE";
    if ($normrunq_cond1_met_str eq "TRUE" && $normrunq_cond2_met_str eq "TRUE")
    {
        $p99w1_has_normalized_runq_pressure = 1; # Set the specific flag
        $normrunq_overall_cond_met_str = "TRUE";
        push @pressure_points, sprintf("RunQNorm_%s(P90=%.2f)", $MANDATORY_PEAK_PROFILE_FOR_HINT, defined $p99w1_norm_runq_p90_num ? $p99w1_norm_runq_p90_num : 0);
    }
    push @global_pressure_rationale_lines, sprintf("     - %s NormRunQ P90     : %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_norm_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - Threshold               : > %.2f", $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met (Norm)    : (%s > %.2f) -> %s", $p99w1_norm_runq_p90_val_str, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD, $normrunq_cond1_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s AbsRunQ P90      : %s (for magnitude check)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - Min AbsRunQ Threshold   : %.2f (typically SMT)", $min_abs_runq_for_norm_check);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met (Mag)     : (%s >= %.2f) -> %s", $p99w1_abs_runq_p90_val_str, $min_abs_runq_for_norm_check, $normrunq_cond2_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s Specific Normalized Workload Pressure Flag: %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $normrunq_overall_cond_met_str);
    push @global_pressure_rationale_lines, "";


    # --- Combine pressure flags & Pool Context ---
    my $overall_pressure_detected_for_csv = $pressure_detected_maxcpu_limit ||
                                            $p99w1_has_absolute_runq_pressure || # Use the specific P-99W1 flags here for overall CSV flag
                                            $p99w1_has_normalized_runq_pressure;
    # ... (Pool context logic and $pressure_detail_str generation as before, using @pressure_points) ...
    push @global_pressure_rationale_lines, "  4. Pool Context:";
    my $pool_name_log = (defined $config_ref && defined $config_ref->{pool_name} && $config_ref->{pool_name} ne '') ? $config_ref->{pool_name} : $na_str_hint;
    my $is_non_default_pool_log_str = "FALSE";
    if (defined $config_ref && defined $config_ref->{pool_name} && lc($config_ref->{pool_name}) ne 'defaultpool' && $config_ref->{pool_name} ne '')
    {
        $is_non_default_pool_log_str = "TRUE";
        if ($overall_pressure_detected_for_csv)
        {
            push @pressure_points, "Pool(" . $config_ref->{'pool_name'} . ")"; # Removed '?'
        }
    }
    push @global_pressure_rationale_lines, sprintf("     - Pool Name               : %s", $pool_name_log);
    push @global_pressure_rationale_lines, sprintf("     - Is Non-Default Pool     : %s", $is_non_default_pool_log_str);
    push @global_pressure_rationale_lines, "";

    my $overall_pressure_detected_for_csv_str = $overall_pressure_detected_for_csv ? "TRUE" : "FALSE";
    my $pressure_detail_str = @pressure_points ? join(", ", @pressure_points) : "None";
    push @global_pressure_rationale_lines, sprintf("  5. Overall Global Hint Pressure Flag (for CSV): %s", $overall_pressure_detected_for_csv_str);
    push @global_pressure_rationale_lines, sprintf("  6. Final PressureDetail string for CSV     : \"%s\"", $pressure_detail_str);

    my $global_pressure_rationale_text = "Section G: Global Sizing Hint Pressure Assessment (source: generate_sizing_hint)\n" .
                                         join("\n", @global_pressure_rationale_lines);


    # --- Tiering logic (remains unchanged) ---
    my $initial_tier_range_str = "3/4";
    if ($shape_descriptor eq "Very Peaky") { $initial_tier_range_str = "1/2"; }
    elsif ($shape_descriptor eq "Moderately Peaky") { $initial_tier_range_str = "2/3"; }
    my $adjusted_tier_str = $initial_tier_range_str;
    if ($overall_pressure_detected_for_csv)
    {
        if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; }
        elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; }
        elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; }
    }
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str;

    return (
        $pattern_tier_string,
        $shape_descriptor,
        $overall_pressure_detected_for_csv, # This is for the CSV Pressure column
        $pressure_detail_str,
        $global_pressure_rationale_text,
        $p99w1_has_absolute_runq_pressure,    # NEW return value
        $p99w1_has_normalized_runq_pressure   # NEW return value
    );
}
# end of generate_sizing_hint

# --- parse_percentile_list_for_header ---
# This sub is used by the OLD global RunQ metric collection logic (which is now superseded
# by per-profile RunQ metrics). It might still be called if that logic path is hit,
# or could be refactored/removed if that path is fully deprecated.
# For now, keeping it as it might be used by initial population of $results_table{$vm_name}{$rq_metric_name}.
# It prepares percentile numbers for use as metric name suffixes.
sub parse_percentile_list_for_header
{
    my ($perc_str, $clean_zeros) = @_;
    $clean_zeros = 1 if !defined $clean_zeros; # Default to cleaning "X.00" to "X"
    my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100) # Validate numeric and range
            {
                my $p_label = $p;
                if ($clean_zeros)
                {
                    $p_label = sprintf("%.2f", $p); # Format to two decimal places
                    $p_label =~ s/\.?0+$//;         # Remove trailing ".00" or ".0"
                    $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00"); # Handle "0.00" -> "0"
                }
                push @percentiles_cleaned, $p_label;
            }
            else # Invalid percentile value
            {
                die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return \@percentiles_cleaned; # Return reference to array of cleaned percentile labels
}

# --- ensure_percentiles_requested ---
# Checks if a list of required percentiles are present in a given percentile string.
# Potentially used for validating if nfit was asked to calculate necessary percentiles
# for the old global RunQ metric collection. May be less relevant with per-profile logic.
sub ensure_percentiles_requested
{
    my ($perc_list_str, @required_percs) = @_; # perc_list_str is comma-separated, required_percs are numbers
    return 1 unless defined $perc_list_str && $perc_list_str ne ''; # If no list provided, assume not applicable or handled elsewhere

    # Parse the provided list string into a map for easy lookup
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0); # Get raw numbers, no zero cleaning for comparison
    my %present_map = map { $_ => 1 } @{$parsed_percs_ref};

    foreach my $req_p_num (@required_percs) # Iterate through numerically required percentiles
    {
        # Check if the numeric value (or its string representation) exists in the parsed list
        my $req_p_str = "$req_p_num"; # Simple string conversion
        my $req_p_str_formatted = sprintf("%.2f", $req_p_num); # e.g. 90.00
        my $req_p_str_cleaned = $req_p_str_formatted;
        $req_p_str_cleaned =~ s/\.?0+$//;
        $req_p_str_cleaned = "0" if $req_p_str_cleaned eq "" && abs($req_p_num -0) < 0.001;


        unless (exists $present_map{$req_p_str} || 
                exists $present_map{$req_p_str_formatted} || 
                exists $present_map{$req_p_str_cleaned} )
        {
            # Check common string representations due to potential formatting differences
            my $found = 0;
            foreach my $key (keys %present_map) {
                if (abs($key - $req_p_num) < 0.001) { # Floating point comparison
                    $found = 1;
                    last;
                }
            }
            return 0 unless $found; # Required percentile not found
        }
    }
    return 1; # All required percentiles found
}

# --- get_nfit_output_dp_from_flags ---
# Determines the number of decimal places nfit is expected to use for a profile's output,
# based on the rounding flags (-r or -u) passed to nfit for that profile.
# This helps nfit-profile format its *own* adjusted values consistently.
sub get_nfit_output_dp_from_flags
{
    my ($nfit_flags_str_for_this_run) = @_; # Combined global and profile-specific flags for nfit
    
    # Regex to find -r[=increment] or -u[=increment]
    # It captures the increment value if provided.
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/)
    {
        my $increment_val_str = $1 // $2; # $1 for -r=val, $2 for -u=val
        
        # If -r or -u is present but no increment value, nfit uses its default increment.
        if (!(defined $increment_val_str && $increment_val_str ne ""))
        {
            # nfit's default increment is $DEFAULT_ROUND_INCREMENT (from nfit.pl, assumed here to be same as nfit-profile's)
            # For robustness, it's better if nfit-profile knows nfit's default or this is coordinated.
            # Using nfit-profile's default as a proxy.
            return get_decimal_places($DEFAULT_ROUND_INCREMENT);
        }
        else # Increment value was specified
        {
            return get_decimal_places($increment_val_str);
        }
    }
    # If no -r or -u flag, nfit typically outputs with more precision (e.g., 4 decimal places by default internally).
    # nfit.pl version 2.28.0.4 defaults to 4 DP if no rounding.
    return 4; 
}

# --- get_decimal_places ---
# Calculates the number of decimal places in a given number string.
sub get_decimal_places
{
    my ($number_str) = @_;
    # Handle scientific notation by converting to fixed point string first
    $number_str = sprintf("%.15f", $number_str) if ($number_str =~ /e/i); 
    
    if ($number_str =~ /\.(\d+)$/) # If there's a decimal part
    {
        return length($1); # Length of the digits after decimal point
    }
    else # No decimal part
    {
        return 0;
    }
}

# --- usage_wrapper ---
# Generates and returns the usage/help message for the script.
sub usage_wrapper
{
    my $script_name = $0;
    $script_name =~ s{.*/}{}; # Get only script name, remove path
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [options]

Runs 'nfit' for multiple profiles. Applies RunQ modifiers and generates hints.
The RunQ modifier behavior (standard vs. additive-only) can be controlled
per profile via the 'runq_modifier_behavior' attribute in nfit.profiles.cfg.
Optionally passes flags to nfit for its internal windowed decay processing.
A detailed rationale log is written to $LOG_FILE_PATH.

Core Input:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
  --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --default-smt, --smt <N> : Optional. Default SMT level (Default: $DEFAULT_SMT_VALUE_PROFILE).

RunQ Metric Configuration (for nfit calls):
  --runq-norm-percentiles <list> : Global default for Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERCS").
                                   This list is combined with profile-specific settings and ensures P50,P90.
  --runq-abs-percentiles <list>  : Global default for Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERCS").
                                   This list is combined with profile-specific settings and ensures P90
                                   (and P<profile_physc_%> if --match-runq-perc-to-profile is used).
  --match-runq-perc-to-profile : Optional. If set, for RunQ additive logic, attempts to use AbsRunQ
                                   percentile matching the profile's PhysC -p <X> percentile
                                   (e.g., uses AbsRunQ_PX). Falls back to AbsRunQ_P90 if PX not available.
                                   Ensures nfit is asked to calculate PX if this option is used.

Configuration Files:
  -config <vm_cfg_csv>       : Optional. VM configuration CSV file.
  --profiles-config <path>   : Optional. Profiles definition file (INI format).
                               Can contain 'runq_modifier_behavior = additive_only' per profile,
                               and profile-specific 'nfit_flags' including --runq-norm-perc/--runq-abs-perc.

Filtering (Global or passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Global start date for analysis (passed to nfit).
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name (passed to nfit).

Control nfit's Internal Windowed Recency Decay (Optional):
  --nfit-enable-windowed-decay    : Enable nfit's internal windowed processing.
                                    (Requires nfit v2.28.0.4+ for full RunQ decay support)
  --nfit-process-window-unit <days|weeks> : Unit for nfit's window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT).
  --nfit-process-window-size <N>  : Size of nfit's window in units (Default: $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT).
  --nfit-decay-half-life-days <N> : Half-life for nfit's recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT).
  --nfit-analysis-reference-date <YYYY-MM-DD> : "Current" date for nfit's recency calculation
                                    (Default: nfit uses date of last record in its filtered NMON data).
  --nfit-runq-avg-method <none|sma|ema> : Averaging method for RunQ data within nfit before percentile.
                                          (Default: $DEFAULT_NFIT_RUNQ_AVG_METHOD). Uses main -w/--decay/--runq-decay from profile.

Rounding (Passed to nfit for its output):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Default increment: $DEFAULT_ROUND_INCREMENT)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are potentially recency-weighted by nfit & RunQ-modified by nfit-profile)...],
  Current_ENT,NFIT_ENT_UserFormula,NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
