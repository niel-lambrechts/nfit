#!/usr/bin/env perl

# NAME     : nfit-profile
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' multiple times with user-defined profiles.
#            Applies RunQ modifiers, generates hints, logs rationale, and aggregates to CSV.
# REQUIRES : Perl, nfit script (v2.28.0.4+), Time::Piece, List::Util, IO::File, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);
use Time::Piece;
use List::Util qw(sum sum0 min max); # sum0 is available from List::Util 1.33+
use Scalar::Util qw(looks_like_number);
use IO::File;
use version;

# --- Store original ARGV for logging ---
my @original_argv = @ARGV;

# --- Capture nfit-profile.pl start time ---
my $PROFILE_SCRIPT_START_TIME_EPOCH = time();
my $PROFILE_SCRIPT_START_TIME_STR = localtime($PROFILE_SCRIPT_START_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");

# --- Version ---
my $VERSION = '4.25.172.0';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90"; # Global default for nfit-profile if not in profile's flags
my $DEFAULT_RUNQ_ABS_PERCS  = "90";    # Global default for nfit-profile if not in profile's flags
my $DEFAULT_NFIT_RUNQ_AVG_METHOD = "ema";
my $DEFAULT_PERCENTILE = 95;

# Windowed Decay Defaults (for when nfit-profile instructs nfit to use its internal decay)
my $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT = 30;

# Heuristic Thresholds (for sizing hints and RunQ modifiers)
my $PATTERN_RATIO_THRESHOLD = 2.0;     # For O vs B pattern determination
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;   # For "Very Peaky" shape
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;   # For "Moderately Peaky" shape
my $LIMIT_THRESHOLD_PERC = 0.98;       # P99W1 vs MaxCPU for pressure detection

# RunQ Modifier Thresholds (for calculate_runq_modified_physc)
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 2.0; # NormRunQ P90 above this may indicate workload pressure
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 1.8;       # AbsRunQ P90 / (MaxCPU * SMT) above this indicates RunQ pressure
my $RUNQ_ADDITIVE_TOLERANCE_FACTOR = 1.8;               # Tolerate AbsRunQ up to this Factor x Base_Profile_PhysC's LCPU capacity

# Max_Additive_CPU Sliding Scale Thresholds (caps additive CPU based on current entitlement)
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;    # If Ent < 1.0, max add = 1.0 core
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;   # If Ent < 2.0, max add = 100% of Ent
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;  # If Ent < 4.0, max add = 75% of Ent
my $MAX_ADD_PERC_VAL_ELSE = 0.5;                             # Else, max add = 50% of Ent

# RunQ Volatility Confidence Factor Thresholds & Values (adjusts additive CPU based on P90/P50 RunQ ratio)
my $VOLATILITY_SPIKY_THRESHOLD = 0.5;    my $VOLATILITY_SPIKY_FACTOR = 0.70;    # Very stable/spiky, less confidence in adding CPU
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85; # Moderately stable
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0; # Full confidence if RunQ saturation is high

# --- Advanced Efficiency Adjustment Tunable Parameters ---
# Guard Rail for High Existing Constraint (CPU Downsizing Skip)
my $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD = 0.90; # If Base PhysC > 90% of MaxCPU
my $RUNQ_PRESSURE_FOR_CONSTRAINT_GUARD_FACTOR = 0.80;      # And RunQ Pressure > (this factor * saturation_threshold)

# Dynamic Blending Weights for Efficient Target (P_efficient_target_raw vs. BasePhysC)
my $NORM_P50_LOW_THRESH_FOR_BLEND1 = 0.25;       # If NormP50 < this, give more weight to raw target
my $BLEND_WEIGHT_BASE_FOR_LOW_P50_1 = 0.60;      #   60% Base / 40% Raw Target
my $NORM_P50_MODERATE_THRESH_FOR_BLEND2 = 0.40;  # If NormP50 < this (but >= BLEND1), moderate blend
my $BLEND_WEIGHT_BASE_FOR_LOW_P50_2 = 0.75;      #   75% Base / 25% Raw Target (original idea)
# If NormP50 >= MODERATE_THRESH_FOR_BLEND2 (but still low enough for efficiency consideration),
# lean more heavily on BasePhysC by default (e.g., 85% Base / 15% Target)
my $BLEND_WEIGHT_BASE_DEFAULT_LOW_P50 = 0.85;

# Volatility-Sensitive Cap for MAX_EFFICIENCY_REDUCTION_PERCENTAGE
# These thresholds are for Volatility Ratio (P90/P50)
my $VOLATILITY_MODERATE_LOW_CAP_THRESH = 1.2;  # Volatility above this starts to reduce the reduction cap
my $VOLATILITY_MODERATE_HIGH_CAP_THRESH = 1.8; # Volatility above this reduces cap more significantly
# Factors to scale down MAX_EFFICIENCY_REDUCTION_PERCENTAGE
my $REDUCTION_CAP_SCALE_FOR_MODERATE_VOLATILITY = 0.66; # e.g., 15% * 0.66 = ~10% max cut
my $REDUCTION_CAP_SCALE_FOR_MODERATE_HIGH_VOLATILITY = 0.33; # e.g., 15% * 0.33 = ~5% max cut

# --- Enhanced Efficiency Factor Constants (for calculate_runq_modified_physc) ---
my $VOLATILITY_CAUTION_THRESHOLD = 2.5; # If NormRunQ P90/P50 ratio >= this, skip efficiency reduction
my $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION = 0.5; # NormRunQ P50 must be below this to consider efficiency
my $MAX_EFFICIENCY_REDUCTION_PERCENTAGE  = 0.15; # Max % a profile can be reduced by efficiency logic
my $MIN_P50_DENOMINATOR_FOR_VOLATILITY = 0.1;    # Min P50 value to avoid division by zero in volatility calc
my $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC = 0.75; # Base, SMT-dependent adjustments in calc sub

# --- Hot Thread Workload (HTW) Additive Dampening Heuristics ---
# These constants are used to detect and dampen additive CPU for workloads
# that appear constrained (e.g., single-threaded) despite high normalized RunQ.
my $HOT_THREAD_WL_ENT_FACTOR = 0.80;    # BasePhysC < Entitlement * this_factor
my $HOT_THREAD_WL_MAXCPU_FACTOR = 0.25;   # OR BasePhysC < MaxCPU * this_factor
my $HOT_THREAD_WL_HIGH_NORM_P50_THRESHOLD = 3.0; # NormRunQ P50 > this_threshold
# RUNQ_PRESSURE_P90_SATURATION_THRESHOLD (1.8) is an existing constant, also used here.
my $HOT_THREAD_WL_IQRC_THRESHOLD = 1.0;    # NormRunQ_IQRC > this_threshold (tune based on data)
my $HOT_THREAD_WL_DETECTION_MIN_CONDITIONS_MET = 4; # Minimum number of detection conditions to be met

# Dynamic Dampening Multipliers for HTW
my $HOT_THREAD_WL_BASE_DAMPENING_FACTOR = 0.25; # Base factor for the dynamic dampening calculation
my $HOT_THREAD_WL_MIN_DYNAMIC_DAMPENING = 0.05; # Floor for the final dynamic dampening factor
my $HOT_THREAD_WL_MAX_DYNAMIC_DAMPENING = 0.75; # Ceiling for the final dynamic dampening factor

# Enhanced Safety Caps for Additive CPU (applied AFTER all other factors)
my $ADDITIVE_CPU_SAFETY_CAP_FACTOR_OF_BASE = 2.0; # Max additive CPU as a multiple of BasePhysC
my $ADDITIVE_CPU_SAFETY_CAP_ABSOLUTE = 0.5;       # Absolute maximum additive CPU in cores

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80; # Reduction factor for additive CPU if VM is in a non-default pool

my $LOG_FILE_PATH = "/tmp/nfit-profile.log"; # Default log file path

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak"; # Standardized name for the peak metric column in output

# --- Argument Parsing ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;                     # For nfit's -r (round to nearest)
my $roundup_arg;                   # For nfit's -u (round up)
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS; # Global default for nfit-profile itself
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;  # Global default for nfit-profile itself
my $match_runq_perc_to_profile = 0; # NEW: Flag to enable matching RunQ percentile to profile's PhysC percentile
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit"; # Default path to nfit script
my $nfit_enable_windowed_decay = 0;        # Flag to instruct nfit to use its internal decay
my $nfit_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT;
my $nfit_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT;
my $nfit_decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT;
my $nfit_analysis_reference_date_str;
my $nfit_runq_avg_method_str = $DEFAULT_NFIT_RUNQ_AVG_METHOD; # 'none', 'sma', 'ema' for nfit's RunQ processing
my $nfit_decay_over_states = 0;
my $nmon_dir;
my $excel_formulas_flag = "false";

GetOptions(
    'physc-data|pc=s'            => \$physc_data_file,
    'runq-data|rq=s'             => \$runq_data_file_arg,
    'nmondir=s'                  => \$nmon_dir,
    'config=s'                   => \$vm_config_file_arg,
    'profiles-config=s'          => \$profiles_config_file_arg,
    'startdate|s=s'              => \$start_date_str,
    'vm|lpar=s'                  => \$target_vm_name,
    'round|r:f'                  => \$round_arg,
    'roundup|u:f'                => \$roundup_arg,
    'default-smt|smt=i'          => \$default_smt_arg,
    'runq-norm-percentiles=s'    => \$runq_norm_perc_list_str,    # Global default list for NormRunQ
    'runq-abs-percentiles=s'     => \$runq_abs_perc_list_str,     # Global default list for AbsRunQ
    'match-runq-perc-to-profile' => \$match_runq_perc_to_profile, # NEW FLAG
    'help|h'                     => \$help,
    'nfit-path=s'                => \$nfit_script_path,
    'version|v'                  => \$show_version,
    'enable-windowed-decay'      => \$nfit_enable_windowed_decay,
    'process-window-unit=s'      => \$nfit_window_unit_str,
    'process-window-size=i'      => \$nfit_window_size_val,
    'decay-half-life-days=i'     => \$nfit_decay_half_life_days_val,
    'analysis-reference-date=s'  => \$nfit_analysis_reference_date_str,
    'runq-avg-method=s'          => \$nfit_runq_avg_method_str,
    'decay-over-states'          => \$nfit_decay_over_states,
    'excel-formulas=s'           => \$excel_formulas_flag,
) or die usage_wrapper();

# --- Validation ---
my $nfit_ver = "N/A"; # Store nfit version
if ($show_version)
{
    print STDERR "nfit-profile version $VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver_output = `$nfit_script_path --version 2>&1`;
        my ($parsed_nfit_ver) = ($nfit_ver_output =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        if (defined $parsed_nfit_ver)
        {
            $nfit_ver = $parsed_nfit_ver;
            print STDERR "Uses nfit version: $nfit_ver\n";
            # Check nfit version compatibility for certain features
            my $required_nfit_ver_for_windowing = "2.27.0";
            my $required_nfit_ver_for_runq_avg_and_decay = "2.28.0.4";

            if ($nfit_enable_windowed_decay && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_windowing))
            {
                print STDERR "Warning: --enable-windowed-decay requires nfit version $required_nfit_ver_for_windowing or higher. Your nfit version ($nfit_ver) may not support this.\n";
            }
            if (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none' && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_runq_avg_and_decay))
            {
                 print STDERR "Warning: --runq-avg-method (sma/ema) may require nfit features from version $required_nfit_ver_for_runq_avg_and_decay or higher. Your nfit version ($nfit_ver) behavior might differ for RunQ processing, especially if --runq-decay is intended.\n";
            }
        }
        else
        {
            print STDERR "Could not determine nfit version from output: $nfit_ver_output\n";
            if ($nfit_enable_windowed_decay || (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none'))
            {
                print STDERR "Warning: Advanced nfit features are enabled but nfit version cannot be verified.\n";
            }
        }
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}

# --- Validation ---
if ($help || (!$physc_data_file && !$nmon_dir))
{
    print STDERR usage_wrapper();
    exit 0;
}

if ($nmon_dir)
{
    if ($physc_data_file || $runq_data_file_arg)
    {
        die "Error: --nmondir cannot be used with --physc-data or --runq-data.\n";
    }
    unless (-d $nmon_dir)
    {
        die "Error: Provided --nmondir path is not a valid directory: $nmon_dir\n";
    }
}
elsif ($physc_data_file)
{
    if (! -f $physc_data_file)
    {
        die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n";
    }
}
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg)
{
    die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n";
}
if ($default_smt_arg <= 0)
{
    die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n";
}
if (! -x $nfit_script_path)
{
    die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n";
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}

# Validations for nfit's windowed decay options, if enabled by nfit-profile
if ($nfit_enable_windowed_decay && $nfit_decay_over_states)
{
    die "Error: --enable-windowed-decay and --decay-over-states are mutually exclusive analysis modes.\n";
}
if ($nfit_enable_windowed_decay)
{
    if ($nfit_window_unit_str ne "days" && $nfit_window_unit_str ne "weeks")
    {
        die "Error: --process-window-unit must be 'days' or 'weeks'.\n";
    }
    if ($nfit_window_size_val < 1)
    {
        die "Error: --process-window-size must be at least 1.\n";
    }
    if ($nfit_decay_half_life_days_val < 1)
    {
        die "Error: --decay-half-life-days must be at least 1.\n";
    }
    if (defined $nfit_analysis_reference_date_str && $nfit_analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
    {
        die "Error: Invalid --analysis-reference-date format. Use YYYY-MM-DD.\n";
    }
    print STDERR "nfit's internal windowed decay processing is enabled via nfit-profile.\n";
}

# Validate nfit's RunQ averaging method, if specified
if (defined $nfit_runq_avg_method_str)
{
    $nfit_runq_avg_method_str = lc($nfit_runq_avg_method_str);
    unless ($nfit_runq_avg_method_str eq 'none' || $nfit_runq_avg_method_str eq 'sma' || $nfit_runq_avg_method_str eq 'ema')
    {
        die "Error: --runq-avg-method must be 'none', 'sma', or 'ema'. Got '$nfit_runq_avg_method_str'.\n";
    }
    print STDERR "Instructing nfit to use RunQ averaging method: $nfit_runq_avg_method_str.\n";
}

# --- Excel Formula Validation ---
my $add_excel_formulas = 1; # Default to on
if (defined $excel_formulas_flag)
{
    my $val = lc($excel_formulas_flag);
    if ($val eq 'true' || $val eq '1')
    {
        $add_excel_formulas = 1;
    }
    elsif ($val eq 'false' || $val eq '0')
    {
        $add_excel_formulas = 0;
    }
    else
    {
        die "Error: Invalid value for --excel-formulas. Must be 'true' or 'false'.\n";
    }
}

# --- Open Log File ---
my $LOG_FH = IO::File->new($LOG_FILE_PATH, '>')
    or warn "Error: Cannot open rationale log file '$LOG_FILE_PATH' for writing: $!. Rationale logging will be skipped.\n";

if ($LOG_FH)
{
    $LOG_FH->autoflush(1); # Ensure immediate writing to log
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nFit Profile Rationale Log\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nfit-profile.pl Run Started: $PROFILE_SCRIPT_START_TIME_STR\n";
    print {$LOG_FH} "nfit-profile.pl Version  : $VERSION\n";

    # Log nfit version used (attempt again if not already fetched by --version flag)
    if ($nfit_ver eq "N/A" && -x $nfit_script_path)
    {
        my $nfit_ver_output_log = `$nfit_script_path --version 2>&1`;
        my ($parsed_nfit_ver_log) = ($nfit_ver_output_log =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        $nfit_ver = $parsed_nfit_ver_log // "Unknown (parse failed)";
    }
    print {$LOG_FH} "nfit.pl Version Used     : $nfit_ver\n";

    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Invocation:\n";
    my @quoted_original_argv_log = map { $_ =~ /\s/ ? qq/"$_"/ : $_ } @original_argv;
    print {$LOG_FH} "  $0 " . join(" ", @quoted_original_argv_log) . "\n";
    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Key Global Settings:\n";
    if ($nmon_dir) {
        print {$LOG_FH} "  - NMON Directory Input     : $nmon_dir\n";
    } else {
        print {$LOG_FH} "  - PhysC Data File          : $physc_data_file\n";
        print {$LOG_FH} "  - RunQ Data File           : " . ($runq_data_file_arg // "Not Provided") . "\n";
    }
    print {$LOG_FH} "  - Match RunQ Perc to Profile : " . ($match_runq_perc_to_profile ? "Enabled" : "Disabled (Using AbsRunQ_P90 default for additive logic)") . "\n"; # Log new option
}

# --- Load Profile Definitions ---
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else # Attempt to find default profiles config
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE"; # Try in script's root
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
if ($LOG_FH) { print {$LOG_FH} "  - Profiles Config File     : $profiles_config_path_to_load\n"; }
@profiles = load_profile_definitions($profiles_config_path_to_load);
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}

# This profile's CPU value is used for MaxCPU pressure checks,
# and its RunQ metrics will now be used for global RunQ pressure hints.
my $MANDATORY_PEAK_PROFILE_FOR_HINT = "P-99W1";

# --- Ensure the Mandatory P-99W1 Profile is Defined ---
# This check occurs after profiles are loaded.
my $mandatory_profile_is_present = 0;
foreach my $profile_entry (@profiles)
{
    if (defined $profile_entry->{name} && $profile_entry->{name} eq $MANDATORY_PEAK_PROFILE_FOR_HINT)
    {
        $mandatory_profile_is_present = 1;
        last;
    }
}

unless ($mandatory_profile_is_present)
{
    die "ERROR: Mandatory profile \"$MANDATORY_PEAK_PROFILE_FOR_HINT\" is not defined in the profiles configuration file: '$profiles_config_path_to_load'.\n" .
        "       This profile is essential for core pressure detection logic in nfit-profile.\n" .
        "       Please add a profile named \"$MANDATORY_PEAK_PROFILE_FOR_HINT\" to your profiles configuration.\n";
}

print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";

# --- Locate and Load VM Configuration Data ---
# This data provides SMT, MaxCPU, Entitlement, etc., per VM.
my $vm_config_file_path = undef;
my $vm_config_found = 0;
my %vm_config_data;         # Stores parsed VM config: $vm_config_data{hostname}{key} = value
my %vm_config_col_idx;      # Maps column names (lowercase) to their index in the CSV
my $vm_config_header_count = 0; # Number of columns in VM config header

if (defined $vm_config_file_arg) # User specified a VM config file
{
    if (-f $vm_config_file_arg)
    {
        $vm_config_file_path = $vm_config_file_arg;
        $vm_config_found = 1;
        print STDERR "Using specified VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n";
    }
}
else # No VM config file specified, try default locations
{
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE";  # Default path: script_dir/etc/
    my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE"; # Alternative path: script_dir/
    if (-f $dp_etc)
    {
        $vm_config_file_path = $dp_etc;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    elsif (-f $dp_root)
    {
        $vm_config_file_path = $dp_root;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        if ($nmon_dir) {
            # Message for the modern, self-sufficient --nmondir mode
            print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM metadata columns 'SystemType' and 'Pool Name' will be blank. Dynamically sourcing SMT and MaxCPU from NMON.\n";
        } else {
            # Original message for the legacy --pc / --rq modes
            print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n";
        }
    }
}
if ($LOG_FH) { print {$LOG_FH} "  - VM Config File           : " . ($vm_config_file_path // "Not Provided/Default Attempted") . "\n"; }

if ($vm_config_found)
{
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>; # Read header line
    unless (defined $hdr)
    {
        die "Error: Could not read header from VM config '$vm_config_file_path'\n";
    }
    chomp $hdr;
    $hdr =~ s/\r$//;        # Remove CR if present (Windows line endings)
    $hdr =~ s/^\x{FEFF}//;  # Remove BOM if present (UTF-8 Byte Order Mark)
    my @rhdrs = split /,/, $hdr;
    $vm_config_header_count = scalar @rhdrs;
    my %hmap; # Map lowercase header name to index
    for my $i (0 .. $#rhdrs)
    {
        my $cn = $rhdrs[$i];
        $cn =~ s/^\s*"?|"?\s*$//g; # Trim spaces and quotes from column name
        if ($cn ne '')
        {
            $hmap{lc($cn)} = $i; # Store lowercase column name
        }
    }

    # Check for required columns
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'}; # Check if SMT column exists
    unless (exists $hmap{'maxcpu'})
    {
        warn "Warning: 'maxcpu' column not found in VM config. Final MaxCPU capping logic will be affected.\n";
    }
    if ($has_smt_col)
    {
        print STDERR "Found 'SMT' column in VM configuration file.\n";
    }
    else
    {
        print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n";
    }

    foreach my $rc (@req_cols)
    {
        unless (exists $hmap{$rc})
        {
            die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n";
        }
        $vm_config_col_idx{$rc} = $hmap{$rc};
    }
    if ($has_smt_col) # If SMT column exists, store its index
    {
        $vm_config_col_idx{'smt'} = $hmap{'smt'};
    }

    # Read data lines from VM config
    while (my $ln = <$cfg_fh>)
    {
        chomp $ln;
        $ln =~ s/\r$//;
        next if $ln =~ /^\s*$/; # Skip empty lines

        # Attempt to parse CSV with quoted fields (handles commas within quotes)
        my @rvals = ($ln =~ /"([^"]*)"/g);
        if (scalar @rvals != $vm_config_header_count)
        { # Fallback to simple comma split if quote parsing fails or count mismatches
            @rvals = split /,/, $ln;
            if (scalar @rvals != $vm_config_header_count)
            {
                warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n";
                next;
            }
            # Trim whitespace for values from simple split
            $_ =~ s/^\s+|\s+$//g for @rvals;
        }
        # Else, if quote parsing worked, values in @rvals are already unquoted and trimmed by regex.

        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ]; # Get hostname
        if (defined $hn && $hn ne '')
        {
            my $smt_v = $default_smt_arg; # Default SMT value
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '')
            {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/) # Extract trailing digits for SMT value (e.g., "SMT4" -> 4)
                {
                    $smt_v = $1;
                    if ($smt_v <= 0) # Validate SMT
                    {
                        warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                        $smt_v = $default_smt_arg;
                    }
                }
                else
                {
                    warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                }
            }

            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            # Validate MaxCPU value
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0)
            {
                $max_cpu_val = 0; # Default to 0 if invalid, meaning no effective MaxCPU cap from config
            }

            # Store parsed VM config data
            $vm_config_data{$hn} = {
                serial      => $rvals[$vm_config_col_idx{'serial'}],
                systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name   => $rvals[$vm_config_col_idx{'procpool_name'}],
                pool_id     => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}],
                maxcpu      => ($max_cpu_val + 0), # Store as number
                smt         => $smt_v,
            };
        }
        else # Hostname missing or empty
        {
            warn "Warning: Missing hostname on VM config line $. Skipping.\n";
        }
    }
    close $cfg_fh;
    print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
}
else # VM config file not found or not specified
{
     print STDERR "Warning: VM configuration file not loaded. MaxCPU capping logic will be affected, and SMT will use default.\n";
}

# --- Construct Common Flags for nfit ---
# These flags are common to ALL nfit runs initiated by nfit-profile.
# Note: RunQ percentile flags (--runq-norm-perc, --runq-abs-perc) are now handled PER PROFILE run.
my $common_nfit_flags_base = "-q";
if ($nmon_dir)
{
    $common_nfit_flags_base .= " -k --nmondir \"$nmon_dir\"";
    # When using --nmondir, runq data comes from within the NMON files, so --runq-data is not used.
    # However, we still need to pass the RunQ averaging method to nfit if specified.
    if (defined $nfit_runq_avg_method_str)
    {
        $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
    }
}
else # The original path using --physc-data
{
    $common_nfit_flags_base .= " -k --physc-data \"$physc_data_file\"";
    if (defined $runq_data_file_arg)
    {
        $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
        if (defined $nfit_runq_avg_method_str)
        {
            $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
        }
    }
}
if (defined $start_date_str) # Global start date for all nfit runs
{
    $common_nfit_flags_base .= " -s $start_date_str";
}

# Common rounding flags (passed to nfit for its output formatting)
my $rounding_flags_for_nfit = ""; # These are applied by nfit itself
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/) # Check if round_arg has a value (e.g. -r=0.1)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/) # Check if roundup_arg has a value (e.g. -u=0.1)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit; # Add rounding to common flags if specified

# Common nfit windowing/decay flags (if nfit-profile is instructing nfit to use its internal decay)
my $nfit_windowing_decay_flags = "";
if ($nfit_enable_windowed_decay)
{
    $nfit_windowing_decay_flags .= " --enable-windowed-decay";
    $nfit_windowing_decay_flags .= " --process-window-unit \"$nfit_window_unit_str\"";
    $nfit_windowing_decay_flags .= " --process-window-size $nfit_window_size_val";
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
elsif ($nfit_decay_over_states)
{
    # Pass through the flag for the new Hybrid State-Time Decay Model.
    $nfit_windowing_decay_flags .= " --decay-over-states";
    # Also pass through the recency parameters it requires.
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
$common_nfit_flags_base .= $nfit_windowing_decay_flags; # Add windowing/decay to common flags if enabled

# Log common flags (updated to reflect that runq percentiles are now per-profile)
if ($LOG_FH)
{
    print {$LOG_FH} "  - nfit Common Base Flags   : $common_nfit_flags_base (RunQ percentiles determined per profile)\n";
    print {$LOG_FH} "  - nfit Windowed Decay Opts : " . ($nfit_windowing_decay_flags ne "" ? $nfit_windowing_decay_flags : "Not Enabled") . "\n";
    print {$LOG_FH} "  - nfit RunQ Avg Method     : $nfit_runq_avg_method_str\n";
    print {$LOG_FH} "  - Default SMT for Profile  : $default_smt_arg\n";
    print {$LOG_FH} "======================================================================\n\n";
    print {$LOG_FH} "===== Per-VM / Per-Profile RunQ Adjustment Details =====\n\n";
}

# --- Main Logic: Run nfit Profiles ---
my %results_table; # Stores PhysC values from nfit for each profile: $results_table{vm_name}{profile_name}
my @vm_order;      # To maintain CSV output order consistent with first nfit run that reports VMs
my %vm_seen;       # Tracks VMs seen to populate @vm_order correctly
my %primary_runq_metrics_captured_for_vm; # Tracks if global P50/P90 RunQ metrics captured for hints
my %source_profile_for_global_runq; # Which profile's output sourced the global RunQ P50/P90 for hints
my %per_profile_runq_metrics; # Stores ALL RunQ metrics (e.g. AbsRunQ_P80, AbsRunQ_P98) from EACH profile's nfit run
                              # Structure: $per_profile_runq_metrics{vm_name}{profile_name}{runq_metric_key}
my %per_profile_nfit_raw_results;

my %parsed_growth_adj_values;      # Stores GrowthAdj from nfit output
my %parsed_growth_adj_abs_values;  # Stores GrowthAdjAbs from nfit output
my $FLOAT_EPSILON          = 1e-9;

print STDERR "nfit-profile version $VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles) # Iterate through each profile defined in nfit.profiles.cfg
{
    my $profile_name = $profile->{name};
    my $profile_runq_behavior = $profile->{runq_behavior} // 'default'; # Default RunQ modifier behavior if not in config

    # Determine Profile's PhysC Percentile (e.g., value X from -p X in profile's flags)
    # This is used for:
    # 1. Extracting the correct PhysC metric from nfit's output (e.g., P98=value).
    # 2. Optionally matching the AbsRunQ percentile if --match-runq-perc-to-profile is set.
    my $profile_physc_perc_val_num;
    if ($profile->{flags} =~ /(?:-p|--percentile)\s+([0-9.]+)/)
    {
        $profile_physc_perc_val_num = $1 + 0; # Store as number
    }

    # --- Construct nfit command with dynamically determined RunQ percentile flags for THIS profile run ---

    my $profile_specific_flags_for_nfit_run = $profile->{flags};
    my $nfit_runq_related_flags_for_command = ""; # This will hold the final --runq-...-perc flags for this nfit call

    if (defined $runq_data_file_arg || defined $nmon_dir) # Check if any RunQ data source is available
    {
        # --- Handle Absolute RunQ Percentiles ---
        my @abs_percs_to_collate;
        if ($profile_specific_flags_for_nfit_run =~ /--runq-abs-perc\s+([^\s\'\"]+)/)
        {
            push @abs_percs_to_collate, split(/,/, $1);
        }
        push @abs_percs_to_collate, split(/,/, $runq_abs_perc_list_str);
        push @abs_percs_to_collate, 90;
        if ($match_runq_perc_to_profile && defined $profile_physc_perc_val_num)
        {
            push @abs_percs_to_collate, $profile_physc_perc_val_num;
        }
        $profile_specific_flags_for_nfit_run =~ s/--runq-abs-perc\s+[^\s\'\"]+//g;
        my %seen_abs;
        my @unique_abs_percs = sort {$a <=> $b} grep { looks_like_number($_) && !$seen_abs{$_}++ } @abs_percs_to_collate;
        if (@unique_abs_percs)
        {
            $nfit_runq_related_flags_for_command .= " --runq-abs-perc '" . join(",", @unique_abs_percs) . "'";
        }

        # --- Handle Normalized RunQ Percentiles ---
        my @norm_percs_to_collate;
        if ($profile_specific_flags_for_nfit_run =~ /--runq-norm-perc\s+([^\s\'\"]+)/)
        {
            push @norm_percs_to_collate, split(/,/, $1);
        }
        push @norm_percs_to_collate, split(/,/, $runq_norm_perc_list_str);
        push @norm_percs_to_collate, (25, 50, 75, 90);
        $profile_specific_flags_for_nfit_run =~ s/--runq-norm-perc\s+[^\s\'\"]+//g;
        my %seen_norm;
        my @unique_norm_percs = sort {$a <=> $b} grep { looks_like_number($_) && !$seen_norm{$_}++ } @norm_percs_to_collate;
        if (@unique_norm_percs)
        {
            $nfit_runq_related_flags_for_command .= " --runq-norm-perc '" . join(",", @unique_norm_percs) . "'";
        }
    }

    my $formatted_run_info = format_nfit_flags_for_display(
        $profile_name,
        $profile_specific_flags_for_nfit_run,
        $nfit_runq_related_flags_for_command,
        $profile_runq_behavior
    );
    print STDERR $formatted_run_info . "\n";

    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg"; # Default
    my $nfit_vm_flag_for_current_run = defined($target_vm_name) ? " -vm \"$target_vm_name\"" : "";

    # Note: With the new nfit, SMT is determined dynamically per state from NMON data.
    # The --smt flag now primarily serves as a fallback or for the legacy CSV mode.
    # The complex per-VM SMT lookup from config is no longer needed here.

    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags_for_nfit_run $nfit_runq_related_flags_for_command";

    my $raw_nfit_output = `$command`;
    my $exit_status = $? >> 8;

    if ($exit_status != 0)
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Command was: $command. Output: $raw_nfit_output. Skip.\n";
        if ($LOG_FH)
        {
             print {$LOG_FH} "ERROR: nfit.pl execution FAILED for profile '$profile_name' on VM(s) '". ($target_vm_name // "All") ."'.\n";
             print {$LOG_FH} "  Command: $command\n";
             print {$LOG_FH} "  Exit Status: $exit_status\n";
             my $short_output = substr($raw_nfit_output, 0, 1000) . (length($raw_nfit_output) > 1000 ? "..." : ""); # Log first 1KB of output
             print {$LOG_FH} "  Output (first 1000 chars): $short_output\n";
        }
        next; # Skip to the next profile in the loop
    }

    # --- NEW ASSIMILATION LOGIC ---
    my $parsed_nfit_results = parse_nfit_key_value_output($raw_nfit_output);


    foreach my $vm_name (sort keys %{$parsed_nfit_results})
    {
        unless ($vm_seen{$vm_name}++) {
            push @vm_order, $vm_name;
        }

        my @states_for_vm = @{$parsed_nfit_results->{$vm_name}};
        $per_profile_nfit_raw_results{$vm_name}{$profile_name} = \@states_for_vm; # Store for logging

        next unless @states_for_vm; # Skip if no data for this VM

        my $p_metric_key = "P" . clean_perc_label($profile_physc_perc_val_num // $DEFAULT_PERCENTILE);
        my @valid_p_values;
        foreach my $state (@states_for_vm) {
            if (defined $state->{$p_metric_key} && looks_like_number($state->{$p_metric_key})) {
                push @valid_p_values, $state->{$p_metric_key};
            }
        }

        my $base_physc_for_profile = "N/A";
        if (@valid_p_values) {
            # Simple, unweighted average as per design for multi-state results
            $base_physc_for_profile = sum0(@valid_p_values) / scalar(@valid_p_values);
        }

        $results_table{$vm_name}{$profile_name} = $base_physc_for_profile;

        # --- Data Capture for Sizing Hints and Modifiers ---
        # For hints, we always use the MOST RECENT state from the P-99W1 profile run.
        if ($profile_name eq $MANDATORY_PEAK_PROFILE_FOR_HINT)
        {
            my $most_recent_state = $states_for_vm[-1]; # The last state in the time-sorted list

            # Capture Peak value from the most recent state
            $results_table{$vm_name}{$PEAK_PROFILE_NAME} = $most_recent_state->{'Peak'} // "N/A";

            # Capture RunQ metrics from the most recent state for global hints
            $per_profile_runq_metrics{$vm_name}{$profile_name} = $most_recent_state;

            # This logic below is now simplified, as we just grab the values from the hash
            my %first_capture_target_keys = ( 'NormRunQ_P50' => 1, 'NormRunQ_P90' => 1, 'AbsRunQ_P90'  => 1 );
            foreach my $key (keys %first_capture_target_keys) {
                if (!$primary_runq_metrics_captured_for_vm{$vm_name}{$key}) {
                    $results_table{$vm_name}{$key} = $most_recent_state->{$key} // "N/A";
                    $primary_runq_metrics_captured_for_vm{$vm_name}{$key} = 1;
                    $source_profile_for_global_runq{$vm_name} //= $profile_name;
                }
            }
        }
        else {
             # For other profiles, we still need to store their RunQ metrics for their own modifications
             # We'll use the most recent state's metrics for this as well for consistency.
             $per_profile_runq_metrics{$vm_name}{$profile_name} = $states_for_vm[-1];
        }
    }

} # End foreach profile
print STDERR "Finished nfit profile runs. Generating CSV output and rationale log...\n";

# --- Generate CSV Output ---
my @output_header_cols_csv;
# Define the order of columns for the CSV output
@output_header_cols_csv = (
    "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT",
    "Serial", "SystemType", "Pool Name", "Pool ID", $PEAK_PROFILE_NAME
);
# Add profile names as column headers (these will contain the RunQ-modified PhysC values)
push @output_header_cols_csv, map { $_->{name} } @profiles;
# Add entitlement and formula placeholder columns
push @output_header_cols_csv, ("Current - ENT", "NFIT - ENT", "NETT", "NETT%");
print STDOUT join(",", map { quote_csv($_) } @output_header_cols_csv) . "\n"; # Print CSV header

my $excel_row_num_counter = 1; # Excel rows are 1-based; header is row 1, so first data row is 2.

# Iterate through VMs in sorted order
foreach my $vm_name (sort @vm_order)
{
    $excel_row_num_counter++; # Increment for current data row number in Excel sheet.

    my @data_row_csv; # Holds data for the current VM's CSV row
    my $cfg_csv = $vm_config_data{$vm_name}; # VM's config data from config-all.csv (if loaded)

    # Determine if the current VM is a VIO Server for logic branching
    my $is_vio_server = (
        defined $cfg_csv &&
        defined $cfg_csv->{'systemtype'} &&
        $cfg_csv->{'systemtype'} =~ /VIO Server/i
    );

# Determine authoritative SMT and MaxCPU to use for this VM's calculations/reporting
    # Precedence: nfit output (--nmondir) > config file (--config) > script default
    my $smt_used_for_vm_csv = $default_smt_arg;
    my $max_cpu_for_vm_csv  = 0; # Default to 0, indicating not found yet

    if ($nmon_dir) {
        # For --nmondir runs, the nfit output is the primary source of truth for configuration.
        # We use the results from the mandatory profile run as our reference.
        my $mandatory_profile_results_aref = $per_profile_nfit_raw_results{$vm_name}{$MANDATORY_PEAK_PROFILE_FOR_HINT};

        if (ref($mandatory_profile_results_aref) eq 'ARRAY' && @$mandatory_profile_results_aref) {
            # nfit reports states chronologically; the last state is the most recent one.
            my $last_state_data = $mandatory_profile_results_aref->[-1];

            if (defined $last_state_data->{'MaxCPU'} && looks_like_number($last_state_data->{'MaxCPU'}) && $last_state_data->{'MaxCPU'} > 0) {
                $max_cpu_for_vm_csv = $last_state_data->{'MaxCPU'};
            }
            if (defined $last_state_data->{'SMT'} && looks_like_number($last_state_data->{'SMT'}) && $last_state_data->{'SMT'} > 0) {
                $smt_used_for_vm_csv = $last_state_data->{'SMT'};
            }
        }
    }

    # --- Fallback Logic ---
    # If MaxCPU wasn't populated from nfit output (or if not in --nmondir mode), try the config file.
    if ($max_cpu_for_vm_csv == 0 && defined $cfg_csv && defined $cfg_csv->{maxcpu} && $cfg_csv->{maxcpu} > 0) {
        $max_cpu_for_vm_csv = $cfg_csv->{maxcpu};
    }

    # If SMT is still the script's default, try the config file as a fallback.
    if ($smt_used_for_vm_csv == $default_smt_arg && defined $cfg_csv && defined $cfg_csv->{smt}) {
        $smt_used_for_vm_csv = $cfg_csv->{smt};
    }

    # --- Generate Sizing Hint and get ACTUAL pressure details for ALL servers ---
    my ($hint_type_tier_csv, $hint_pattern_shape_csv, $hint_pressure_bool_csv, $pressure_detail_str_csv, $global_pressure_log_details_str, $p99w1_vm_has_abs_runq_pressure, $p99w1_vm_has_norm_runq_pressure) =
        generate_sizing_hint(
            'results_ref'              => \%results_table,
            'vm'                       => $vm_name,
            'config_ref'               => $cfg_csv,
            'max_cpu_for_vm_numeric'        => $max_cpu_for_vm_csv,
            'smt_used_for_vm_numeric'       => $smt_used_for_vm_csv,
            'per_profile_runq_metrics_ref'  => \%per_profile_runq_metrics
        );
    my $pressure_bool_str_csv = $hint_pressure_bool_csv ? "True" : "False";

    if ($LOG_FH)
    {
        print {$LOG_FH} "----------------------------------------------------------------------\n";
        print {$LOG_FH} "Global Sizing Hint Pressure Assessment (VM: $vm_name)\n";
        print {$LOG_FH} $global_pressure_log_details_str . "\n";
    }

    # --- Build the initial part of the CSV row ---
    push @data_row_csv, $vm_name,                   # VM (Column A)
                        "",                         # TIER (Column B, empty)
                        $hint_type_tier_csv,        # Hint (e.g., "G3" or "P" for VIO)
                        $hint_pattern_shape_csv,    # Pattern (e.g., "Steady" or "VIO Server")
                        $pressure_bool_str_csv,     # ACTUAL calculated Pressure
                        $pressure_detail_str_csv,   # ACTUAL calculated PressureDetail
                        $smt_used_for_vm_csv;       # SMT

    # --- intelligently source and add metadata to the CSV row ---
    my ($serial_out, $systype_out, $poolname_out, $poolid_out, $ent_out);

    # Primary Source: Use the --config file if it was loaded for this VM
    if (defined $cfg_csv) {
        $serial_out   = $cfg_csv->{serial} // '';
        $systype_out  = $cfg_csv->{systemtype} // '';
        $poolname_out = $cfg_csv->{pool_name} // '';
        $poolid_out   = $cfg_csv->{pool_id} // '';
        $ent_out      = $cfg_csv->{entitlement} // '';
    }
    # Fallback Source: If no config file, use data parsed from nfit.pl's output
    else {
        # Find the results from the last profile run that has data for this VM
        my $last_profile_with_results = (reverse grep { exists $per_profile_nfit_raw_results{$vm_name}{$_->{name}} } @profiles)[0];
        my $last_state_data;
        if ($last_profile_with_results) {
            my $profile_name = $last_profile_with_results->{name};
            my $raw_results_for_vm = $per_profile_nfit_raw_results{$vm_name}{$profile_name};

            # Use the data from the last (most recent) state reported by nfit
            if (ref($raw_results_for_vm) eq 'ARRAY' && @$raw_results_for_vm) {
                $last_state_data = $raw_results_for_vm->[-1];
            }
        }

        if (defined $last_state_data) {
            # Populate variables from the parsed nfit data
            $serial_out = $last_state_data->{'SerialNumber'} // '';
            $poolid_out = $last_state_data->{'PoolID'} // '';
            $ent_out    = $last_state_data->{'Entitlement'} // '';

            # These fields are not available from nfit, so they will be blank in fallback mode
            $systype_out  = '';
            $poolname_out = '';
        }
    }

    # Add the sourced metadata details to the CSV row
    push @data_row_csv, $serial_out, $systype_out, $poolname_out, $poolid_out;

    # Add Peak PhysC value
    push @data_row_csv, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // "");


    # --- Loop through profiles and populate values ---
    foreach my $profile_being_adjusted_ref (@profiles)
    {
        my $profile_name_being_adjusted = $profile_being_adjusted_ref->{name};
        my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name_being_adjusted};
        my $final_value_for_csv = $raw_physc_profile_value_str // "N/A";

        # *** This is the main VIO logic branch ***
        if (!$is_vio_server)
        {
            # --- Standard (NON-VIO) Server: Apply modification logic ---
            my $current_profile_runq_behavior = $profile_being_adjusted_ref->{runq_behavior} // 'default';
            my $debug_info_for_log = { AbsRunQKeyUsed => 'AbsRunQ_P90 (default/key unknown)' };
            my $abs_runq_p_value_to_use_for_calc = "N/A";
            my $abs_runq_key_actually_used = "AbsRunQ_P90";
            my $current_profile_physc_perc_val_num;

            if ($profile_being_adjusted_ref->{flags} =~ /(?:-p|--percentile)\s+([0-9.]+)/) {
                $current_profile_physc_perc_val_num = $1 + 0;
            }

            if ($match_runq_perc_to_profile && defined $current_profile_physc_perc_val_num) {
                my $target_perc_label = sprintf("%.2f", $current_profile_physc_perc_val_num);
                $target_perc_label =~ s/\.?0+$//;
                $target_perc_label = "0" if $target_perc_label eq "" && abs($current_profile_physc_perc_val_num - 0) < 0.001;
                my $potential_key = "AbsRunQ_P" . $target_perc_label;

                if (exists $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{$potential_key}) {
                    $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{$potential_key};
                    $abs_runq_key_actually_used = $potential_key;
                } else {
                    if ($LOG_FH) {
                        print {$LOG_FH} "WARNING VM '$vm_name', Profile '$profile_name_being_adjusted': Matched key '$potential_key' for AbsRunQ not found. Falling back to AbsRunQ_P90.\n";
                    }
                    $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"} // "N/A";
                }
            } else {
                $abs_runq_p_value_to_use_for_calc = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{"AbsRunQ_P90"} // "N/A";
            }

            my $this_profile_norm_p50 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P50'} // "N/A";
            my $this_profile_norm_p90 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P90'} // "N/A";
            my $this_profile_norm_p25 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P25'} // "N/A";
            my $this_profile_norm_p75 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P75'} // "N/A";

            if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/)
            {
                # -- Subtract-Then-Add-Back Fix --
                # The raw value from nfit may be inflated with a growth prediction.
                # To correctly calculate the RunQ additive CPU, which is based on historical
                # pressure, we must first subtract the growth adjustment to get a true
                # historical baseline for the calculation.

                # Step 1: Get the growth adjustment value calculated by nfit.pl.
                # This is sourced from the most recent state of the raw nfit results for this profile.
                my $growth_adjustment_to_apply = 0.0;
                my $raw_nfit_states_aref = $per_profile_nfit_raw_results{$vm_name}{$profile_name_being_adjusted};
                if (ref($raw_nfit_states_aref) eq 'ARRAY' && @$raw_nfit_states_aref)
                {
                    # The GrowthAdjAbs is what nfit added to the baseline.
                    my $growth_adj_from_nfit = $raw_nfit_states_aref->[-1]{'GrowthAdjAbs'} // 0;
                    if (defined $growth_adj_from_nfit && looks_like_number($growth_adj_from_nfit))
                    {
                        $growth_adjustment_to_apply = $growth_adj_from_nfit + 0;
                    }
                }

                # Step 2: Calculate the historical baseline by subtracting the growth adjustment.
                my $inflated_physc_from_nfit = $raw_physc_profile_value_str + 0;
                my $historical_physc_for_runq_calc = $inflated_physc_from_nfit - $growth_adjustment_to_apply;


                # Step 3: Perform the RunQ adjustment using the corrected historical baseline.
                my ($runq_adjusted_physc, $calc_debug_info_ref) = calculate_runq_modified_physc(
                    $historical_physc_for_runq_calc, # Use the corrected historical value
                    $this_profile_norm_p25,
                    $this_profile_norm_p50,
                    $this_profile_norm_p75,
                    $this_profile_norm_p90,
                    $abs_runq_p_value_to_use_for_calc,
                    $abs_runq_key_actually_used,
                    $smt_used_for_vm_csv,
                    (defined $cfg_csv ? $cfg_csv->{entitlement} : "0"),
                    $max_cpu_for_vm_csv,
                    ($is_vio_server ? 1 : 0),
                    $current_profile_runq_behavior,
                    $p99w1_vm_has_abs_runq_pressure,
                    $p99w1_vm_has_norm_runq_pressure
                );

                # Step 4: Add the growth adjustment back to the RunQ-adjusted value to get the final recommendation.
                my $final_recommendation = $runq_adjusted_physc + $growth_adjustment_to_apply;


                # --- Final Formatting and Logging ---
                my $effective_nfit_flags_for_dp_calc = $rounding_flags_for_nfit . " " . $profile_being_adjusted_ref->{flags};
                my $current_profile_output_dp = get_nfit_output_dp_from_flags($effective_nfit_flags_for_dp_calc);
                my $current_sprintf_format = "%." . $current_profile_output_dp . "f";
                $final_value_for_csv = sprintf($current_sprintf_format, $final_recommendation);

                # The log call can remain the same. The rationale log already displays the
                # growth adjustment value, providing context for the calculation. The important
                # part is that the calculation itself is now correct.
                if ($LOG_FH)
                {
                    # For logging purposes, we still show the original inflated value as the "Base PhysC"
                    # from nfit's perspective, as the log details the subsequent adjustments.
                    my $nfit_growth_adj_for_log = $parsed_growth_adj_values{$vm_name}{$profile_name_being_adjusted} // "0.0000 (not parsed)";
                    my $nfit_growth_adj_abs_for_log = $parsed_growth_adj_abs_values{$vm_name}{$profile_name_being_adjusted} // "0.0000 (not parsed)";

                    log_profile_rationale(
                        $LOG_FH, $vm_name, $profile_name_being_adjusted, $raw_physc_profile_value_str,
                        $per_profile_nfit_raw_results{$vm_name}{$profile_name_being_adjusted},
                        $profile_name_being_adjusted, $abs_runq_p_value_to_use_for_calc,
                        $this_profile_norm_p50, $this_profile_norm_p90, $cfg_csv, $smt_used_for_vm_csv,
                        $max_cpu_for_vm_csv, $current_profile_runq_behavior, $calc_debug_info_ref,
                        $final_value_for_csv, $nfit_growth_adj_for_log, $nfit_growth_adj_abs_for_log
                    );
                }
            }
        }
        # For VIO servers, we just use the raw value already in $final_value_for_csv
        push @data_row_csv, $final_value_for_csv;
    }

    # Add final columns (entitlement, formulas) to the CSV row
    my $current_ent_display_csv_out = $ent_out;
    if (looks_like_number($current_ent_display_csv_out)) {
        $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out);
    }

    # If the --config file was used, get entitlement from it.
    if (defined $cfg_csv && defined $cfg_csv->{entitlement}) {
        $current_ent_display_csv_out = $cfg_csv->{entitlement};
    }
    # Otherwise, fall back to the entitlement from the most recent nfit state.
    else {
        # Find the last profile that has raw results for this VM
        my $last_profile_with_results = (reverse grep { exists $per_profile_nfit_raw_results{$vm_name}{$_->{name}} } @profiles)[0];
        if ($last_profile_with_results) {
            my $profile_name = $last_profile_with_results->{name};
            my $raw_results_for_vm = $per_profile_nfit_raw_results{$vm_name}{$profile_name};

            # Use the 'Entitlement' from the last (most recent) state
            if (ref($raw_results_for_vm) eq 'ARRAY' && @$raw_results_for_vm) {
                my $last_state = $raw_results_for_vm->[-1];
                if (exists $last_state->{'Entitlement'}) {
                    $current_ent_display_csv_out = $last_state->{'Entitlement'};
                }
            }
        }
    }

    # Format the final value for display
    if ($current_ent_display_csv_out ne "" && looks_like_number($current_ent_display_csv_out)) {
        $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out);
    }

    my $nfit_ent_formula_str = generate_nfit_ent_formula($excel_row_num_counter, scalar(@profiles));

    my $idx_current_ent_col_this_row_actual = 12 + scalar(@profiles) + 1;
    my $idx_nfit_ent_formula_col_this_row_actual = 12 + scalar(@profiles) + 2;

    my $cell_letter_current_ent_actual = get_excel_col_name($idx_current_ent_col_this_row_actual);
    my $cell_letter_nfit_ent_formula_actual = get_excel_col_name($idx_nfit_ent_formula_col_this_row_actual);

    my $cell_ref_current_ent_actual = $cell_letter_current_ent_actual . $excel_row_num_counter;
    my $cell_ref_nfit_ent_formula_actual = $cell_letter_nfit_ent_formula_actual . $excel_row_num_counter;

    my $nett_user_formula_str = sprintf("=(%s-%s)", $cell_ref_nfit_ent_formula_actual, $cell_ref_current_ent_actual);
    my $nett_perc_user_formula_str = sprintf("=IFERROR((%s-%s)/%s,\"\")", $cell_ref_nfit_ent_formula_actual, $cell_ref_current_ent_actual, $cell_ref_current_ent_actual);

    push @data_row_csv, $current_ent_display_csv_out,
                        $nfit_ent_formula_str,
                        $nett_user_formula_str,
                        $nett_perc_user_formula_str;

    print STDOUT join(",", map { quote_csv($_) } @data_row_csv) . "\n";
} # End foreach vm_name

# --- Collect unique serials that were part of the output ---
my %serials_in_output_map;
if (%vm_config_data && @vm_order) { # Ensure vm_config_data was loaded and there are VMs to process
    foreach my $vm_name_in_order (@vm_order) {
        if (exists $vm_config_data{$vm_name_in_order} &&
            defined $vm_config_data{$vm_name_in_order}{serial} &&
            $vm_config_data{$vm_name_in_order}{serial} ne '') {
            $serials_in_output_map{$vm_config_data{$vm_name_in_order}{serial}} = 1;
        }
    }
}
my @sorted_unique_serials_list = sort keys %serials_in_output_map;

# --- Add the CSV Footer with Summary Formulas ---
if (@vm_order && $add_excel_formulas) { # Only print footer if there was data AND 'excel-formulas' flag is true
    print_csv_footer($excel_row_num_counter, $physc_data_file, scalar(@profiles), \@sorted_unique_serials_list);
}

# --- Script Footer ---
print STDERR "CSV output generated successfully.\n";
if ($nfit_enable_windowed_decay) # If nfit was instructed to use its internal decay
{
    print STDERR "Note: nfit was instructed to use internal windowed decay processing.\n";
}
if ($LOG_FH) # If logging was enabled and successful
{
    my $PROFILE_SCRIPT_END_TIME_EPOCH = time();
    my $PROFILE_SCRIPT_END_TIME_STR = localtime($PROFILE_SCRIPT_END_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");
    my $PROFILE_SCRIPT_DURATION = $PROFILE_SCRIPT_END_TIME_EPOCH - $PROFILE_SCRIPT_START_TIME_EPOCH;

    print {$LOG_FH} "\n----------------------------------------------------------------------\n";
    print {$LOG_FH} "nfit-profile.pl Run Ended  : $PROFILE_SCRIPT_END_TIME_STR\n";
    print {$LOG_FH} "Total Duration             : $PROFILE_SCRIPT_DURATION seconds\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "End of Rationale Log.\n";
    print {$LOG_FH} "======================================================================\n";
    close $LOG_FH;
    print STDERR "Rationale log written to: $LOG_FILE_PATH\n";
}

exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================

# --- get_excel_col_name ---
# Converts a 1-based column index to an Excel column name (e.g., 1 -> A, 27 -> AA).
sub get_excel_col_name {
    my ($idx) = @_;
    my $name = '';
    die "Column index must be positive" if (!defined $idx || $idx <= 0);
    while ($idx > 0) {
        my $mod = ($idx - 1) % 26;
        $name = chr(65 + $mod) . $name;
        $idx = int(($idx - $mod - 1) / 26); # Corrected logic for 1-based index progression
    }
    return $name;
}

# --- generate_nfit_ent_formula ---
# Generates the dynamic Excel formula for the "NFIT_ENT_UserFormula" column.
sub generate_nfit_ent_formula {
    my ($excel_row_num, $num_profiles) = @_;

    # First profile column is M (13th column).
    # Peak (L) is the 12th column. Profiles start after Peak.
    my $first_profile_excel_col_letter = get_excel_col_name(12 + 1);
    my $last_profile_excel_col_letter = get_excel_col_name(12 + $num_profiles);

    # The fixed array string for the MATCH function, as provided by the user.
    my $tier_match_array_str_for_formula = '{"P","G1","G2","G3","G4","O1","O2","O3","O4","B1","B2","B3","B4"}';

    # Dynamic column index for 'NFIT - Ent'.
    # 13 fixed leading columns (A-M) + num_profiles columns + 1 (for "NFIT - Ent" itself).
    my $entitlement_column_index = 13 + $num_profiles + 1;

    # Using "A:AZ" as the VLOOKUP range as requested for stability.
    my $vlookup_range_for_peer_ent = "A:AZ";

    my $formula_body = sprintf(
        'IF(ISNUMBER(SEARCH("PowerHA Standby", I%d)),VLOOKUP(VLOOKUP(A%d, PowerHA!A:B, 2, FALSE),%s, %d, FALSE) * $L$258, CEILING(INDEX(%s%d:%s%d, MATCH(B%d, %s, 0)), 0.05))',
        $excel_row_num,                            # For I%d (SystemType)
        $excel_row_num,                            # For A%d (VM Name for inner VLOOKUP)
        $vlookup_range_for_peer_ent,               # Range for outer VLOOKUP (e.g., A:AZ)
        $entitlement_column_index,                 # Dynamic column index for Current_ENT of the peer
        $first_profile_excel_col_letter, $excel_row_num, # For M%d (start of profile data range)
        $last_profile_excel_col_letter,  $excel_row_num, # For e.g. Y%d (end of profile data range)
        $excel_row_num,                            # For C%d (Hint column, containing the tier string like "G3")
        $tier_match_array_str_for_formula          # For {"P","G1",...} array
    );
    return "=" . $formula_body; # Excel formulas start with "="
}

# --- print_csv_footer ---
# Prints the summary footer section with labels and Excel formulas.
# Make sure Time::Piece is used if not already at the top of your script for strftime
# use Time::Piece; # Already in the full script you provided.
# use List::Util qw(sum min max); # Already in the full script.
# Ensure get_excel_col_name and quote_csv are defined elsewhere or within this sub's scope.
sub print_csv_footer {
    my ($last_data_row, $nmon_physc_file, $num_profiles, $sorted_unique_serials_list_ref) = @_;

    my @sorted_unique_serials = @$sorted_unique_serials_list_ref;
    my $count_of_unique_serials = scalar(@sorted_unique_serials);
    # If there are no unique serials, we still might want to print headers for the section,
    # and the UNIQUE formula (which will result in #CALC! or empty in Excel).
    # The loops for formulas should gracefully handle count = 0 for SUM ranges.
    # Or, ensure at least one iteration for the UNIQUE formula itself.
    my $loop_count_for_serials = ($count_of_unique_serials == 0) ? 1 : $count_of_unique_serials;


    # --- Calculate dynamic column letters based on script's output structure ---
    my $col_serial_letter = get_excel_col_name(8);       # Serial is 8th column (H)
    my $col_system_type_letter = get_excel_col_name(9);  # SystemType is 9th column (I)
    my $idx_current_ent = 12 + $num_profiles + 1;
    my $col_current_ent_letter = get_excel_col_name($idx_current_ent);
    my $idx_nfit_ent_user_formula = 12 + $num_profiles + 2;
    my $col_nfit_ent_user_formula_letter = get_excel_col_name($idx_nfit_ent_user_formula);

    # --- Get NMON physc data file modification timestamp ---
    my $file_timestamp_str = "N/A";
    if (defined $nmon_physc_file && -f $nmon_physc_file) {
        my $mtime_epoch = (stat($nmon_physc_file))[9];
        if (defined $mtime_epoch) { # Ensure mtime_epoch is defined
            $file_timestamp_str = localtime($mtime_epoch)->strftime("%Y-%m-%d %H:%M:%S");
        } else {
            $file_timestamp_str = "Timestamp N/A (stat fetch failed for $nmon_physc_file)";
        }
    } else {
        $file_timestamp_str = "Timestamp N/A (File not found or not provided)";
    }

    # --- Define starting row for footer elements ---
    print STDOUT "\n"; # Blank line after main data
    my $footer_start_row = $last_data_row + 2;

    my $row_data_age = $footer_start_row;
    my $row_timestamp = $footer_start_row + 1;
    my $row_as_is_nfit_labels = $footer_start_row + 3; # After another blank line
    my $row_ent_col_headers = $footer_start_row + 4;
    my $row_unique_serials_start = $footer_start_row + 5;

    my $empty = "";
    my @csv_row;

    # --- Row 1 of Footer: Data Age ---
    # Column letters for where the SUM, DELTA, PERC formulas for this row will RESIDE
    my $col_letter_data_age_sum_current_incl = get_excel_col_name(23); # W
    my $col_letter_data_age_sum_nfit_incl = get_excel_col_name(24);    # X
    my $col_letter_data_age_delta_incl = get_excel_col_name(25);       # Y
    my $col_letter_data_age_perc_incl = get_excel_col_name(26);        # Z

    my $formula_sum_current_ent_incl_sby = sprintf("=SUM(%s2:%s%d)", $col_current_ent_letter, $col_current_ent_letter, $last_data_row);
    my $formula_sum_nfit_ent_incl_sby = sprintf("=SUM(%s2:%s%d)", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row);
    my $formula_delta_incl_sby = sprintf("=%s%d-%s%d", $col_letter_data_age_sum_nfit_incl, $row_data_age, $col_letter_data_age_sum_current_incl, $row_data_age);
    my $formula_perc_incl_sby = sprintf("=IFERROR(%s%d/%s%d,\"\")", $col_letter_data_age_delta_incl, $row_data_age, $col_letter_data_age_sum_current_incl, $row_data_age);

    @csv_row = ($empty) x 22; # Pad up to the column before the first formula/label
    $csv_row[0] = "Data Age"; # Column A
    $csv_row[21] = "Incl. SBY"; # Column V
    push @csv_row, $formula_sum_current_ent_incl_sby, $formula_sum_nfit_ent_incl_sby, $formula_delta_incl_sby, $formula_perc_incl_sby;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Row 2 of Footer: Timestamp ---
    # Column letters for this row's SUM, DELTA, PERC formulas (can be same as above if aligned)
    my $col_letter_ts_sum_current_excl = $col_letter_data_age_sum_current_incl; # W
    my $col_letter_ts_sum_nfit_excl    = $col_letter_data_age_sum_nfit_incl;    # X
    my $col_letter_ts_delta_excl       = $col_letter_data_age_delta_incl;       # Y
    my $col_letter_ts_perc_excl        = $col_letter_data_age_perc_incl;        # Z

    my $formula_sum_current_ent_excl_sby = sprintf("=SUMIFS(%s\$2:%s\$%d, %s\$2:%s\$%d, \"<>*PowerHA Standby*\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row);
    my $formula_sum_nfit_ent_excl_sby = sprintf("=SUMIFS(%s\$2:%s\$%d, %s\$2:%s\$%d, \"<>*PowerHA Standby*\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row);
    my $formula_delta_excl_sby = sprintf("=%s%d-%s%d", $col_letter_ts_sum_nfit_excl, $row_timestamp, $col_letter_ts_sum_current_excl, $row_timestamp);
    my $formula_perc_excl_sby = sprintf("=IFERROR(%s%d/%s%d,\"\")", $col_letter_ts_delta_excl, $row_timestamp, $col_letter_ts_sum_current_excl, $row_timestamp);

    @csv_row = ($empty) x 22;
    $csv_row[0] = $file_timestamp_str;
    $csv_row[21] = "Excl. SBY";
    push @csv_row, $formula_sum_current_ent_excl_sby, $formula_sum_nfit_ent_excl_sby, $formula_delta_excl_sby, $formula_perc_excl_sby;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Blank Row ---
    print STDOUT "\n"; # Corresponds to e.g. Excel row 256

    # --- Row: AS-IS NFIT Labels --- (e.g., Excel row 257 / my $row_as_is_nfit_labels)
    @csv_row = ($empty) x 23; # Ensure enough columns
    $csv_row[17] = "AS-IS"; # Column R
    $csv_row[18] = "NFIT";  # Column S
    $csv_row[20] = "AS-IS"; # Column U (for Largest PowerHA AS-IS)
    $csv_row[21] = "NFIT";  # Column V (for Largest PowerHA NFIT)
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Row: ENT Column Headers and other labels --- (e.g., Excel row 258 / my $row_ent_col_headers)
    @csv_row = ($empty) x 22; # Adjust total size based on max column used
    $csv_row[0] = "ENT"; $csv_row[1] = "ENT-NOVIO"; $csv_row[2] = "ENT-HA"; $csv_row[3] = "ENT-NFIT";
    $csv_row[4] = "NFIT-ENT-NO-VIO"; $csv_row[5] = "NFIT-ENT-NO-POWERHA-STANDBY";
    $csv_row[6] = "NFIT-ENT-NO-POWERHA-SBY-NO-VIO"; $csv_row[7] = "NFIT-ENT-POWERHA-SBY-AS-IS";
    $csv_row[8] = "NFIT-ENT-POWERHA-SBY-AS-IS-NOVIO";
    $csv_row[12] = "PowerHA SBY% TGT"; $csv_row[13] = "0.25"; # Cols M, N

    my $largest_frame_formula_as_is = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,rows,FILTER(HSTACK(sys,ent),NOT(type=\"VIO Server\")),uniqSys,UNIQUE(INDEX(rows,,1)),sums,BYROW(uniqSys,LAMBDA(s,SUM(FILTER(INDEX(rows,,2),INDEX(rows,,1)=s)))),XLOOKUP(MAX(sums),sums,uniqSys))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row);
    my $largest_frame_formula_nfit = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,rows,FILTER(HSTACK(sys,ent),NOT(type=\"VIO Server\")),uniqSys,UNIQUE(INDEX(rows,,1)),sums,BYROW(uniqSys,LAMBDA(s,SUM(FILTER(INDEX(rows,,2),INDEX(rows,,1)=s)))),XLOOKUP(MAX(sums),sums,uniqSys))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row);
    my $largest_powerha_formula_as_is = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,pharows,FILTER(HSTACK(sys,ent),ISNUMBER(SEARCH(\"PowerHA Primary\",type))),uniqSysPHA,UNIQUE(INDEX(pharows,,1)),sumsPHA,BYROW(uniqSysPHA,LAMBDA(s,SUM(FILTER(INDEX(pharows,,2),INDEX(pharows,,1)=s)))),XLOOKUP(MAX(sumsPHA),sumsPHA,uniqSysPHA,\"\"))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row); # Added if_not_found for XLOOKUP
    my $largest_powerha_formula_nfit = sprintf("=LET(sys,%s\$2:%s\$%d,type,%s\$2:%s\$%d,ent,%s\$2:%s\$%d,pharows,FILTER(HSTACK(sys,ent),ISNUMBER(SEARCH(\"PowerHA Primary\",type))),uniqSysPHA,UNIQUE(INDEX(pharows,,1)),sumsPHA,BYROW(uniqSysPHA,LAMBDA(s,SUM(FILTER(INDEX(pharows,,2),INDEX(pharows,,1)=s)))),XLOOKUP(MAX(sumsPHA),sumsPHA,uniqSysPHA,\"\"))", $col_serial_letter, $col_serial_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Added if_not_found

    $csv_row[16] = "Largest Frame"; # Col Q
    $csv_row[17] = $largest_frame_formula_as_is; # Col R
    $csv_row[18] = $largest_frame_formula_nfit;  # Col S
    $csv_row[19] = "Largest PowerHA"; # Col T
    $csv_row[20] = $largest_powerha_formula_as_is; # Col U
    $csv_row[21] = $largest_powerha_formula_nfit; # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # --- Per-Serial Summary Rows --- (e.g., starting Excel row 259 / my $row_unique_serials_start)
    for (my $i = 0; $i < $loop_count_for_serials; $i++) {
        my $current_formula_row = $row_unique_serials_start + $i;
        my @csv_row_serial_summary;

        if ($i == 0) {
            my $formula_unique_serials = sprintf("=UNIQUE(%s\$2:%s\$%d)", $col_serial_letter, $col_serial_letter, $last_data_row);
            push @csv_row_serial_summary, $formula_unique_serials;
        } else {
            push @csv_row_serial_summary, $empty; # Column A empty for subsequent rows, UNIQUE spills
        }

        # Formulas for columns B-J
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row); # Col B
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col C
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col D
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row); # Col E
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col F
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>*PowerHA Standby*\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col G
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, A%d, \$%s\$2:\$%s\$%d, \"<>*PowerHA Standby*\", \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col H
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMPRODUCT((\$%s\$2:\$%s\$%d=A%d)*IF(ISNUMBER(SEARCH(\"PowerHA Standby\",\$%s\$2:\$%s\$%d)),\$%s\$2:\$%s\$%d,\$%s\$2:\$%s\$%d)),\"\")", $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Col I
        push @csv_row_serial_summary, sprintf("=IFERROR(SUMPRODUCT((\$%s\$2:\$%s\$%d=A%d)*(\$%s\$2:\$%s\$%d<>\"VIO Server\")*IF(ISNUMBER(SEARCH(\"PowerHA Standby\",\$%s\$2:\$%s\$%d)),\$%s\$2:\$%s\$%d,\$%s\$2:\$%s\$%d)),\"\")", $col_serial_letter, $col_serial_letter, $last_data_row, $current_formula_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_system_type_letter, $col_system_type_letter, $last_data_row, $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row); # Col J

        if ($i == 0) { # Add right-hand side elements only for the first row of this block
            my $num_main_formulas = scalar(@csv_row_serial_summary);
            my $padding_needed = 16 - $num_main_formulas; # Target Col Q (17th)
            push @csv_row_serial_summary, ($empty) x $padding_needed if $padding_needed > 0;

            my $col_R_header_cell = get_excel_col_name(18) . $row_ent_col_headers; # R258
            my $col_S_header_cell = get_excel_col_name(19) . $row_ent_col_headers; # S258
            my $col_U_header_cell = get_excel_col_name(21) . $row_ent_col_headers; # U258

            push @csv_row_serial_summary, "Largest Frame ENT (Excl. VIO)"; # Col Q
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_R_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col R
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"<>VIO Server\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_S_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col S
            push @csv_row_serial_summary, "Largest PowerHA ENT"; # Col T
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_current_ent_letter, $col_current_ent_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_U_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col U
            push @csv_row_serial_summary, sprintf("=IFERROR(SUMIFS(\$%s\$2:\$%s\$%d, \$%s\$2:\$%s\$%d, %s, \$%s\$2:\$%s\$%d, \"*PowerHA Primary*\"),\"\")", $col_nfit_ent_user_formula_letter, $col_nfit_ent_user_formula_letter, $last_data_row, $col_serial_letter, $col_serial_letter, $last_data_row, $col_U_header_cell, $col_system_type_letter, $col_system_type_letter, $last_data_row); # Col V
        }
        print STDOUT join(",", map { quote_csv($_) } @csv_row_serial_summary) . "\n";
    }

    # --- Rows after per-serial summary (Frame Evac, etc.) ---
    my $actual_row_unique_serials_end = $row_unique_serials_start + $loop_count_for_serials - 1;
    my $row_after_serials_block = $row_unique_serials_start + $loop_count_for_serials;


    # Determine cell references for "Largest Frame AS-IS/NFIT result" and "Largest PHA AS-IS/NFIT result"
    # These are from the row $row_ent_col_headers, columns R, S, U, V respectively.
    my $cell_largest_frame_asis_val = get_excel_col_name(18) . $row_ent_col_headers; # R<row_ent_col_headers>
    my $cell_largest_frame_nfit_val = get_excel_col_name(19) . $row_ent_col_headers; # S<row_ent_col_headers>
    my $cell_largest_pha_asis_val   = get_excel_col_name(21) . $row_ent_col_headers; # U<row_ent_col_headers>
    my $cell_largest_pha_nfit_val   = get_excel_col_name(22) . $row_ent_col_headers; # V<row_ent_col_headers>

    # Row: Frame Evac - Max Required
    @csv_row = ($empty) x 22; # Pad to ensure correct column alignment
    $csv_row[16] = "Frame Evac - Max Required"; # Col Q
    $csv_row[17] = sprintf("=MAX(%s,%s)", $cell_largest_frame_asis_val, $cell_largest_pha_asis_val); # Col R
    $csv_row[21] = sprintf("=MAX(%s,%s)", $cell_largest_frame_nfit_val, $cell_largest_pha_nfit_val); # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # Row: Frame Evac - Required per frame
    # This refers to the results from the "Frame Evac - Max Required" line just printed.
    my $current_print_row_for_evac_max = $row_after_serials_block; # The row number where the above line was printed
                                                                  # This needs to be $row_after_serials_block if printed sequentially without gaps
    my $cell_max_req_as_is_val = get_excel_col_name(18) . $current_print_row_for_evac_max; # R<current_print_row>
    my $cell_max_req_nfit_val  = get_excel_col_name(22) . $current_print_row_for_evac_max; # V<current_print_row>

    @csv_row = ($empty) x 22;
    $csv_row[16] = "Frame Evac - Required per frame"; # Col Q
    $csv_row[17] = sprintf("=IFERROR(%s/COUNTA(UNIQUE(\$%s\$2:\$%s\$%d)),\"N/A\")", $cell_max_req_as_is_val, $col_serial_letter, $col_serial_letter, $last_data_row); # Col R
    $csv_row[21] = sprintf("=IFERROR(%s/COUNTA(UNIQUE(\$%s\$2:\$%s\$%d)),\"N/A\")", $cell_max_req_nfit_val, $col_serial_letter, $col_serial_letter, $last_data_row); # Col V
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";

    # Adjust row number for Total row if Frame Evac rows were printed
    my $row_for_total_sum = $current_print_row_for_evac_max + 2; # Skip one line after last Frame Evac

    # --- Total Row for Per-Serial Summary ---
    @csv_row = ();
    push @csv_row, "Total"; # Col A
    for my $col_idx (2..10) { # Columns B to J
        my $col_letter = get_excel_col_name($col_idx);
        if ($count_of_unique_serials > 0) {
            push @csv_row, sprintf("=SUM(%s%d:%s%d)", $col_letter, $row_unique_serials_start, $col_letter, $actual_row_unique_serials_end);
        } else { # No unique serials, sum is 0 or empty
            push @csv_row, "0";
        }
    }
    # Pad if necessary
    my $current_cols = scalar(@csv_row);
    push @csv_row, ($empty) x (22 - $current_cols) if 22 > $current_cols;
    print STDOUT join(",", map { quote_csv($_) } @csv_row) . "\n";
}

# ==============================================================================
# Subroutine to format nfit flags for display
# ==============================================================================
sub format_nfit_flags_for_display {
    my ($profile_name, $profile_specific_flags, $runq_perc_flags, $runq_behavior) = @_;
    my @output_lines;

    push @output_lines, "Running profile: $profile_name";

    my $temp_profile_flags = $profile_specific_flags; # Work on a copy

    my @core_fit_parts;
    my @decay_parts;
    my @growth_parts;
    my @other_parts; # For flags not specifically categorized

    # Helper sub-subroutine to extract and remove a flag pattern
    # Arguments:
    #   1. Regex for the flag and its potential value (e.g., qr/-p\s+[^\s]+/)
    #   2. Array reference to store the extracted flag string
    #   3. Scalar reference to the string of flags to be processed (will be modified)
    sub _extract_flag {
        my ($flag_regex, $parts_array_ref, $flags_string_ref) = @_;
        if ($$flags_string_ref =~ s/($flag_regex)//) {
            my $extracted_part = $1;
            $extracted_part =~ s/^\s+|\s+$//g; # Trim whitespace
            push @$parts_array_ref, $extracted_part if $extracted_part;
        }
    }

    # --- Core Fit Parameters ---
    _extract_flag(qr/--percentile\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)|-p\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@core_fit_parts, \$temp_profile_flags);
    _extract_flag(qr/--process-window-size\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)|-w\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@core_fit_parts, \$temp_profile_flags);
    _extract_flag(qr/--filter-above-perc\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@core_fit_parts, \$temp_profile_flags);
    # Add more related flags here if needed, e.g.:
    # _extract_flag(qr/--filter-metric\s+[^\s]+/, \@core_fit_parts, \$temp_profile_flags);
    # _extract_flag(qr/--filter-limit\s+[^\s]+/, \@core_fit_parts, \$temp_profile_flags);

    # --- Decay Options ---
    _extract_flag(qr/--decay\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@decay_parts, \$temp_profile_flags);
    _extract_flag(qr/--runq-decay\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@decay_parts, \$temp_profile_flags);
    # Add more related flags here, e.g.:
    # _extract_flag(qr/--ema-period\s+[^\s]+/, \@decay_parts, \$temp_profile_flags);
    # _extract_flag(qr/--sma-period\s+[^\s]+/, \@decay_parts, \$temp_profile_flags);

    # --- Growth Prediction ---
    _extract_flag(qr/--enable-growth-prediction\b/, \@growth_parts, \$temp_profile_flags); # \b for word boundary
    _extract_flag(qr/--max-growth-inflation-percent\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@growth_parts, \$temp_profile_flags);
    _extract_flag(qr/--growth-period-days\s+(?:\"[^\"]*\"|\'[^\']*\'|[^\s\"]+)/, \@growth_parts, \$temp_profile_flags);

    if (@core_fit_parts) {
        push @output_lines, "  Core         : " . join(" ", @core_fit_parts);
    }
    if (@decay_parts) {
        push @output_lines, "  Decay        : " . join(" ", @decay_parts);
    }
    if (@growth_parts) {
        push @output_lines, "  Growth       : " . join(" ", @growth_parts);
    }

    # --- RunQ Percentiles (these are from the already processed $runq_perc_flags) ---
    my $trimmed_runq_perc_flags = $runq_perc_flags;
    $trimmed_runq_perc_flags =~ s/^\s+|\s+$//g; # Trim
    if ($trimmed_runq_perc_flags) {
        push @output_lines, "  RunQ Percs   : " . $trimmed_runq_perc_flags;
    }

    # --- Other/Remaining Profile Flags ---
    # Any flags left in $temp_profile_flags are considered "Other"
    $temp_profile_flags =~ s/^\s+|\s+$//g; # Trim remaining
    my @remaining_flags = split(/\s+/, $temp_profile_flags); # Split remaining by space
    @remaining_flags = grep { $_ ne "" } @remaining_flags; # Filter out empty strings
    if (@remaining_flags) {
         # Reconstruct to handle flags that might have been split from their values if not perfectly matched above
         # This simplistic split might not be perfect if un-extracted flags had quoted spaces.
         # For robust handling of complex "Other" flags, more sophisticated parsing of $temp_profile_flags would be needed.
         # However, ideally, most common flags are explicitly extracted above.
        push @output_lines, "  Other Args   : " . join(" ", @remaining_flags);
    }

    # --- RunQ Behavior ---
    # This comes directly from the profile config, not from the flag strings
    if (defined $runq_behavior && $runq_behavior ne 'default') {
        push @output_lines, "  RunQBehavior : $runq_behavior";
    }

    return join("\n", @output_lines);
}

# --- parse_profile_name_for_log ---
# Parses common nfit-profile profile name patterns for a more descriptive log output.
# Adheres to Allman style and includes comments.
sub parse_profile_name_for_log
{
    my ($profile_name_str) = @_;

    my $description = $profile_name_str; # Default to original name if no pattern matches
    my @parts;

    # Regex to capture common patterns like O3-95W15, P-99W1, G2-BatchSpecial etc.
    # This regex looks for: TypeChar [TierNum] - Percentile W WindowNum [SuffixLetters]
    if ($profile_name_str =~ /^([OBGP])(?:-?(\d+))?-?(\d{2,3})(?:W(\d+))?([A-Z]*)?$/i)
    {
        my $type_char   = uc($1);
        my $tier_num    = $2; # Optional
        my $perc_val    = $3;
        my $win_val     = $4; # Optional
        my $suffix_char = $5; # Optional

        my $type_desc = "Unknown Type"; # Default for safety
        if ($type_char eq 'O')
        {
            $type_desc = "Online";
        }
        elsif ($type_char eq 'B')
        {
            $type_desc = "Batch";
        }
        elsif ($type_char eq 'G')
        {
            $type_desc = "General";
        }
        elsif ($type_char eq 'P')
        {
            $type_desc = "Peak";
        }

        if (defined $tier_num && $tier_num ne "")
        {
            $type_desc .= " (Tier $tier_num)";
        }
        push @parts, $type_desc;

        if (defined $perc_val)
        {
            push @parts, "$perc_val" . "th Percentile";
        }
        if (defined $win_val)
        {
            push @parts, "$win_val-minute Window";
        }
        if (defined $suffix_char && $suffix_char ne "")
        {
            push @parts, "Variant '$suffix_char'";
        }

        $description = join(", ", @parts);
    }
    elsif (lc($profile_name_str) eq "peak") # Handle specific "Peak" profile name
    {
        $description = "Absolute Peak Value";
    }
    # Add more 'elsif' blocks here for other distinct profile naming conventions if needed.

    return "$profile_name_str ($description)";
}

# --- log_profile_rationale ---
# Logs the detailed rationale for how a profile's PhysC value was adjusted.
# Incorporates a summary-first approach and clearer narrative for planners.
# Adheres to Allman style and includes comments.
sub log_profile_rationale
{
    my ($fh,
        $vm_name,
        $profile_being_adjusted,
        $base_physc_for_profile, # This is NOW the aggregated Base PhysC or direct value
        $raw_nfit_states_aref,   # NEW: Array ref of all state result hashes from nfit
        $runq_metrics_source_profile_name_for_this_calc,
        $abs_runq_value_used_for_calc,
        $normP50_for_this_calc,
        $normP90_for_this_calc,
        $vm_cfg_ref,
        $smt_val,
        $lpar_max_cpu_cfg_val_from_config,
        $profile_rq_behavior,
        $calc_debug_info_ref,
        $final_csv_value_for_profile,
        $nfit_growth_adj_for_log,
        $nfit_growth_adj_abs_for_log
    ) = @_;

    # Ensure script doesn't die if log handle isn't valid
    return unless $fh;

    my $na = 'N/A'; # Consistent N/A string for display
    my $abs_runq_key_reported_in_log = $calc_debug_info_ref->{AbsRunQKeyUsed} // 'AbsRunQ_P90 (default)';

    # --- Top Summary Block ---
    my $profile_description_log = parse_profile_name_for_log($profile_being_adjusted);

    # Use the unrounded final value from debug_info for precise change calculation
    my $final_recommendation_unrounded_str = $calc_debug_info_ref->{'FinalAdjustedPhysC'} // $na;
    my $final_recommendation_unrounded_num = ($final_recommendation_unrounded_str ne $na && $final_recommendation_unrounded_str =~ /^-?[0-9.]+$/)
                                           ? ($final_recommendation_unrounded_str + 0) : undef;

    my $base_physc_val_num = looks_like_number($base_physc_for_profile) ? $base_physc_for_profile + 0 : undef;

    my $net_change_str = $na;
    if (defined $base_physc_val_num && defined $final_recommendation_unrounded_num) {
        my $delta = $final_recommendation_unrounded_num - $base_physc_val_num;
        my $perc_change_str = (abs($base_physc_val_num) > $FLOAT_EPSILON) ? sprintf(" (Change: %s%.1f%%)", ($delta >=0 ? "+" : ""), ($delta / $base_physc_val_num) * 100) : "";
        $net_change_str = sprintf("%s%.4f cores%s", ($delta >=0 ? "+" : ""), abs($delta), $perc_change_str);
    }

    print {$fh} "======================================================================\n";
    printf {$fh} "VM Name                         : %s\n", $vm_name;
    printf {$fh} "Profile Processed               : %s\n", $profile_description_log;
    print {$fh} "----------------------------------------------------------------------\n";

    # --- Section A: nfit Raw State Analysis ---
    if (ref($raw_nfit_states_aref) eq 'ARRAY' && @$raw_nfit_states_aref)
    {
        # Determine the correct percentile key for this profile.
        my $p_metric_key = "P" . clean_perc_label( ($profile_being_adjusted =~ /-p\s+([0-9.]+)/) ? $1 : $DEFAULT_PERCENTILE );

        print {$fh} "Section A: nfit Raw State Analysis & Base Value Calculation\n";
        printf {$fh} "  - nfit reported the following configuration states for this profile:\n";
        foreach my $state_res (@$raw_nfit_states_aref) {
            my $state_id_str = $state_res->{'State_ID'} // 'N/A';
            printf {$fh} "    - %-26s: Ent=%.2f, MaxCPU=%.2f, SMT=%d, %s=%s\n",
                $state_id_str,
                $state_res->{'Entitlement'} // 0,
                $state_res->{'MaxCPU'} // 0,
                $state_res->{'SMT'} // 0,
                $p_metric_key,
                $state_res->{$p_metric_key} // $na;
        }

        if (@$raw_nfit_states_aref > 1) {
            printf {$fh} "    - Aggregation Method        : Simple Average of %d states was used.\n", scalar(@$raw_nfit_states_aref);
        } else {
            printf {$fh} "    - Aggregation Method        : Direct value from a single state was used.\n";
        }
    }

    printf {$fh} "Initial Base PhysC for Profile    : %s cores (Aggregated/Direct value from nfit states)\n", ($base_physc_for_profile // $na);
    printf {$fh} "Final nfit-profile Recommendation : %s cores (Unrounded: %s)\n", ($final_csv_value_for_profile // $na), $final_recommendation_unrounded_str;
    printf {$fh} "Net Adjustment by nfit-profile    : %s\n", $net_change_str;
    print {$fh} "======================================================================\n\n";

    # --- Section B: Key Inputs & Configuration ---

    print {$fh} "Section B: Key Inputs & Configuration for Modifier Logic\n";
    printf {$fh} "  1. Key RunQ Metrics (source: %s, state: %s):\n",
                 $runq_metrics_source_profile_name_for_this_calc,
                 "Most Recent";
    printf {$fh} "     - AbsRunQ used for Upsizing   (%s) : %s threads\n", $abs_runq_key_reported_in_log, ($abs_runq_value_used_for_calc // $na);
    printf {$fh} "     - NormRunQ P25                   : %s\n", ($calc_debug_info_ref->{'NormRunQ_P25_Val'} // $na);
    printf {$fh} "     - NormRunQ P50                   : %s\n", ($normP50_for_this_calc // ($calc_debug_info_ref->{'NormRunQ_P50_Val'} // $na) );
    printf {$fh} "     - NormRunQ P75                   : %s\n", ($calc_debug_info_ref->{'NormRunQ_P75_Val'} // $na);
    printf {$fh} "     - NormRunQ P90                   : %s\n", ($normP90_for_this_calc // $na);

    my $iqrc_val_for_log_A_sec = $calc_debug_info_ref->{'NormRunQ_IQRC_Val'} // $na;
    printf {$fh} "     - NormRunQ IQRC (Volatility)     : %s", $iqrc_val_for_log_A_sec;
    my $iqrc_interpretation_log_A_sec = $na;
    if ($iqrc_val_for_log_A_sec ne $na && $iqrc_val_for_log_A_sec =~ /^-?[0-9.]+$/)
    {
        my $iqrc_num_A_sec = $iqrc_val_for_log_A_sec + 0;
        if    ($iqrc_num_A_sec < 0.3)  { $iqrc_interpretation_log_A_sec = "Very steady"; }
        elsif ($iqrc_num_A_sec <= 0.6) { $iqrc_interpretation_log_A_sec = "Moderate variability"; }
        elsif ($iqrc_num_A_sec <= 1.0) { $iqrc_interpretation_log_A_sec = "High variability"; }
        else                           { $iqrc_interpretation_log_A_sec = "Very bursty/erratic"; }
        printf {$fh} " (%s)\n", $iqrc_interpretation_log_A_sec;
    } else {
        print {$fh} "\n";
    }

    printf {$fh} "  2. VM Configuration & Profile Behavior:\n";
    printf {$fh} "     - SMT                            : %s\n", ($smt_val // $na);
    my $entitlement_display_A_log_sec = (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} && $vm_cfg_ref->{entitlement} ne '') ? $vm_cfg_ref->{entitlement} : $na;
    printf {$fh} "     - Current Entitlement            : %s cores\n", $entitlement_display_A_log_sec;
    my $lpar_max_cpu_display_A_log_sec = ($lpar_max_cpu_cfg_val_from_config > 0) ? sprintf("%.2f", $lpar_max_cpu_cfg_val_from_config) : $na;
    printf {$fh} "     - LPAR MaxCPU                    : %s cores\n", $lpar_max_cpu_display_A_log_sec;
    printf {$fh} "     - P-99W1 AbsRunQ Pressure Hint   : %s\n", ($calc_debug_info_ref->{'P99W1_AbsPressureHint'} ? "True" : "False");
    printf {$fh} "     - P-99W1 NormRunQ Pressure Hint  : %s\n", ($calc_debug_info_ref->{'P99W1_NormPressureHint'} ? "True" : "False");
    printf {$fh} "     - Profile RunQ Behavior          : %s\n\n", ($profile_rq_behavior // $na);

    if (defined $calc_debug_info_ref->{'ReasonForNoModification'} && $calc_debug_info_ref->{'ReasonForNoModification'} ne '')
    {
        printf {$fh} "CPU Modification Path Skipped: %s\n", $calc_debug_info_ref->{'ReasonForNoModification'};
    }
    else
    {
        # --- Section B: CPU Downsizing (Efficiency Assessment) ---
        print {$fh} "Section B: CPU Downsizing (Efficiency Assessment)\n";
        my $downsizing_reason_B_log = $calc_debug_info_ref->{'DownsizingReason'} // "Not calculated or N/A."; # Use renamed key
        my $downsizing_factor_B_log = $calc_debug_info_ref->{'DownsizingFactor'} // "1.00"; # Use renamed key
        my $physc_after_downsizing_B_log = $calc_debug_info_ref->{'PhysCAfterDownsizing'} // $na; # Use renamed key

        printf {$fh} "  - Overall Status                : %s\n", $downsizing_reason_B_log;
        printf {$fh} "  - Final Downsizing Factor       : %s\n", $downsizing_factor_B_log;

        # Conditionally print detailed analytical breakdown for downsizing
        if ($downsizing_reason_B_log =~ /^Analytical/ &&
             defined $calc_debug_info_ref->{'EffPEfficientTarget'} && # Internal keys can remain Eff...
             defined $calc_debug_info_ref->{'EffCondNormP50Met'} &&
             defined $calc_debug_info_ref->{'EffCondVolatilityMet'})
        {
            printf {$fh} "  - Detailed Analytical Path for Downsizing:\n";
            printf {$fh} "     a. Initial Condition Checks for Downsizing Path:\n";
            my $eff_cond_norm_p50_met_str_B = $calc_debug_info_ref->{'EffCondNormP50Met'} ? "YES (Low P50)" : "NO (P50 not low enough)";
            printf {$fh} "        - NormRunQ P50             : %-5s (Condition: < %.2f for consideration? %s)\n",
                         ($normP50_for_this_calc // $na),
                         $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION,
                         $eff_cond_norm_p50_met_str_B;

            my $eff_cond_volatility_met_str_B = $calc_debug_info_ref->{'EffCondVolatilityMet'} ? "YES (Not excessively volatile)" : "NO (Too volatile)";
            printf {$fh} "        - Workload Volatility      : %-5s (NormP90 %.2f / NormP50 %.2f. Condition: < %.2f to proceed? %s)\n",
                         ($calc_debug_info_ref->{'EffVolatilityRatio'} // $na),
                         ($normP90_for_this_calc ne $na ? ($normP90_for_this_calc+0):0), # Ensure numeric for sprintf
                         ($normP50_for_this_calc ne $na ? ($normP50_for_this_calc+0):0),
                         $VOLATILITY_CAUTION_THRESHOLD,
                         $eff_cond_volatility_met_str_B;
            print {$fh} "\n";

            printf {$fh} "     b. Calculating Raw Efficient PhysC Target (Theoretical Minimum if RunQ was at Target Norm):\n";
            printf {$fh} "        - Base PhysC for Profile   : %s cores\n", ($calc_debug_info_ref->{'EffPBase'} // $na);
            printf {$fh} "        - AbsRunQ Metric Used      : %s (value: %s threads)\n", $abs_runq_key_reported_in_log, ($abs_runq_value_used_for_calc // $na);
            printf {$fh} "        - SMT Value                : %s\n", ($calc_debug_info_ref->{'EffSMTValue'} // $na);
            printf {$fh} "        - Target NormRunQ for SMT%-2s: %.2f (internal heuristic for optimal queue/LCPU)\n",
                         ($calc_debug_info_ref->{'EffSMTValue'} // $na),
                         ($calc_debug_info_ref->{'EffTargetNormRunQ'} // $na);
            printf {$fh} "        - Calculated Raw Efficient PhysC Target = AbsRunQ / (SMT * Target NormRunQ)\n";
            printf {$fh} "                                        = %s / (%s * %.2f) = %s cores\n",
                         ($abs_runq_value_used_for_calc // $na),
                         ($calc_debug_info_ref->{'EffSMTValue'} // $na),
                         ($calc_debug_info_ref->{'EffTargetNormRunQ'} // $na),
                         ($calc_debug_info_ref->{'EffPEfficientTargetRaw'} // $na);
            print {$fh} "\n";

            printf {$fh} "     c. Blending Raw Target with Observed Base PhysC (Applying Confidence):\n";
            printf {$fh} "        - Blending Weights         : %.0f%% Base PhysC / %.0f%% Raw Target\n",
                         defined $calc_debug_info_ref->{'EffBlendWeightBase'} ? (($calc_debug_info_ref->{'EffBlendWeightBase'} // 0) * 100) : 0,
                         defined $calc_debug_info_ref->{'EffBlendWeightTarget'} ? (($calc_debug_info_ref->{'EffBlendWeightTarget'} // 0) * 100) : 0;
            printf {$fh} "        - Blending Rationale       : %s\n", ($calc_debug_info_ref->{'EffBlendReason'} // $na);
            printf {$fh} "        - Blended Efficient Target = (Base PhysC * Weight) + (Raw Target * Weight)\n";
            printf {$fh} "                                 = (%s * %.2f) + (%s * %.2f) = %s cores\n",
                         ($calc_debug_info_ref->{'EffPBase'} // $na),
                         ($calc_debug_info_ref->{'EffBlendWeightBase'} // 0.0),
                         ($calc_debug_info_ref->{'EffPEfficientTargetRaw'} // $na),
                         ($calc_debug_info_ref->{'EffBlendWeightTarget'} // 0.0),
                         ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na);
            print {$fh} "\n";

            printf {$fh} "     d. Determining Potential CPU Downsizing (Based on Blended Target):\n";
            my $eff_comp_base_vs_target_met_str_B = defined($calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'})
                                                ? ($calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'} ? "YES" : "NO") : $na;
            printf {$fh} "        - Comparison               : Base PhysC (%s) > Blended Efficient Target (%s)? %s\n",
                         ($calc_debug_info_ref->{'EffPBase'} // $na),
                         ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na),
                         $eff_comp_base_vs_target_met_str_B;

            if (defined $calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'} && $calc_debug_info_ref->{'EffComparisonBaseVsTargetMet'})
            {
                printf {$fh} "        - Potential CPU Downsize   : %s - %s = %s cores\n",
                             ($calc_debug_info_ref->{'EffPBase'} // $na),
                             ($calc_debug_info_ref->{'EffPEfficientTarget'} // $na),
                             ($calc_debug_info_ref->{'EffPotentialReduction'} // $na);
                printf {$fh} "        - Max Downsize Cap %%      : %.1f%% (Reason: %s)\n",
                             ($calc_debug_info_ref->{'EffMaxAllowableReductionPerc'} eq $na ? ($MAX_EFFICIENCY_REDUCTION_PERCENTAGE*100) : ($calc_debug_info_ref->{'EffMaxAllowableReductionPerc'} +0) ),
                             ($calc_debug_info_ref->{'EffReductionCapReason'} // $na);
                printf {$fh} "        - Max Allowable Downsize   : %s cores (Base PhysC * Max Downsize Cap %%)\n",
                             ($calc_debug_info_ref->{'EffMaxAllowableReductionCores'} // $na);
                printf {$fh} "        - Actual CPU Downsized By  : %s cores (min of Potential and Max Allowable)\n",
                             ($calc_debug_info_ref->{'EffActualReductionCores'} // $na);
            }
            else
            {
                printf {$fh} "        - No potential for downsizing based on Blended Target, or reduction was zero.\n";
            }
            print {$fh} "\n";

            printf {$fh} "     e. Final Downsizing Factor Calculation:\n";
            printf {$fh} "        - Calculated Factor        : (Base PhysC - Actual Reduction) / Base PhysC\n";
            my $eff_p_base_val_for_div_B = ($calc_debug_info_ref->{'EffPBase'} ne $na && ($calc_debug_info_ref->{'EffPBase'} + 0) != 0)
                                       ? ($calc_debug_info_ref->{'EffPBase'} + 0) : 1.0;
            my $eff_p_base_display_for_div_B = ($eff_p_base_val_for_div_B == 1.0 && ($calc_debug_info_ref->{'EffPBase'} eq $na || ($calc_debug_info_ref->{'EffPBase'} + 0) == 0))
                                           ? "$eff_p_base_val_for_div_B (adj for display)" : ($calc_debug_info_ref->{'EffPBase'} // $na);
            printf {$fh} "                                   (%s - %s) / %s = %s\n",
                         ($calc_debug_info_ref->{'EffPBase'} // $na),
                         ($calc_debug_info_ref->{'EffActualReductionCores'} // "0.0000"),
                         $eff_p_base_display_for_div_B,
                         ($calc_debug_info_ref->{'EffCalculatedFactor'} // $na);
        }
        printf {$fh} "  => PhysC after Downsizing       : %s cores\n\n", $physc_after_downsizing_B_log;

        # --- Section C: CPU Upsizing (Additive CPU) ---
        print {$fh} "Section C: CPU Upsizing (Additive CPU)\n";
        my $is_runq_pressure_C_log_sec = ($calc_debug_info_ref->{'IsRunQPressure'} // "False") eq "True";
        my $is_workload_pressure_C_log_sec = ($calc_debug_info_ref->{'IsWorkloadPressure'} // "False") eq "True";
        my $apply_additive_C_log_sec = $is_runq_pressure_C_log_sec || $is_workload_pressure_C_log_sec;

        printf {$fh} "  - Pressure Assessment Summary:\n";
        printf {$fh} "      Overall LPAR RunQ Pressure  : %s (Value: %s vs Threshold: %.2f)\n",
                     ($is_runq_pressure_C_log_sec ? "True" : "False"),
                     ($calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na), $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD;
        printf {$fh} "      Normalised Workload Pressure: %s (NormP90: %s vs Threshold: %.2f; Reason: %s)\n",
                     ($is_workload_pressure_C_log_sec ? "True" : "False"),
                     ($normP90_for_this_calc // $na), $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                     ($calc_debug_info_ref->{'WorkloadPressureReason'} // $na);
        printf {$fh} "  - Additive Logic Triggered      : %s\n", ($apply_additive_C_log_sec ? "Yes" : "No");

        if ($apply_additive_C_log_sec)
        {
            printf {$fh} "    Details of Upsizing Calculation:\n";
            printf {$fh} "    - Base for Upsizing         : %s cores (PhysC after Downsizing)\n", $physc_after_downsizing_B_log;
            printf {$fh} "    - Effective LCPUs at Base   : %s threads\n", ($calc_debug_info_ref->{'EffectiveLCPUsAtBase'} // $na);
            printf {$fh} "    - Excess Threads Calculated : %s threads\n", ($calc_debug_info_ref->{'ExcessThreads'} // $na);
            printf {$fh} "    - Raw Additive CPU          : %s cores\n", ($calc_debug_info_ref->{'RawAdditive'} // $na);
            printf {$fh} "    - Entitlement-Based Cap     : %s cores (Max Additive Cap: %s)\n",
                         (defined $calc_debug_info_ref->{'HotThreadWLDampenedAdditiveFrom'} && $calc_debug_info_ref->{'HotThreadWLDampeningApplied'} eq "True"
                            ? $calc_debug_info_ref->{'HotThreadWLDampenedAdditiveFrom'}
                            : ($calc_debug_info_ref->{'CappedRawAdditive'} // $na) # Show original value before HTW if HTW was applied
                         ), ($calc_debug_info_ref->{'MaxAdditiveCap'} // $na);

            if (defined $calc_debug_info_ref->{'HotThreadWLDampeningApplied'} && $calc_debug_info_ref->{'HotThreadWLDampeningApplied'} eq "True")
            {
                printf {$fh} "    - Hot Thread Dampening      : Applied\n";
                printf {$fh} "        Conditions Summary      : %s\n", ($calc_debug_info_ref->{'HotThreadWLConditionsString'} // $na);
                printf {$fh} "        Dynamic Dampen Factor   : %s\n", ($calc_debug_info_ref->{'HotThreadWLDynamicFactor'} // $na);
                printf {$fh} "        Additive (Before HTW)   : %s cores -> (After HTW): %s cores\n",
                             ($calc_debug_info_ref->{'HotThreadWLDampenedAdditiveFrom'} // $na),
                             ($calc_debug_info_ref->{'HotThreadWLDampenedAdditiveTo'} // $na);
            }
            elsif (defined $calc_debug_info_ref->{'HotThreadWLDampeningApplied'}) # Checked but not applied
            {
                 printf {$fh} "    - Hot Thread Dampening      : Not Applied (Details: %s)\n", ($calc_debug_info_ref->{'HotThreadWLConditionsString'} // "Conditions not met");
            }

            printf {$fh} "    - Volatility Factor Applied : %s (Reason: %s)\n", ($calc_debug_info_ref->{'VoltFactor'} // $na), ($calc_debug_info_ref->{'VoltFactorReason'} // $na);
            printf {$fh} "    - Pool Factor Applied       : %s\n", ($calc_debug_info_ref->{'PoolFactor'} // $na);

            if (defined $calc_debug_info_ref->{'AdditiveSafetyCapApplied'} && $calc_debug_info_ref->{'AdditiveSafetyCapApplied'} =~ /^True/)
            {
                printf {$fh} "    - Final Additive Safety Cap : %s\n", $calc_debug_info_ref->{'AdditiveSafetyCapApplied'};
            }
        }
        printf {$fh} "  => Final Additive CPU         : %s cores\n\n", ($calc_debug_info_ref->{'FinalAdditive'} // "0.0000");

        # --- Section D: Maximum CPU Sizing Sanity Checks ---
        print {$fh} "Section D: Maximum CPU Sizing Sanity Checks\n";
        printf {$fh} "  - Recommendation before Max Sanity Check  : %s cores\n", ($calc_debug_info_ref->{'PreMaxCpuCapRec'} // $na);
        printf {$fh} "  - LPAR MaxCPU (from VM config)            : %s cores\n", $lpar_max_cpu_display_A_log_sec;
        printf {$fh} "  - Entitlement (for forecast multiplier)   : %s cores\n", $entitlement_display_A_log_sec;
        printf {$fh} "  - Forecast Multiplier Used                : %s\n", ($calc_debug_info_ref->{'ForecastMultiplier'} // $na);
        printf {$fh} "  - Effective MaxCPU Sanity Limit           : %s cores\n", ($calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na);
        printf {$fh} "  - Limited by MaxCPU Sanity Check?         : %s\n", ($calc_debug_info_ref->{'CappedByMaxCPU'} // $na);
        printf {$fh} "  => Recommendation after Max Sanity Check  : %s cores\n\n", ($final_recommendation_unrounded_str // $na);
    } # End else for ReasonForNoModification (main calculation block)

    # --- Footer Block (Bottom Summary) ---
    print {$fh} "----------------------------------------------------------------------\n";
    printf {$fh} "Overall Summary for Profile: %s\n", $profile_being_adjusted;
    printf {$fh} "  Final Recommended Value : %s cores (Unrounded: %s)\n",
                 ($final_csv_value_for_profile // $na), # This is rounded for CSV
                 $final_recommendation_unrounded_str;    # This is unrounded from calc
    print  {$fh} "  Key Decision Path & Justification:\n";

    # --- Correctly source nfit's GrowthAdj from the state data ---
    my $nfit_growth_adj_to_display = "0.0000"; # Default value
    if (ref($raw_nfit_states_aref) eq 'ARRAY' && @$raw_nfit_states_aref)
    {
        # If nfit did its own aggregation (i.e., --enable-windowed-decay was on),
        # it returns one state/result line which contains the final GrowthAdj.
        # We display that value. Otherwise, this is not applicable at the nfit level.
        $nfit_growth_adj_to_display = $raw_nfit_states_aref->[0]->{GrowthAdj} // "0.0000";
    }

    printf {$fh} "    - Initial Base PhysC        : %s cores (Aggregated from nfit states. Includes nfit's GrowthAdj: %s)\n",
                 ($base_physc_for_profile // $na),
                 $nfit_growth_adj_to_display;

    my $downsizing_summary_reason_footer = $calc_debug_info_ref->{'DownsizingReason'} // "N/A";
    if (length($downsizing_summary_reason_footer) > 70) { $downsizing_summary_reason_footer = substr($downsizing_summary_reason_footer, 0, 67) . "..."; }
    printf {$fh} "    - CPU Downsizing            : Factor %s -> PhysC became %s. (Summary: %s)\n",
                 ($calc_debug_info_ref->{'DownsizingFactor'} // $na),
                 ($calc_debug_info_ref->{'PhysCAfterDownsizing'} // $na),
                 $downsizing_summary_reason_footer;

    my $additive_final_val_footer = $calc_debug_info_ref->{'FinalAdditive'} // "0.0000";
    my $additive_reason_summary_footer = "Not applied or N/A";
    my $additive_is_applied_footer_flag = (defined $additive_final_val_footer && ($additive_final_val_footer+0) > $FLOAT_EPSILON) ||
                                          (defined $calc_debug_info_ref->{'ExcessThreads'} && $calc_debug_info_ref->{'ExcessThreads'} !~ /No excess/i && $calc_debug_info_ref->{'ExcessThreads'} ne "N/A");


    if ($additive_is_applied_footer_flag || ($calc_debug_info_ref->{'IsRunQPressure'} eq "True" || $calc_debug_info_ref->{'IsWorkloadPressure'} eq "True") )
    {
        $additive_reason_summary_footer = "Pressure detected";
        my @pressure_types_footer;
        if ($calc_debug_info_ref->{'IsRunQPressure'} eq "True") { push @pressure_types_footer, "Overall LPAR"; }
        if ($calc_debug_info_ref->{'IsWorkloadPressure'} eq "True") { push @pressure_types_footer, "Normalized Workload"; }
        if (@pressure_types_footer) { $additive_reason_summary_footer .= " (" . join(", ", @pressure_types_footer) . ")";}
        else { $additive_reason_summary_footer .= " (Type N/A)";}

        if (defined $calc_debug_info_ref->{'HotThreadWLDampeningApplied'} && $calc_debug_info_ref->{'HotThreadWLDampeningApplied'} eq "True")
        {
            $additive_reason_summary_footer .= "; HTW Dampened";
        }
        if (defined $calc_debug_info_ref->{'AdditiveSafetyCapApplied'} && $calc_debug_info_ref->{'AdditiveSafetyCapApplied'} =~ /^True/)
        {
            $additive_reason_summary_footer .= "; Safety Capped";
        }
         # Add note if additive ended up zero despite pressure
        if (abs(($additive_final_val_footer // 0)+0) < $FLOAT_EPSILON && ($calc_debug_info_ref->{'IsRunQPressure'} eq "True" || $calc_debug_info_ref->{'IsWorkloadPressure'} eq "True")) {
            $additive_reason_summary_footer .= "; Final Additive Zero (due to caps/dampening)";
        }
    }
    elsif (abs(($additive_final_val_footer // 0)+0) < $FLOAT_EPSILON)
    {
         $additive_reason_summary_footer = "No significant pressure, or additive calculated to zero.";
         if (defined $calc_debug_info_ref->{'ExcessThreads'} && $calc_debug_info_ref->{'ExcessThreads'} =~ /No excess threads/i) { # Match specific string
             $additive_reason_summary_footer = "No excess threads calculated for additive.";
         }
    }
    printf {$fh} "    - CPU Upsizing (Additive)   : %s cores. (Reason: %s)\n",
                 $additive_final_val_footer, $additive_reason_summary_footer;

    my $lpar_cap_applied_summary_footer = "Not applied or N/A";
    if (defined $calc_debug_info_ref->{'CappedByMaxCPU'})
    {
        $lpar_cap_applied_summary_footer = $calc_debug_info_ref->{'CappedByMaxCPU'} eq "True"
                                   ? "Applied (Effective Limit: " . ($calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na) . ")"
                                   : "Not Applied (Effective Limit: " . ($calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na) . ")";
    }
    printf {$fh} "    - Max CPU Sanity Check      : %s\n", $lpar_cap_applied_summary_footer;
    print {$fh} "======================================================================\n\n";

} # End of log_profile_rationale

# --- Helper subroutine to parse and collate percentile lists for nfit calls ---
# Takes an existing list of percentiles (as a comma-separated string) and an array
# of numeric percentiles that must be ensured to be present in the final list.
# Returns a sorted, unique array of percentile strings, formatted for nfit.
sub parse_and_collate_percentiles
{
    my ($existing_perc_list_str, @ensure_these_percs_numeric) = @_;
    my %final_percs_map; # Use a hash to store unique percentiles to avoid duplicates

    # Add percentiles from the existing string (e.g., from profile flags or global nfit-profile default)
    if (defined $existing_perc_list_str && $existing_perc_list_str ne '')
    {
        my @raw_list = split /,\s*/, $existing_perc_list_str;
        foreach my $p_str (@raw_list)
        {
            next if $p_str eq ''; # Skip empty strings that might result from split (e.g. "80,,90")

            # Validate if it looks like a percentile number, then format it consistently for nfit
            if ($p_str =~ /^[0-9.]+$/ && $p_str >= 0 && $p_str <= 100)
            {
                my $p_label = sprintf("%.2f", $p_str + 0); # Normalize format (e.g., "90.00")
                $p_label =~ s/\.?0+$//;                    # Clean trailing ".00" (e.g., "90")
                $p_label = "0" if $p_label eq "" && abs(($p_str+0) - 0) < 0.001; # Handle case of "0.00" -> "0"
                $final_percs_map{$p_label} = 1; # Add to hash (value 1 is arbitrary, key is what matters)
            }
            else
            {
                # If it's not a simple number, it might be an invalid value.
                # nfit.pl will ultimately validate it. For now, include as is.
                # Alternatively, one could issue a warning here:
                # warn "Warning: Non-standard percentile string '$p_str' found in list '$existing_perc_list_str'. Passing to nfit as is.\n";
                $final_percs_map{$p_str} = 1;
            }
        }
    }

    # Add percentiles that must be ensured (e.g., P90 for AbsRunQ, P50/P90 for NormRunQ)
    foreach my $p_num (@ensure_these_percs_numeric)
    {
        my $p_label = sprintf("%.2f", $p_num); # Format, e.g., 90 -> "90.00", 98.5 -> "98.50"
        $p_label =~ s/\.?0+$//;                # Clean to "90", "98.5"
        $p_label = "0" if $p_label eq "" && abs($p_num - 0) < 0.001; # "0.00" -> "0"
        $final_percs_map{$p_label} = 1; # Add/overwrite in hash to ensure it's present
    }

    # Return a numerically sorted list of unique percentile strings
    my @sorted_keys = sort {
        # Robust sort: treat as numbers if possible, otherwise string compare
        my $is_a_num = ($a =~ /^[0-9.]+$/); # Check if $a looks like a number
        my $is_b_num = ($b =~ /^[0-9.]+$/); # Check if $b looks like a number
        if ($is_a_num && $is_b_num) { return ($a+0) <=> ($b+0); } # Both are numbers, numeric sort
        elsif ($is_a_num) { return -1; } # Numbers come before non-numbers
        elsif ($is_b_num) { return 1;  } # Non-numbers come after numbers
        else { return $a cmp $b; }       # Both are non-numbers (e.g. invalid values), string compare
    } keys %final_percs_map; # Get unique keys from hash and sort them

    return @sorted_keys;
}

# --- quote_csv ---
# Ensures a string is properly quoted for CSV output, escaping internal double quotes.
sub quote_csv
{
    my ($field) = @_;
    if (!defined $field) # Handle undefined fields as empty strings
    {
        $field = '';
    }
    $field =~ s/"/""/g; # Escape any double quotes within the field by doubling them
    return qq/"$field"/; # Enclose the entire field in double quotes
}

# --- load_profile_definitions ---
# Loads profile configurations from the specified INI-like file.
# Each section [Profile Name] defines a profile.
# Keys: nfit_flags (mandatory), runq_modifier_behavior (optional, default: 'default').
sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef; # Name of the current [Profile] being parsed
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath
        or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//;    # Remove comments starting with #
        $line =~ s/\s*;.*//;    # Remove comments starting with ; (alternative comment)
        $line =~ s/^\s+|\s+$//g; # Trim leading/trailing whitespace
        next if $line eq '';    # Skip empty lines or lines that became empty after comment removal

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/) # Matches section header like [Profile Name]
        {
            # Before starting a new section, check if the previous one was potentially incomplete
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags} && # Flags are mandatory
                (!defined $loaded_profiles_list[-1]{runq_behavior} || $loaded_profiles_list[-1]{runq_behavior} eq 'default') )
            {
                 my $is_incomplete = 1;
                 # A profile needs flags to be valid. If flags were somehow defined but this check missed it,
                 # this might be overly cautious, but missing flags is the primary concern.
                 if (defined $loaded_profiles_list[-1]{flags})
                 {
                    $is_incomplete = 0;
                 }
                 if ($is_incomplete)
                 {
                    warn "Warning: Profile section '[$current_section_name]' in '$filepath' (ending before line $line_number) appears incomplete (missing nfit_flags). Skipping this potentially malformed entry.\n";
                    pop @loaded_profiles_list; # Remove the incomplete profile
                 }
            }

            $current_section_name = $1; # Capture profile name from section header
            $current_section_name =~ s/^\s+|\s+$//g; # Trim spaces from profile name
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef; # Reset current section context
                next;
            }
            # Initialize the new profile with its name and default runq_behavior. Flags added later.
            push @loaded_profiles_list, { name => $current_section_name, flags => undef, runq_behavior => 'default' };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/) # Matches key-value pair like nfit_flags = ...
        {
            my $key = lc($1); # Key name (lowercase for case-insensitivity)
            my $value = $2;   # Value
            $key =~ s/^\s+|\s+$//g;   # Trim spaces from key
            $value =~ s/^\s+|\s+$//g; # Trim spaces from value

            # Ensure we are adding to the currently parsed profile
            if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
            {
                if ($key eq 'nfit_flags')
                {
                    if (defined $loaded_profiles_list[-1]{flags}) # Check for duplicate flags
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one defined.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                elsif ($key eq 'runq_modifier_behavior')
                {
                     if (defined $loaded_profiles_list[-1]{runq_behavior} && $loaded_profiles_list[-1]{runq_behavior} ne 'default')
                    { # Check for duplicate runq_behavior definition
                        warn "Warning: Duplicate 'runq_modifier_behavior' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one defined.\n";
                    }
                    # Validate the value for runq_modifier_behavior
                    if ($value eq 'additive_only' || $value eq 'default')
                    {
                        $loaded_profiles_list[-1]{runq_behavior} = $value;
                    }
                    else
                    {
                        warn "Warning: Invalid value '$value' for 'runq_modifier_behavior' in profile '[$current_section_name]' (line $line_number). Using default. Allowed: additive_only, default.\n";
                        $loaded_profiles_list[-1]{runq_behavior} = 'default'; # Fallback to default if invalid value
                    }
                }
                # Add other potential profile-specific keys here if needed in the future
                # else { warn "Warning: Unknown key '$key' in profile '[$current_section_name]' ..."; }
            }
            else # Key-value pair found outside a valid section or for a mismatched section
            {
                 warn "Warning: Key-value pair '$key=$value' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping.\n";
            }
        }
        elsif ($line ne '') # Non-empty line that doesn't match section or key-value format
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    } # End while loop reading file
    close $fh;

    # Final validation of loaded profiles: ensure all valid profiles have 'nfit_flags'
    my @valid_profiles;
    foreach my $p_ref (@loaded_profiles_list)
    {
        if (defined $p_ref->{flags} && $p_ref->{flags} ne '')
        {
            # runq_behavior is already defaulted or set during parsing
            push @valid_profiles, $p_ref;
        }
        else # Profile is missing the mandatory 'nfit_flags'
        {
            warn "Warning: Profile '[" . $p_ref->{name} . "]' in '$filepath' is missing mandatory 'nfit_flags' definition. Removing this profile from processing.\n";
        }
    }
    return @valid_profiles;
}

# --- calculate_runq_modified_physc (with enhanced efficiency logic and detailed debug output) ---
# Calculates the final PhysC value for a profile after applying efficiency factors
# and RunQ-driven additive CPU adjustments.
# Takes the raw PhysC from nfit, RunQ metrics, SMT, entitlement, MaxCPU, etc.
# Returns the adjusted PhysC value and a hash of debug information for logging.
sub calculate_runq_modified_physc
{
    my (
        $selected_tier_physc_value_str,
        $norm_runq_p25_str,
        $norm_runq_p50_str,
        $norm_runq_p75_str,
        $norm_runq_p90_str,
        $abs_runq_p_value_str,
        $abs_runq_key_for_debug,
        $smt_used,
        $current_entitlement_str,
        $max_cpu_config_str,
        $is_in_non_default_pool,
        $profile_runq_behavior_setting,
        $p99w1_overall_vm_has_abs_runq_pressure,
        $p99w1_overall_vm_has_norm_runq_pressure
    ) = @_;

    my %debug_info;
    my $na_str = "N/A";

    # --- Initialize all debug fields to sensible defaults or N/A ---
    $debug_info{'AbsRunQKeyUsed'} = $abs_runq_key_for_debug // 'N/A (key not provided)';
    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // $na_str;
    $profile_runq_behavior_setting //= 'default';

    my $base_physc = ($selected_tier_physc_value_str ne $na_str && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/)
                   ? ($selected_tier_physc_value_str + 0)
                   : undef;

    # Efficiency related fields - meticulously initialized
    $debug_info{'DownsizingReason'} = "Efficiency calculation not initiated or skipped by initial guards.";
    $debug_info{'DownsizingFactor'} = "1.00"; # This will be the final sprintf'd version
    $debug_info{'EffCondNormP50Met'} = undef; # Boolean: NormP50 low enough?
    $debug_info{'EffCondVolatilityMet'} = undef; # Boolean: Volatility acceptable?
    $debug_info{'EffVolatilityRatio'} = $na_str;
    $debug_info{'EffPBase'} = (defined $base_physc) ? sprintf("%.4f", $base_physc) : $na_str;
    $debug_info{'EffSMTValue'} = $smt_used // $na_str;
    $debug_info{'EffTargetNormRunQ'} = $na_str;
    $debug_info{'EffPEfficientTargetRaw'} = $na_str; # Raw target before blending
    $debug_info{'EffBlendReason'} = "Blending not applied or not applicable.";
    $debug_info{'EffBlendWeightBase'} = $na_str;   # e.g., 0.75
    $debug_info{'EffBlendWeightTarget'} = $na_str; # e.g., 0.25
    $debug_info{'EffPEfficientTarget'} = $na_str; # This will be the blended target
    $debug_info{'EffComparisonBaseVsTargetMet'} = undef; # Boolean: Base > Blended Target?
    $debug_info{'EffPotentialReduction'} = $na_str;
    $debug_info{'EffMaxAllowableReductionPerc'} = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * 100; # Default cap %
    $debug_info{'EffReductionCapReason'} = "Default reduction cap applied.";
    $debug_info{'EffMaxAllowableReductionCores'} = $na_str;
    $debug_info{'EffActualReductionCores'} = $na_str;
    $debug_info{'EffCalculatedFactor'} = "1.0000"; # Raw, unformatted factor
    $debug_info{'EffFinalFactorApplied'} = "1.00"; # Formatted, final factor used

    # General fields
    $debug_info{'DownsizedPhysC'} = defined($base_physc) ? sprintf("%.4f", $base_physc) : $na_str; # PhysC after efficiency
    $debug_info{'RunQPressure_P90_Val'} = $na_str; $debug_info{'IsRunQPressure'} = "False";
    $debug_info{'IsWorkloadPressure'} = "False"; $debug_info{'WorkloadPressureReason'} = "Conditions not met or N/A inputs";
    $debug_info{'EffectiveLCPUsAtBase'} = $na_str; $debug_info{'ExcessThreads'} = $na_str;
    $debug_info{'RawAdditive'} = "0.0000"; $debug_info{'MaxAdditiveCap'} = "0.0000"; $debug_info{'CappedRawAdditive'} = "0.0000";
    $debug_info{'VoltFactorReason'} = "Default (no overriding condition met or additive not applied)";
    $debug_info{'VoltFactor'} = "1.00";
    $debug_info{'PoolFactor'} = "1.00";
    $debug_info{'FinalAdditive'} = "0.0000";
    $debug_info{'PreMaxCpuCapRec'} = $debug_info{'DownsizedPhysC'};
    $debug_info{'LPARMaxCPUConfig'} = ($max_cpu_config_str ne "" && $max_cpu_config_str =~ /^[0-9.]+$/ && ($max_cpu_config_str+0) > 0)
                                   ? ($max_cpu_config_str+0) : $na_str;
    $debug_info{'EntitlementForForecast'} = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/)
                                         ? ($current_entitlement_str + 0) : 0;
    $debug_info{'ForecastMultiplier'} = $na_str; $debug_info{'EffectiveMaxCPUCap'} = $na_str;
    $debug_info{'CappedByMaxCPU'} = $na_str;
    $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BasePhysC'}; # Default final is same as base
    $debug_info{'ReasonForNoModification'} = "";

    my $curr_ent_numeric = $debug_info{'EntitlementForForecast'};
    my $eff_p_base_numeric = defined($base_physc) ? $base_physc : undef;
    $debug_info{'EffPBase'} = defined($eff_p_base_numeric) ? sprintf("%.4f", $eff_p_base_numeric) : $na_str;


    unless (defined $base_physc)
    {
        $debug_info{'ReasonForNoModification'} = "BasePhysC for profile not numeric or N/A";
        $debug_info{'FinalAdjustedPhysC'} = $selected_tier_physc_value_str // $na_str;
        return ($selected_tier_physc_value_str // $na_str, \%debug_info);
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne $na_str && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne $na_str && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_runq_p_numeric  = ($abs_runq_p_value_str  ne $na_str && $abs_runq_p_value_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p_value_str + 0)  : undef;
    my $max_cpu_for_lpar_numeric = ($debug_info{'LPARMaxCPUConfig'} ne $na_str) ? $debug_info{'LPARMaxCPUConfig'} : 0;
    my $norm_p25_numeric = ($norm_runq_p25_str ne $na_str && $norm_runq_p25_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p25_str + 0) : undef;
    my $norm_p75_numeric = ($norm_runq_p75_str ne $na_str && $norm_runq_p75_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p75_str + 0) : undef;
    my $normrunq_iqrc_val = undef;
    if (defined $norm_p25_numeric && defined $norm_p50_numeric && defined $norm_p75_numeric)
    {
          my $p50_denominator_for_iqrc = (abs($norm_p50_numeric) > $MIN_P50_DENOMINATOR_FOR_VOLATILITY)
                                                 ? $norm_p50_numeric
                                                 : (($norm_p50_numeric >= 0) ? $MIN_P50_DENOMINATOR_FOR_VOLATILITY : -$MIN_P50_DENOMINATOR_FOR_VOLATILITY);
          if (abs($p50_denominator_for_iqrc) > $FLOAT_EPSILON)
          {
                $normrunq_iqrc_val = ($norm_p75_numeric - $norm_p25_numeric) / $p50_denominator_for_iqrc;
          }
          elsif (abs($norm_p75_numeric - $norm_p25_numeric) < $FLOAT_EPSILON)
          {
                $normrunq_iqrc_val = 0.0;
          }
          else
          {
                $normrunq_iqrc_val = 999.0;
          }
    }
    $debug_info{'NormRunQ_P25_Val'} = (defined $norm_p25_numeric) ? sprintf("%.2f", $norm_p25_numeric) : $na_str;
    $debug_info{'NormRunQ_P50_Val'} = (defined $norm_p50_numeric) ? sprintf("%.2f", $norm_p50_numeric) : $na_str;
    $debug_info{'NormRunQ_P75_Val'} = (defined $norm_p75_numeric) ? sprintf("%.2f", $norm_p75_numeric) : $na_str;
    $debug_info{'NormRunQ_IQRC_Val'} = (defined $normrunq_iqrc_val) ? sprintf("%.3f", $normrunq_iqrc_val) : $na_str;

    my $efficiency_factor_numeric = 1.00;
    $debug_info{'DownsizingFactor'} = sprintf("%.2f", $efficiency_factor_numeric);
    $debug_info{'DownsizingReason'} = "Default (No CPU downsizing applied or eligible).";
    my $analytical_efficiency_path_attempted = 0;

    if ( (defined $p99w1_overall_vm_has_abs_runq_pressure && $p99w1_overall_vm_has_abs_runq_pressure) ||
         (defined $p99w1_overall_vm_has_norm_runq_pressure && $p99w1_overall_vm_has_norm_runq_pressure) )
    {
        $debug_info{'DownsizingReason'} = sprintf(
            "Skipped CPU Downsizing: VM's %s profile shows RunQ pressure (Abs P-99W1 pressure: %s, Norm P-99W1 pressure: %s).",
            $MANDATORY_PEAK_PROFILE_FOR_HINT,
            $p99w1_overall_vm_has_abs_runq_pressure ? "TRUE" : "FALSE",
            $p99w1_overall_vm_has_norm_runq_pressure ? "TRUE" : "FALSE"
        );
    }
    elsif ($profile_runq_behavior_setting eq 'additive_only') {
        $debug_info{'DownsizingReason'} = "Skipped CPU Downsizing: Profile runq_behavior=additive_only";
    }
    elsif (defined $curr_ent_numeric && $curr_ent_numeric > 0 && defined $eff_p_base_numeric && $eff_p_base_numeric > $curr_ent_numeric) {
        $debug_info{'DownsizingReason'} = sprintf("Skipped CPU Downsizing: Base PhysC (%.4f) > Entitlement (%.2f)", $eff_p_base_numeric, $curr_ent_numeric);
    }
    elsif ($max_cpu_for_lpar_numeric > 0 && defined $eff_p_base_numeric && $eff_p_base_numeric > ($max_cpu_for_lpar_numeric * $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD)) {
        my $temp_runq_pressure_val = 0;
        if (defined $abs_runq_p_numeric && $smt_used > 0) {
            $temp_runq_pressure_val = $abs_runq_p_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
        }
        if ($temp_runq_pressure_val > ($RUNQ_PRESSURE_P90_SATURATION_THRESHOLD * $RUNQ_PRESSURE_FOR_CONSTRAINT_GUARD_FACTOR)) {
            $debug_info{'DownsizingReason'} = sprintf("Skipped CPU Downsizing: High existing constraint. Base PhysC (%.4f) > %.0f%% of MaxCPU (%.2f) AND RunQ Pressure (%.2f) is high.",
                                                     $eff_p_base_numeric, $BASE_PHYSC_VS_MAXCPU_THRESH_FOR_CONSTRAINT_GUARD*100, $max_cpu_for_lpar_numeric, $temp_runq_pressure_val);
        } else {
            $analytical_efficiency_path_attempted = 1;
        }
    } else {
        $analytical_efficiency_path_attempted = 1;
    }

    if ($analytical_efficiency_path_attempted && defined $norm_p50_numeric && defined $norm_p90_numeric && defined $abs_runq_p_numeric && $smt_used > 0 && defined $eff_p_base_numeric)
    {
        $debug_info{'EffCondNormP50Met'} = ($norm_p50_numeric < $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION);
        my $effective_p50_for_volatility = ($norm_p50_numeric > 0.0001)
                                         ? max($norm_p50_numeric, $MIN_P50_DENOMINATOR_FOR_VOLATILITY)
                                         : $MIN_P50_DENOMINATOR_FOR_VOLATILITY;
        my $volatility_ratio = (defined $norm_p90_numeric && $effective_p50_for_volatility > 0.0001)
                               ? ($norm_p90_numeric / $effective_p50_for_volatility)
                               : 1.0;
        $debug_info{'EffVolatilityRatio'} = sprintf("%.2f", $volatility_ratio);
        $debug_info{'EffCondVolatilityMet'} = ($volatility_ratio < $VOLATILITY_CAUTION_THRESHOLD);

        if (!$debug_info{'EffCondVolatilityMet'}) {
             $debug_info{'DownsizingReason'} = sprintf("Skipped CPU Downsizing: Workload volatile (NormP90/P50 ratio %.2f >= %.2f). No analytical reduction.", $volatility_ratio, $VOLATILITY_CAUTION_THRESHOLD);
        }
        elsif (!$debug_info{'EffCondNormP50Met'}) {
             $debug_info{'DownsizingReason'} = sprintf("Skipped CPU Downsizing: NormRunQ P50 (%.2f) not below threshold (%.2f) for efficiency consideration. No analytical reduction.",
                                                     $norm_p50_numeric, $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION);
        }
        else
        {
            my $target_norm_runq_eff_calc = $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC;
            if ($smt_used >= 8) { $target_norm_runq_eff_calc = 0.80; }
            elsif ($smt_used >= 4) { $target_norm_runq_eff_calc = 0.75; }
            else { $target_norm_runq_eff_calc = 0.60; }
            $debug_info{'EffTargetNormRunQ'} = sprintf("%.2f", $target_norm_runq_eff_calc);

            my $p_efficient_target_raw = ($smt_used * $target_norm_runq_eff_calc > 0.0001)
                                       ? ($abs_runq_p_numeric / ($smt_used * $target_norm_runq_eff_calc))
                                       : $eff_p_base_numeric + 1;
            $debug_info{'EffPEfficientTargetRaw'} = sprintf("%.4f", $p_efficient_target_raw);
            my $base_physc_weight = $BLEND_WEIGHT_BASE_DEFAULT_LOW_P50;
            my $efficient_target_weight = 1.0 - $base_physc_weight;
            my $blending_details_str = sprintf("Default low P50 blend (%.0f%% Base / %.0f%% Target).", $base_physc_weight*100, $efficient_target_weight*100);

            if ($norm_p50_numeric < $NORM_P50_LOW_THRESH_FOR_BLEND1) {
                $base_physc_weight = $BLEND_WEIGHT_BASE_FOR_LOW_P50_1;
                $efficient_target_weight = 1.0 - $base_physc_weight;
                $blending_details_str = sprintf("NormP50 (%.2f) < %.2f, using more aggressive blend (%.0f%% Base / %.0f%% Target).",
                                                $norm_p50_numeric, $NORM_P50_LOW_THRESH_FOR_BLEND1, $base_physc_weight*100, $efficient_target_weight*100);
            } elsif ($norm_p50_numeric < $NORM_P50_MODERATE_THRESH_FOR_BLEND2) {
                $base_physc_weight = $BLEND_WEIGHT_BASE_FOR_LOW_P50_2;
                $efficient_target_weight = 1.0 - $base_physc_weight;
                $blending_details_str = sprintf("NormP50 (%.2f) < %.2f, using moderate blend (%.0f%% Base / %.0f%% Target).",
                                                $norm_p50_numeric, $NORM_P50_MODERATE_THRESH_FOR_BLEND2, $base_physc_weight*100, $efficient_target_weight*100);
            }
            $debug_info{'EffBlendWeightBase'} = sprintf("%.2f", $base_physc_weight);
            $debug_info{'EffBlendWeightTarget'} = sprintf("%.2f", $efficient_target_weight);
            $debug_info{'EffBlendReason'} = $blending_details_str;

            my $blended_efficient_target = ($eff_p_base_numeric * $base_physc_weight) + ($p_efficient_target_raw * $efficient_target_weight);
            $debug_info{'EffPEfficientTarget'} = sprintf("%.4f", $blended_efficient_target);
            $debug_info{'EffComparisonBaseVsTargetMet'} = ($eff_p_base_numeric > $blended_efficient_target);

            if ($debug_info{'EffComparisonBaseVsTargetMet'})
            {
                my $potential_reduction_cores = $eff_p_base_numeric - $blended_efficient_target;
                $debug_info{'EffPotentialReduction'} = sprintf("%.4f", $potential_reduction_cores);
                my $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE;
                my $reduction_cap_reason_template = "Volatility (%.2f) low, using full reduction cap of %.1f%%.";

                if ($volatility_ratio > $VOLATILITY_MODERATE_HIGH_CAP_THRESH) {
                    $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * $REDUCTION_CAP_SCALE_FOR_MODERATE_HIGH_VOLATILITY;
                    $reduction_cap_reason_template = "Volatility (%.2f) moderately high (>%.2f), reduction cap limited to %.1f%%.";
                    $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $VOLATILITY_MODERATE_HIGH_CAP_THRESH, $current_max_reduction_perc_val * 100);
                } elsif ($volatility_ratio > $VOLATILITY_MODERATE_LOW_CAP_THRESH) {
                    $current_max_reduction_perc_val = $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * $REDUCTION_CAP_SCALE_FOR_MODERATE_VOLATILITY;
                    $reduction_cap_reason_template = "Volatility (%.2f) moderate (>%.2f), reduction cap limited to %.1f%%.";
                    $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $VOLATILITY_MODERATE_LOW_CAP_THRESH, $current_max_reduction_perc_val * 100);
                } else {
                     $debug_info{'EffReductionCapReason'} = sprintf($reduction_cap_reason_template, $volatility_ratio, $current_max_reduction_perc_val * 100);
                }
                $debug_info{'EffMaxAllowableReductionPerc'} = $current_max_reduction_perc_val * 100;
                my $max_allowable_reduction_cores = $eff_p_base_numeric * $current_max_reduction_perc_val;
                $debug_info{'EffMaxAllowableReductionCores'} = sprintf("%.4f", $max_allowable_reduction_cores);
                my $actual_reduction_cores = min($potential_reduction_cores, $max_allowable_reduction_cores);
                $actual_reduction_cores = max(0, $actual_reduction_cores);
                $debug_info{'EffActualReductionCores'} = sprintf("%.4f", $actual_reduction_cores);

                if ($actual_reduction_cores > 0.0001)
                {
                    my $new_physc_after_reduction = $eff_p_base_numeric - $actual_reduction_cores;
                    $efficiency_factor_numeric = ($eff_p_base_numeric > 0.0001) ? ($new_physc_after_reduction / $eff_p_base_numeric) : 1.00;
                    my $min_expected_eff_factor = 1 - $current_max_reduction_perc_val;
                    if ($efficiency_factor_numeric < ($min_expected_eff_factor - 0.001) ) {$efficiency_factor_numeric = $min_expected_eff_factor;}
                    $efficiency_factor_numeric = 1.00 if $efficiency_factor_numeric > 1.00;
                    $efficiency_factor_numeric = max(0, $efficiency_factor_numeric);
                    $debug_info{'EffCalculatedFactor'} = sprintf("%.4f", $efficiency_factor_numeric);
                    $debug_info{'EffFinalFactorApplied'} = sprintf("%.2f", $efficiency_factor_numeric);
                    $debug_info{'DownsizingReason'} = sprintf("Analytical CPU Downsizing (using blended target & dynamic cap): Reduction of %.4f cores applied.", $actual_reduction_cores);
                }
                else
                {
                    $debug_info{'EffFinalFactorApplied'} = "1.00";
                    $debug_info{'EffCalculatedFactor'} = "1.0000";
                    $debug_info{'DownsizingReason'} = sprintf("Analytical CPU Downsizing (using blended target & dynamic cap): Base_PhysC %.4f, Blended_Target %.4f. Calculated reduction (%.4f) negligible or zero. No adjustment from this path.",
                                                             $eff_p_base_numeric, $blended_efficient_target, $actual_reduction_cores // 0.0);
                }
            }
            else
            {
                 $debug_info{'EffFinalFactorApplied'} = "1.00";
                 $debug_info{'EffCalculatedFactor'} = "1.0000";
                 $debug_info{'DownsizingReason'} = sprintf("Analytical CPU Downsizing: Base_PhysC %.4f not greater than Blended_Efficient_Target_PhysC %.4f. No reduction. Blending Reason: %s",
                                                         $eff_p_base_numeric, $blended_efficient_target, $blending_details_str);
            }
        }
    }
    elsif ($analytical_efficiency_path_attempted && $debug_info{'DownsizingReason'} eq "Efficiency calculation not initiated or skipped by initial guards.")
    {
        $debug_info{'DownsizingReason'} = "Key metrics (NormP50/P90, AbsRunQ) N/A for full analytical CPU downsizing check. No efficiency adjustment applied.";
    }

    $debug_info{'DownsizingFactor'} = sprintf("%.2f", $efficiency_factor_numeric);

    my $base_adjusted_physc = (defined $eff_p_base_numeric ? $eff_p_base_numeric : 0) * $efficiency_factor_numeric;
    $debug_info{'DownsizedPhysC'} = sprintf("%.4f", $base_adjusted_physc);

    unless (defined $abs_runq_p_numeric && $smt_used > 0 && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) )
    {
        $debug_info{'ReasonForNoModification'} = ($debug_info{'ReasonForNoModification'} eq "")
            ? "Missing essential RunQ or contextual metrics for further modifier logic after efficiency step."
            : $debug_info{'ReasonForNoModification'};
        $debug_info{'VoltFactorReason'} = "Skipped: " . ($debug_info{'ReasonForNoModification'} || "Essential metrics N/A for additive logic");
        $debug_info{'FinalAdjustedPhysC'} = $debug_info{'DownsizedPhysC'};

        return ($base_adjusted_physc, \%debug_info);
    }

    my $runq_pressure_p_val = 0;
    if ($max_cpu_for_lpar_numeric > 0 && $smt_used > 0)
    {
        $runq_pressure_p_val = $abs_runq_p_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
    }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p_val);
    my $is_runq_pressure = ($runq_pressure_p_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False";

    my $is_workload_pressure_calc = 0;
    my $workload_pressure_reason_str_calc = "Workload pressure conditions not met or inputs N/A.";
    my $min_absrunq_for_workload_pressure_check = $smt_used;

    if (defined $norm_p90_numeric)
    {
        if ($norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
        {
            if (defined $abs_runq_p_numeric && $abs_runq_p_numeric >= $min_absrunq_for_workload_pressure_check)
            {
                $is_workload_pressure_calc = 1;
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f) AND AbsRunQ (%s=%.2f) >= SMT-based min threshold (%.2f)",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $debug_info{AbsRunQKeyUsed}, $abs_runq_p_numeric,
                                                      $min_absrunq_for_workload_pressure_check);
            }
            else
            {
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f), BUT AbsRunQ (%s=%.2f) < SMT-based min threshold (%.2f). Workload Pressure NOT flagged.",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $debug_info{AbsRunQKeyUsed}, $abs_runq_p_numeric // $na_str,
                                                      $min_absrunq_for_workload_pressure_check);
            }
        }
        else
        {
            $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) <= threshold (%.2f)",
                                                  $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
        }
    }
    else
    {
        $workload_pressure_reason_str_calc = "NormRunQ P90 N/A";
    }
    $debug_info{'IsWorkloadPressure'} = $is_workload_pressure_calc ? "True" : "False";
    $debug_info{'WorkloadPressureReason'} = $workload_pressure_reason_str_calc;

    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure_calc);
    my $additive_cpu = 0.0;
    my $raw_additive_cpu = 0.0;
    my $max_additive_cap_sliding = 0.0;
    my $capped_raw_additive_val = 0.0;
    my $volatility_confidence_factor = 1.0;
    my $pool_confidence_factor = 1.0;

    if ($apply_additive_logic)
    {
        my $effective_lcpus_at_original_base = (defined $eff_p_base_numeric ? $eff_p_base_numeric : 0) * $smt_used;
        $debug_info{'EffectiveLCPUsAtBase'} = sprintf("%.4f", $effective_lcpus_at_original_base);
        my $capacity_threshold_for_excess = $RUNQ_ADDITIVE_TOLERANCE_FACTOR * $effective_lcpus_at_original_base;
        my $excess_threads = (defined $abs_runq_p_numeric ? $abs_runq_p_numeric : 0) - $capacity_threshold_for_excess;

        if ($excess_threads > 0)
        {
            $debug_info{'ExcessThreads'} = sprintf("%.4f (AbsRunQ %s %.2f > Tolerated Capacity %.2f based on %.1f x %.4f LCPUs)",
                                                   $excess_threads,
                                                   $debug_info{AbsRunQKeyUsed}, ($abs_runq_p_numeric // 0.0),
                                                   $capacity_threshold_for_excess,
                                                   $RUNQ_ADDITIVE_TOLERANCE_FACTOR,
                                                   $effective_lcpus_at_original_base);
            $raw_additive_cpu = $excess_threads / $smt_used if $smt_used > 0;

            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1)      { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; }
            else                                             { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }

            $capped_raw_additive_val = min($raw_additive_cpu, $max_additive_cap_sliding);
            my $apply_hot_thread_wl_dampening = 0;
            my $hot_thread_wl_dampening_reason_str = "";
            my $hot_thread_wl_conditions_met_str = "";
            my $final_dynamic_dampening_factor = 1.0;

            $debug_info{'HotThreadWLDampeningApplied'} = "False";
            $debug_info{'HotThreadWLConditionsString'} = "N/A";
            $debug_info{'HotThreadWLDynamicFactor'} = "N/A";
            $debug_info{'HotThreadWLDampenedAdditiveFrom'} = "N/A";
            $debug_info{'HotThreadWLDampenedAdditiveTo'} = "N/A";

            if ($apply_additive_logic && $capped_raw_additive_val > $FLOAT_EPSILON)
            {
                 my @htw_conditions_met_details;
                 my $htw_condition_count = 0;
                 if ($is_workload_pressure_calc)
                 {
                      push @htw_conditions_met_details, "HighNormP90";
                      $htw_condition_count++;
                 }
                 my $cond2_underutilized = 0;
                 if (defined $base_physc && $base_physc > $FLOAT_EPSILON)
                 {
                      my $underutilized_vs_ent = (defined $curr_ent_numeric && $curr_ent_numeric > $FLOAT_EPSILON && $base_physc < ($curr_ent_numeric * $HOT_THREAD_WL_ENT_FACTOR));
                      my $underutilized_vs_maxcpu = (defined $max_cpu_for_lpar_numeric && $max_cpu_for_lpar_numeric > $FLOAT_EPSILON && $base_physc < ($max_cpu_for_lpar_numeric * $HOT_THREAD_WL_MAXCPU_FACTOR));
                      if ($underutilized_vs_ent || $underutilized_vs_maxcpu)
                      {
                            $cond2_underutilized = 1;
                            my $detail_ent_str = $underutilized_vs_ent ? sprintf("BaseP(%.2f)<Ent(%.2f)*%.1f", $base_physc, $curr_ent_numeric // 0, $HOT_THREAD_WL_ENT_FACTOR) : "";
                            my $detail_max_str = $underutilized_vs_maxcpu ? sprintf("BaseP(%.2f)<MaxP(%.2f)*%.1f", $base_physc, $max_cpu_for_lpar_numeric // 0, $HOT_THREAD_WL_MAXCPU_FACTOR) : "";
                            push @htw_conditions_met_details, "UnderutilizedCap(" . join(" or ", grep { $_ ne "" } $detail_ent_str, $detail_max_str) . ")";
                            $htw_condition_count++;
                      }
                 }
                 if (defined $norm_p50_numeric && $norm_p50_numeric > $HOT_THREAD_WL_HIGH_NORM_P50_THRESHOLD)
                 {
                      push @htw_conditions_met_details, sprintf("HighNormP50(%.2f>%.1f)", $norm_p50_numeric, $HOT_THREAD_WL_HIGH_NORM_P50_THRESHOLD);
                      $htw_condition_count++;
                 }
                 if (!$is_runq_pressure && defined $debug_info{'RunQPressure_P90_Val'} && $debug_info{'RunQPressure_P90_Val'} ne $na_str)
                 {
                      push @htw_conditions_met_details, sprintf("NoLPARRunQSat(AbsPVal:%.2f<%.1f)", ($debug_info{'RunQPressure_P90_Val'} + 0), $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
                      $htw_condition_count++;
                 }
                 if (defined $normrunq_iqrc_val && abs($normrunq_iqrc_val) > $HOT_THREAD_WL_IQRC_THRESHOLD)
                 {
                      push @htw_conditions_met_details, sprintf("HighIQRC(%.2f>%.1f)", $normrunq_iqrc_val, $HOT_THREAD_WL_IQRC_THRESHOLD);
                      $htw_condition_count++;
                 }
                 $hot_thread_wl_conditions_met_str = @htw_conditions_met_details ? join("; ", @htw_conditions_met_details) : "No specific conditions met";

                 if ($htw_condition_count >= $HOT_THREAD_WL_DETECTION_MIN_CONDITIONS_MET)
                 {
                      $apply_hot_thread_wl_dampening = 1;
                      $hot_thread_wl_dampening_reason_str = sprintf("Hot Thread Workload detected (%d/%d conditions met: %s). Applying dynamic dampening.",
                                                                    $htw_condition_count, 5, $hot_thread_wl_conditions_met_str);
                      my $util_ratio = (defined $max_cpu_for_lpar_numeric && $max_cpu_for_lpar_numeric > $FLOAT_EPSILON && defined $base_physc)
                                          ? ($base_physc / $max_cpu_for_lpar_numeric) : 1.0;
                      my $util_damp_multiplier = max(0.1, min(1.0, $util_ratio));
                      my $iqrc_damp_multiplier = (defined $normrunq_iqrc_val)
                                                        ? min(1.0, 1.0 / (1.0 + abs($normrunq_iqrc_val)))
                                                        : 1.0;
                      my $base_physc_severity_multiplier = (defined $base_physc && $base_physc > $FLOAT_EPSILON)
                                                                     ? min(1.0, $base_physc / 1.0)
                                                                     : 0.1;
                      my $calculated_dynamic_damp_factor = $HOT_THREAD_WL_BASE_DAMPENING_FACTOR *
                                                                   $util_damp_multiplier *
                                                                   $iqrc_damp_multiplier *
                                                                   $base_physc_severity_multiplier;

                      $final_dynamic_dampening_factor = max($HOT_THREAD_WL_MIN_DYNAMIC_DAMPENING,
                                                                         min($HOT_THREAD_WL_MAX_DYNAMIC_DAMPENING, $calculated_dynamic_damp_factor));
                      my $original_additive_val = $capped_raw_additive_val;
                      $capped_raw_additive_val *= $final_dynamic_dampening_factor;
                      $debug_info{'HotThreadWLDampeningApplied'} = "True";
                      $debug_info{'HotThreadWLConditionsString'} = $hot_thread_wl_conditions_met_str;
                      $debug_info{'HotThreadWLDynamicFactor'} = sprintf("%.4f (Base:%.2f UtilM:%.2f IqrcM:%.2f SevM:%.2f -> RawCalc:%.4f)",
                                                                      $final_dynamic_dampening_factor,
                                                                      $HOT_THREAD_WL_BASE_DAMPENING_FACTOR,
                                                                      $util_damp_multiplier,
                                                                      $iqrc_damp_multiplier,
                                                                      $base_physc_severity_multiplier,
                                                                      $calculated_dynamic_damp_factor);
                      $debug_info{'HotThreadWLDampenedAdditiveFrom'} = sprintf("%.4f", $original_additive_val);
                      $debug_info{'HotThreadWLDampenedAdditiveTo'} = sprintf("%.4f", $capped_raw_additive_val);
                      $debug_info{'CappedRawAdditive'} = sprintf("%.4f", $capped_raw_additive_val);
                 }
                 else
                 {
                      $debug_info{'HotThreadWLDampeningApplied'} = "False";
                      $debug_info{'HotThreadWLConditionsString'} = sprintf("Conditions not met for HTW dampening (%d/%d met: %s).",
                                                                         $htw_condition_count, 5, $hot_thread_wl_conditions_met_str);
                 }
            }

            if ($is_runq_pressure)
            {
                $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR;
                $debug_info{'VoltFactorReason'} = sprintf("RunQPressure Saturation (Factor set to %.2f)", $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR);
            }
            elsif ($is_workload_pressure_calc && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01)
            {
                my $volatility_ratio_for_factor = ($norm_p50_numeric > 0.01)
                                                 ? ($norm_p90_numeric / $norm_p50_numeric)
                                                 : 999;
                if ($volatility_ratio_for_factor < $VOLATILITY_SPIKY_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; }
                elsif ($volatility_ratio_for_factor < $VOLATILITY_MODERATE_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; }
                else { $volatility_confidence_factor = 1.0; }
                $debug_info{'VoltFactorReason'} = sprintf("Calculated (NormRQ P90/P50 ratio %.2f for WorkloadPressure -> Factor %.2f)", $volatility_ratio_for_factor, $volatility_confidence_factor);
            }
            else
            {
                 $debug_info{'VoltFactorReason'} = "Additive logic applied, but conditions for specific Volatility Factor adjustment not met (e.g., WorkloadPressure False or P50/P90 N/A for ratio). Using default factor.";
            }
            $additive_cpu = $capped_raw_additive_val * $volatility_confidence_factor;
            if ($is_in_non_default_pool && $additive_cpu > 0)
            {
                $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR;
                $additive_cpu *= $pool_confidence_factor;
            }
        }
        else
        {
            $debug_info{'ExcessThreads'} = sprintf("0.0000 (No excess above tolerated capacity of %.2f; AbsRunQ %s was %.2f)",
                                                   $capacity_threshold_for_excess,
                                                   $debug_info{AbsRunQKeyUsed}, ($abs_runq_p_numeric // $na_str));
            $raw_additive_cpu = 0.0;
            $capped_raw_additive_val = 0.0;
            $additive_cpu = 0.0;
            $debug_info{'VoltFactorReason'} = "No excess threads, so no additive CPU calculated.";
        }
    }
    else
    {
        $debug_info{'ExcessThreads'} = "N/A (Additive logic not applied as no significant pressure detected)";
        $debug_info{'VoltFactorReason'} = "Additive logic not applied.";
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu);
    $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding);
    $debug_info{'CappedRawAdditive'} = sprintf("%.4f", $capped_raw_additive_val);
    $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor);
    $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor);

    my $original_additive_before_safety_cap = $additive_cpu;
    my $additive_safety_cap_applied_reason = "Not applied";
    my $safety_cap_from_base = (defined $eff_p_base_numeric && $eff_p_base_numeric > $FLOAT_EPSILON)
                                     ? ($eff_p_base_numeric * $ADDITIVE_CPU_SAFETY_CAP_FACTOR_OF_BASE)
                                     : $ADDITIVE_CPU_SAFETY_CAP_ABSOLUTE;
    my $final_safety_cap_value = min($ADDITIVE_CPU_SAFETY_CAP_ABSOLUTE, $safety_cap_from_base);
    $final_safety_cap_value = max(0.0, $final_safety_cap_value);
    if ($additive_cpu > $final_safety_cap_value)
    {
         $additive_cpu = $final_safety_cap_value;
         $additive_safety_cap_applied_reason = sprintf("True: Additive CPU hard-capped to %.4f (min(%.2f abs_cap, %.2f * BaseP=%.4f))",
                                                                     $additive_cpu,
                                                                     $ADDITIVE_CPU_SAFETY_CAP_ABSOLUTE,
                                                                     $ADDITIVE_CPU_SAFETY_CAP_FACTOR_OF_BASE,
                                                                     $eff_p_base_numeric // 0.0);
    }
    else
    {
         $additive_safety_cap_applied_reason = sprintf("False (Additive %.4f within hard cap of %.4f)",
                                                                     $original_additive_before_safety_cap,
                                                                     $final_safety_cap_value);
    }
    $debug_info{'AdditiveSafetyCapApplied'} = $additive_safety_cap_applied_reason;
    $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);

    my $calculated_demand = $base_adjusted_physc + $additive_cpu;
    my $runq_modified_rec = $calculated_demand;
    $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    my $forecast_multiplier_val = 1.25;
    if ($curr_ent_numeric < 0.5)    { $forecast_multiplier_val = 2.5; }
    elsif ($curr_ent_numeric < 1.0) { $forecast_multiplier_val = 2.0; }
    elsif ($curr_ent_numeric < 2.0) { $forecast_multiplier_val = 1.75; }
    elsif ($curr_ent_numeric < 4.0) { $forecast_multiplier_val = 1.5; }
    $debug_info{'ForecastMultiplier'} = $forecast_multiplier_val;

    my $effective_max_cpu_cap_val = ($max_cpu_for_lpar_numeric > 0) ? ($max_cpu_for_lpar_numeric * $forecast_multiplier_val) : undef;
    $debug_info{'EffectiveMaxCPUCap'} = defined($effective_max_cpu_cap_val) ? sprintf("%.4f", $effective_max_cpu_cap_val) : $na_str;

    if (defined $effective_max_cpu_cap_val && $calculated_demand > $effective_max_cpu_cap_val)
    {
        $runq_modified_rec = $effective_max_cpu_cap_val;
        $debug_info{'CappedByMaxCPU'} = "True";
    }
    else
    {
      $debug_info{'CappedByMaxCPU'} = (defined $effective_max_cpu_cap_val) ? "False" : "N/A (No LPAR MaxCPU for cap check or MaxCPU not exceeded)";
    }

    if ($runq_modified_rec < 0) { $runq_modified_rec = 0; }
    $debug_info{'FinalAdjustedPhysC'} = sprintf("%.4f", $runq_modified_rec);

    return ($runq_modified_rec, \%debug_info);
}

# --- generate_sizing_hint (Unified Global Pressure Detection with Logging Rationale) ---
# Generates a sizing tier hint, pattern, and overall pressure indication for a VM.
# Also returns a detailed rationale string for its pressure assessment, AND
# specific boolean flags for P-99W1's RunQ pressure conditions.
sub generate_sizing_hint
{
    my %args = @_;
    my $results_ref                  = $args{'results_ref'};
    my $vm                           = $args{'vm'};
    my $config_ref                   = $args{'config_ref'};
    my $max_cpu_for_vm_numeric       = $args{'max_cpu_for_vm_numeric'} // 0;
    my $smt_used_for_vm_numeric      = $args{'smt_used_for_vm_numeric'} // 0;
    my $per_profile_runq_metrics_ref = $args{'per_profile_runq_metrics_ref'};

    # $MANDATORY_PEAK_PROFILE_FOR_HINT should be globally available or passed.
    # Example: my $MANDATORY_PEAK_PROFILE_FOR_HINT = "P-99W1"; (defined outside)

    my $na_str_hint = "N/A";
    my @global_pressure_rationale_lines;

    # ... (initial part of rationale logging: Inputs like MaxCPU, SMT etc. - as in previous version) ...
    push @global_pressure_rationale_lines, sprintf("  Input LPAR MaxCPU              : %.2f cores", $max_cpu_for_vm_numeric);
    push @global_pressure_rationale_lines, sprintf("  Input SMT for VM               : %d", $smt_used_for_vm_numeric);

    # --- VIO Server Check ---
    my $is_vio_server = 0;
    if (defined $config_ref &&
        defined $config_ref->{'systemtype'} &&
        $config_ref->{'systemtype'} =~ /VIO Server/i)
    {
        $is_vio_server = 1;
    }

    # --- Profile Value Parsing (Pattern/Peakiness & P-99W1 PhysC) ---
    my $o3_val_str = $results_ref->{$vm}{'O3-95W15'} // "0";
    my $o3_val_num = ($o3_val_str ne $na_str_hint && $o3_val_str =~ /^-?[0-9.]+\z/) ? ($o3_val_str + 0) : 0;
    my $b3_val_str = $results_ref->{$vm}{'B3-95W15'} // "0";
    my $b3_val_num = ($b3_val_str ne $na_str_hint && $b3_val_str =~ /^-?[0-9.]+\z/) ? ($b3_val_str + 0) : 0;
    my $g3_val_str = $results_ref->{$vm}{'G3-95W15'} // "0";
    my $g3_val_num = ($g3_val_str ne $na_str_hint && $g3_val_str =~ /^-?[0-9.]+\z/) ? ($g3_val_str + 0) : 0;
    my $p99w1_physc_val_str = $results_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT} // $na_str_hint;
    my $p99w1_physc_val_num = ($p99w1_physc_val_str ne $na_str_hint && $p99w1_physc_val_str =~ /^-?[0-9.]+\z/)
                           ? ($p99w1_physc_val_str + 0)
                           : 0;
    push @global_pressure_rationale_lines, sprintf("  Input %s PhysC Value    : %s (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_physc_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);

    # (Pattern and Peakiness logic - unchanged)
    my $suggested_pattern = "G";
    if ($b3_val_num > 0.01 && $o3_val_num > ($b3_val_num * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "O"; }
    elsif ($o3_val_num > 0.01 && $b3_val_num > ($o3_val_num * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "B"; }
    my $peakiness_ratio = ($g3_val_num > 0.001) ? ($p99w1_physc_val_num / $g3_val_num) : 0;
    my $shape_descriptor = "Steady";
    if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Very Peaky"; }
    elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Moderately Peaky"; }


    # --- Unified Pressure Detection ---
    my $pressure_detected_maxcpu_limit = 0;
    # Specific P-99W1 RunQ pressure flags to be returned
    my $p99w1_has_absolute_runq_pressure = 0;
    my $p99w1_has_normalized_runq_pressure = 0;
    my @pressure_points;

    # Fetch P-99W1's specific RunQ metrics
    my $p99w1_abs_runq_p90_val_str = $na_str_hint;
    my $p99w1_norm_runq_p90_val_str = $na_str_hint;
    # ... (logic to fetch $p99w1_abs_runq_p90_val_str and $p99w1_norm_runq_p90_val_str as before) ...
    # ... (logging of these input RunQ values to @global_pressure_rationale_lines as before) ...
    if (defined $per_profile_runq_metrics_ref &&
        exists $per_profile_runq_metrics_ref->{$vm} &&
        exists $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT})
    {
        my $p99w1_runq_metrics = $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT};
        $p99w1_abs_runq_p90_val_str = $p99w1_runq_metrics->{'AbsRunQ_P90'} // $na_str_hint;
        $p99w1_norm_runq_p90_val_str = $p99w1_runq_metrics->{'NormRunQ_P90'} // $na_str_hint;
    }
    push @global_pressure_rationale_lines, sprintf("  Input %s AbsRunQ P90    : %s threads (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);
    push @global_pressure_rationale_lines, sprintf("  Input %s NormRunQ P90   : %s (from nfit output for %s)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_norm_runq_p90_val_str, $MANDATORY_PEAK_PROFILE_FOR_HINT);
    push @global_pressure_rationale_lines, "";


    # 1. MaxCPU Limit Pressure
    # ... (logic as before, sets $pressure_detected_maxcpu_limit, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, "MaxCPU"; happens if $pressure_detected_maxcpu_limit = 1;) ...
    push @global_pressure_rationale_lines, sprintf("  1. MaxCPU Limit Pressure Check (%s PhysC vs LPAR MaxCPU):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for MaxCPU check)
    my $maxcpu_limit_calc_threshold = ($max_cpu_for_vm_numeric > 0) ? ($max_cpu_for_vm_numeric * $LIMIT_THRESHOLD_PERC) : 0;
    my $maxcpu_condition_met_str = "FALSE";
    if ($max_cpu_for_vm_numeric > 0 && $p99w1_physc_val_num >= $maxcpu_limit_calc_threshold)
    {
        $pressure_detected_maxcpu_limit = 1;
        $maxcpu_condition_met_str = "TRUE";
        push @pressure_points, "MaxCPU";
    }
    push @global_pressure_rationale_lines, sprintf("     - %s PhysC Value      : %.2f", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_physc_val_num);
    push @global_pressure_rationale_lines, sprintf("     - LPAR MaxCPU            : %.2f", $max_cpu_for_vm_numeric);
    push @global_pressure_rationale_lines, sprintf("     - Threshold (>= %.0f%%)      : %.2f cores", $LIMIT_THRESHOLD_PERC * 100, $maxcpu_limit_calc_threshold);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met           : (%.2f >= %.2f) -> %s", $p99w1_physc_val_num, $maxcpu_limit_calc_threshold, $maxcpu_condition_met_str);
    push @global_pressure_rationale_lines, sprintf("     - MaxCPU Pressure Flag    : %s", $maxcpu_condition_met_str);
    push @global_pressure_rationale_lines, "";


    # 2. Absolute RunQ Pressure (using P-99W1's AbsRunQ_P90)
    # ... (logic as before, sets $p99w1_has_absolute_runq_pressure, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, ... happens if $p99w1_has_absolute_runq_pressure = 1;) ...
    my $p99w1_abs_runq_p90_num = ($p99w1_abs_runq_p90_val_str ne $na_str_hint && $p99w1_abs_runq_p90_val_str =~ /^-?[0-9.]+$/) ? ($p99w1_abs_runq_p90_val_str + 0) : undef;
    my $calculated_abs_runq_pressure_ratio = 0;
    my $lpar_max_lcpu_capacity = ($max_cpu_for_vm_numeric > 0 && $smt_used_for_vm_numeric > 0) ? ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric) : 0;
    push @global_pressure_rationale_lines, sprintf("  2. Absolute RunQ Pressure Check (%s AbsRunQ P90 vs LPAR Capacity):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for AbsRunQ check)
    if (defined $p99w1_abs_runq_p90_num && $lpar_max_lcpu_capacity > 0)
    {
        $calculated_abs_runq_pressure_ratio = $p99w1_abs_runq_p90_num / $lpar_max_lcpu_capacity;
    }
    my $absrunq_cond_met_str = "FALSE";
    if ($calculated_abs_runq_pressure_ratio > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD)
    {
        $p99w1_has_absolute_runq_pressure = 1; # Set the specific flag
        $absrunq_cond_met_str = "TRUE";
        push @pressure_points, sprintf("RunQAbs_%s(P90=%.2f)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $calculated_abs_runq_pressure_ratio);
    }
    push @global_pressure_rationale_lines, sprintf("     - %s AbsRunQ P90      : %s threads", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - LPAR Max LCPU Capacity  : (%.2f MaxCPU * %d SMT) = %.2f threads", $max_cpu_for_vm_numeric, $smt_used_for_vm_numeric, $lpar_max_lcpu_capacity);
    push @global_pressure_rationale_lines, sprintf("     - Calculated Ratio        : %.4f", $calculated_abs_runq_pressure_ratio);
    push @global_pressure_rationale_lines, sprintf("     - Threshold               : > %.2f", $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met           : (%.4f > %.2f) -> %s", $calculated_abs_runq_pressure_ratio, $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD, $absrunq_cond_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s Specific Absolute RunQ Pressure Flag: %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $absrunq_cond_met_str);
    push @global_pressure_rationale_lines, "";


    # 3. Normalised Workload Pressure (using P-99W1's NormRunQ_P90)
    # ... (logic as before, sets $p99w1_has_normalized_runq_pressure, logs to @global_pressure_rationale_lines) ...
    # ... (ensure push @pressure_points, ... happens if $p99w1_has_normalized_runq_pressure = 1;) ...
    my $p99w1_norm_runq_p90_num = ($p99w1_norm_runq_p90_val_str ne $na_str_hint && $p99w1_norm_runq_p90_val_str =~ /^-?[0-9.]+$/) ? ($p99w1_norm_runq_p90_val_str + 0) : undef;
    my $min_abs_runq_for_norm_check = $smt_used_for_vm_numeric > 0 ? $smt_used_for_vm_numeric : 1.0;
    push @global_pressure_rationale_lines, sprintf("  3. Normalised Workload Pressure Check (%s NormRunQ P90):", $MANDATORY_PEAK_PROFILE_FOR_HINT);
    # ... (detailed logging lines for NormRunQ check)
    my $normrunq_cond1_met_str = (defined $p99w1_norm_runq_p90_num && $p99w1_norm_runq_p90_num > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD) ? "TRUE" : "FALSE";
    my $normrunq_cond2_met_str = (defined $p99w1_abs_runq_p90_num && $p99w1_abs_runq_p90_num >= $min_abs_runq_for_norm_check) ? "TRUE" : "FALSE";
    my $normrunq_overall_cond_met_str = "FALSE";
    if ($normrunq_cond1_met_str eq "TRUE" && $normrunq_cond2_met_str eq "TRUE")
    {
        $p99w1_has_normalized_runq_pressure = 1; # Set the specific flag
        $normrunq_overall_cond_met_str = "TRUE";
        push @pressure_points, sprintf("RunQNorm_%s(P90=%.2f)", $MANDATORY_PEAK_PROFILE_FOR_HINT, defined $p99w1_norm_runq_p90_num ? $p99w1_norm_runq_p90_num : 0);
    }
    push @global_pressure_rationale_lines, sprintf("     - %s NormRunQ P90     : %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_norm_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - Threshold               : > %.2f", $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met (Norm)    : (%s > %.2f) -> %s", $p99w1_norm_runq_p90_val_str, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD, $normrunq_cond1_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s AbsRunQ P90      : %s (for magnitude check)", $MANDATORY_PEAK_PROFILE_FOR_HINT, $p99w1_abs_runq_p90_val_str);
    push @global_pressure_rationale_lines, sprintf("     - Min AbsRunQ Threshold   : %.2f (typically SMT)", $min_abs_runq_for_norm_check);
    push @global_pressure_rationale_lines, sprintf("     - Condition Met (Mag)     : (%s >= %.2f) -> %s", $p99w1_abs_runq_p90_val_str, $min_abs_runq_for_norm_check, $normrunq_cond2_met_str);
    push @global_pressure_rationale_lines, sprintf("     - %s Specific Normalised Workload Pressure Flag: %s", $MANDATORY_PEAK_PROFILE_FOR_HINT, $normrunq_overall_cond_met_str);
    push @global_pressure_rationale_lines, "";


    # --- Combine pressure flags & Pool Context ---
    my $overall_pressure_detected_for_csv = $pressure_detected_maxcpu_limit ||
                                            $p99w1_has_absolute_runq_pressure || # Use the specific P-99W1 flags here for overall CSV flag
                                            $p99w1_has_normalized_runq_pressure;
    # Pool context logic, using @pressure_points
    push @global_pressure_rationale_lines, "  4. Pool Context:";

    # Get Pool ID from nfit's dynamic data, and Pool Name from the optional config file
    my $pool_id_from_nmon = (defined $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT}{'PoolID'}) ? $per_profile_runq_metrics_ref->{$vm}{$MANDATORY_PEAK_PROFILE_FOR_HINT}{'PoolID'} : 0;
    my $pool_name_from_config = (defined $config_ref && defined $config_ref->{pool_name}) ? $config_ref->{pool_name} : undef;

    # A non-default pool is one where the ID is not 0.
    my $is_non_default_pool = (looks_like_number($pool_id_from_nmon) && $pool_id_from_nmon != 0);

    push @global_pressure_rationale_lines, sprintf("     - Pool ID (from NMON)     : %s", $pool_id_from_nmon);
    push @global_pressure_rationale_lines, sprintf("     - Pool Name (from config) : %s", $pool_name_from_config // "N/A");
    push @global_pressure_rationale_lines, sprintf("     - Is Non-Default Pool     : %s", $is_non_default_pool ? "TRUE" : "FALSE");

    if ($is_non_default_pool && $overall_pressure_detected_for_csv) {
        # If we have a pool name, use it. Otherwise, fall back to the ID.
        my $pool_identifier = defined($pool_name_from_config) && $pool_name_from_config ne '' ? $pool_name_from_config : "ID:$pool_id_from_nmon";
        push @pressure_points, "Pool($pool_identifier)";
    }
    push @global_pressure_rationale_lines, "";

    my $overall_pressure_detected_for_csv_str = $overall_pressure_detected_for_csv ? "TRUE" : "FALSE";
    my $pressure_detail_str = @pressure_points ? join(", ", @pressure_points) : "None";
    push @global_pressure_rationale_lines, sprintf("  5. Overall Global Hint Pressure Flag (for CSV): %s", $overall_pressure_detected_for_csv_str);
    push @global_pressure_rationale_lines, sprintf("  6. Final PressureDetail string for CSV     : \"%s\"", $pressure_detail_str);

    my $global_pressure_rationale_text = "Section G: Global Sizing Hint Pressure Assessment (source: generate_sizing_hint)\n" .
                                         join("\n", @global_pressure_rationale_lines);


    # --- Tiering logic (remains unchanged) ---
    my $initial_tier_range_str = "3/4";
    if ($shape_descriptor eq "Very Peaky") { $initial_tier_range_str = "1/2"; }
    elsif ($shape_descriptor eq "Moderately Peaky") { $initial_tier_range_str = "2/3"; }
    my $adjusted_tier_str = $initial_tier_range_str;
    if ($overall_pressure_detected_for_csv)
    {
        if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; }
        elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; }
        elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; }
    }
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str;

    if ($is_vio_server)
    {
        # For VIOs, we return the *actual* calculated pressure flags and details,
        # but override the final tier/pattern hint for safety and clarity.
        return (
            "P",    # Override Hint to "P" for Peak/Manual
            $shape_descriptor, # Override Pattern
            $overall_pressure_detected_for_csv, # Return ACTUAL calculated pressure
            $pressure_detail_str,               # Return ACTUAL pressure details
            $global_pressure_rationale_text,
            $p99w1_has_absolute_runq_pressure,
            $p99w1_has_normalized_runq_pressure
        );
    }
    else
    {
        # For non-VIOs, return the standard, calculated hint and pattern.
        return (
            $pattern_tier_string,
            $shape_descriptor,
            $overall_pressure_detected_for_csv,
            $pressure_detail_str,
            $global_pressure_rationale_text,
            $p99w1_has_absolute_runq_pressure,
            $p99w1_has_normalized_runq_pressure
        );
    }
}
# end of generate_sizing_hint

# --- parse_percentile_list_for_header ---
# This sub is used by the OLD global RunQ metric collection logic (which is now superseded
# by per-profile RunQ metrics). It might still be called if that logic path is hit,
# or could be refactored/removed if that path is fully deprecated.
# For now, keeping it as it might be used by initial population of $results_table{$vm_name}{$rq_metric_name}.
# It prepares percentile numbers for use as metric name suffixes.
sub parse_percentile_list_for_header
{
    my ($perc_str, $clean_zeros) = @_;
    $clean_zeros = 1 if !defined $clean_zeros; # Default to cleaning "X.00" to "X"
    my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100) # Validate numeric and range
            {
                my $p_label = $p;
                if ($clean_zeros)
                {
                    $p_label = sprintf("%.2f", $p); # Format to two decimal places
                    $p_label =~ s/\.?0+$//;         # Remove trailing ".00" or ".0"
                    $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00"); # Handle "0.00" -> "0"
                }
                push @percentiles_cleaned, $p_label;
            }
            else # Invalid percentile value
            {
                die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return \@percentiles_cleaned; # Return reference to array of cleaned percentile labels
}

# --- ensure_percentiles_requested ---
# Checks if a list of required percentiles are present in a given percentile string.
# Potentially used for validating if nfit was asked to calculate necessary percentiles
# for the old global RunQ metric collection. May be less relevant with per-profile logic.
sub ensure_percentiles_requested
{
    my ($perc_list_str, @required_percs) = @_; # perc_list_str is comma-separated, required_percs are numbers
    return 1 unless defined $perc_list_str && $perc_list_str ne ''; # If no list provided, assume not applicable or handled elsewhere

    # Parse the provided list string into a map for easy lookup
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0); # Get raw numbers, no zero cleaning for comparison
    my %present_map = map { $_ => 1 } @{$parsed_percs_ref};

    foreach my $req_p_num (@required_percs) # Iterate through numerically required percentiles
    {
        # Check if the numeric value (or its string representation) exists in the parsed list
        my $req_p_str = "$req_p_num"; # Simple string conversion
        my $req_p_str_formatted = sprintf("%.2f", $req_p_num); # e.g. 90.00
        my $req_p_str_cleaned = $req_p_str_formatted;
        $req_p_str_cleaned =~ s/\.?0+$//;
        $req_p_str_cleaned = "0" if $req_p_str_cleaned eq "" && abs($req_p_num -0) < 0.001;


        unless (exists $present_map{$req_p_str} ||
                exists $present_map{$req_p_str_formatted} ||
                exists $present_map{$req_p_str_cleaned} )
        {
            # Check common string representations due to potential formatting differences
            my $found = 0;
            foreach my $key (keys %present_map) {
                if (abs($key - $req_p_num) < 0.001) { # Floating point comparison
                    $found = 1;
                    last;
                }
            }
            return 0 unless $found; # Required percentile not found
        }
    }
    return 1; # All required percentiles found
}

# --- get_nfit_output_dp_from_flags ---
# Determines the number of decimal places nfit is expected to use for a profile's output,
# based on the rounding flags (-r or -u) passed to nfit for that profile.
# This helps nfit-profile format its *own* adjusted values consistently.
sub get_nfit_output_dp_from_flags
{
    my ($nfit_flags_str_for_this_run) = @_; # Combined global and profile-specific flags for nfit

    # Regex to find -r[=increment] or -u[=increment]
    # It captures the increment value if provided.
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/)
    {
        my $increment_val_str = $1 // $2; # $1 for -r=val, $2 for -u=val

        # If -r or -u is present but no increment value, nfit uses its default increment.
        if (!(defined $increment_val_str && $increment_val_str ne ""))
        {
            # nfit's default increment is $DEFAULT_ROUND_INCREMENT (from nfit.pl, assumed here to be same as nfit-profile's)
            # For robustness, it's better if nfit-profile knows nfit's default or this is coordinated.
            # Using nfit-profile's default as a proxy.
            return get_decimal_places($DEFAULT_ROUND_INCREMENT);
        }
        else # Increment value was specified
        {
            return get_decimal_places($increment_val_str);
        }
    }
    # If no -r or -u flag, nfit typically outputs with more precision (e.g., 4 decimal places by default internally).
    # nfit.pl version 2.28.0.4 defaults to 4 DP if no rounding.
    return 4;
}

# --- get_decimal_places ---
# Calculates the number of decimal places in a given number string.
sub get_decimal_places
{
    my ($number_str) = @_;
    # Handle scientific notation by converting to fixed point string first
    $number_str = sprintf("%.15f", $number_str) if ($number_str =~ /e/i);

    if ($number_str =~ /\.(\d+)$/) # If there's a decimal part
    {
        return length($1); # Length of the digits after decimal point
    }
    else # No decimal part
    {
        return 0;
    }
}

# Helper to format a percentile number into a clean string for metric keys.
sub clean_perc_label {
    my ($p) = @_;
    my $label = sprintf("%.2f", $p);
    $label =~ s/\.?0+$//;
    $label = "0" if $label eq "" && abs($p-0)<0.001;
    return $label;
}

# Parses the new rich key-value output from nfit v3.
# Handles the "VMName:StateString Key=Val Key=Val..." format.
# Returns a hash where keys are VM names, and values are arrays of state-result hashes.
sub parse_nfit_key_value_output
{
    my ($raw_output) = @_;
    my %parsed_data;
    my @lines = split /\n/, $raw_output;

    foreach my $line (@lines)
    {

        next if $line =~ /^\s*$/;
        next if $line =~ /^#/;
        next if $line =~ /^VM_Name,State_ID/;
        next unless $line =~ /:/;

        my ($vm_name, $data_string) = split /:/, $line, 2;
        $vm_name =~ s/^\s+|\s+$//g;

        next unless (defined $vm_name && $vm_name ne '' && defined $data_string);
        $data_string =~ s/^\s+|\s+$//g;

        my @parts = split /\s+/, $data_string;
        my %state_data_hash;
        my @state_id_parts;

        foreach my $part (@parts) {
            if ($part =~ /^([^=]+)=(.+)$/) {
                $state_data_hash{$1} = $2;
            } else {
                push @state_id_parts, $part;
            }
        }

        my $state_id_str = join(' ', @state_id_parts);
        $state_data_hash{'State_ID'} = ($state_id_str ne '') ? $state_id_str : 'Aggregated';

        push @{$parsed_data{$vm_name}}, \%state_data_hash;
    }

    return \%parsed_data;
}

# --- usage_wrapper ---
# Generates and returns the usage/help message for the script.
sub usage_wrapper
{
    my $script_name = $0;
    $script_name =~ s{.*/}{}; # Get only script name, remove path
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [options]

Runs 'nfit' for multiple profiles. Applies RunQ modifiers and generates hints.
The RunQ modifier behavior (standard vs. additive-only) can be controlled
per profile via the 'runq_modifier_behavior' attribute in nfit.profiles.cfg.
Optionally passes flags to nfit for its internal windowed decay processing.
A detailed rationale log is written to $LOG_FILE_PATH.

Input Method:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
      --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --nmondir <directory>    : Path to a directory of .nmon files to process (mutually exclusive with --physc-data and --runq-data).
  --default-smt, --smt <N> : Optional. Default SMT level (Default: $DEFAULT_SMT_VALUE_PROFILE).

RunQ Metric Configuration (for nfit calls):
  --runq-norm-percentiles <list> : Global default for Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERCS").
                                   This list is combined with profile-specific settings and ensures P50,P90.
  --runq-abs-percentiles <list>  : Global default for Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERCS").
                                   This list is combined with profile-specific settings and ensures P90
                                   (and P<profile_physc_%> if --match-runq-perc-to-profile is used).
  --match-runq-perc-to-profile : Optional. If set, for RunQ additive logic, attempts to use AbsRunQ
                                   percentile matching the profile's PhysC -p <X> percentile
                                   (e.g., uses AbsRunQ_PX). Falls back to AbsRunQ_P90 if PX not available.
                                   Ensures nfit is asked to calculate PX if this option is used.

Configuration Files:
  -config <vm_cfg_csv>       : Optional. VM configuration CSV file.
  --profiles-config <path>   : Optional. Profiles definition file (INI format).
                               Can contain 'runq_modifier_behavior = additive_only' per profile,
                               and profile-specific 'nfit_flags' including --runq-norm-perc/--runq-abs-perc.

Filtering (Global or passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Global start date for analysis (passed to nfit).
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name (passed to nfit).

Control nfit's Internal Windowed Recency Decay (Optional):
  --enable-windowed-decay                : Enable nfit's internal windowed processing.
  --decay-over-states                    : Enable the Hybrid State-Time Decay Model. This advanced mode
                                           applies recency decay to state-based results.
                                           (Mutually exclusive with --enable-windowed-decay).
  --process-window-unit <days|weeks>     : Unit for nfit's window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT).
  --process-window-size <N>              : Size of nfit's window in units (Default: $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT).
  --decay-half-life-days <N>             : Half-life for nfit's recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT).
  --analysis-reference-date <YYYY-MM-DD> : Reference date for nfit's recency calculation
                                            (Default: nfit uses date of last record in its filtered NMON data).
  --runq-avg-method <none|sma|ema>       : Averaging method for RunQ data within nfit before percentile.
                                            (Default: $DEFAULT_NFIT_RUNQ_AVG_METHOD). Uses main -w/--decay/--runq-decay from profile.

Rounding (Passed to nfit for its output):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Default increment: $DEFAULT_ROUND_INCREMENT)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

CSV Output Options:
  --excel-formulas <true|false> : Add summary formulas to the bottom of the CSV for Excel.
                                  (Default: true).

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are potentially recency-weighted by nfit & RunQ-modified by nfit-profile)...],
  Current_ENT,NFIT_ENT_UserFormula,NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
