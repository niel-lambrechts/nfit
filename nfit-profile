#!/usr/bin/env perl

# NAME     : nfit-profile
# VERSION  : 2.35.0.3 # Implemented Enhanced Efficiency Factor, aligned Workload Pressure, full logging.
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' multiple times with user-defined profiles.
#            Applies RunQ modifiers, generates hints, logs rationale, and aggregates to CSV.
# REQUIRES : Perl, nfit script (v2.28.0.4+), Time::Piece, List::Util, IO::File, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);
use Time::Piece;
use List::Util qw(sum min max);
use IO::File;
use version;

# --- Store original ARGV for logging ---
my @original_argv = @ARGV;

# --- Capture nfit-profile.pl start time ---
my $PROFILE_SCRIPT_START_TIME_EPOCH = time();
my $PROFILE_SCRIPT_START_TIME_STR = localtime($PROFILE_SCRIPT_START_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");

# --- Version ---
my $SCRIPT_VERSION = '2.35.0.3';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90";
my $DEFAULT_RUNQ_ABS_PERCS  = "90";
my $DEFAULT_NFIT_RUNQ_AVG_METHOD = "ema";

# Windowed Decay Defaults
my $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT = 30;

# Heuristic Thresholds
my $PATTERN_RATIO_THRESHOLD = 2.0;
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;
my $LIMIT_THRESHOLD_PERC = 0.98;

# RunQ Modifier Thresholds
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 2.0;
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 1.8;
my $RUNQ_ADDITIVE_TOLERANCE_FACTOR = 1.8; # e.g., Tolerate AbsRunQ up to this Factor x Base_Profile_PhysC's LCPU capacity

# Max_Additive_CPU Sliding Scale Thresholds
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;
my $MAX_ADD_PERC_VAL_ELSE = 0.5;

# RunQ Volatility Confidence Factor Thresholds & Values
my $VOLATILITY_SPIKY_THRESHOLD = 0.5; my $VOLATILITY_SPIKY_FACTOR = 0.70;
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85;
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0;

# --- Enhanced Efficiency Factor Constants ---
my $VOLATILITY_CAUTION_THRESHOLD = 2.5;
my $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION = 0.5;
my $MAX_EFFICIENCY_REDUCTION_PERCENTAGE  = 0.15;
my $MIN_P50_DENOMINATOR_FOR_VOLATILITY = 0.1;
# $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC is now SMT-dependent, see calculate_runq_modified_physc. It still needs to be declared though.
my $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC = 0.75;

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80;

my $LOG_FILE_PATH = "/tmp/nfit-profile.log";

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak";

# --- Argument Parsing ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;
my $roundup_arg;
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS;
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit";
my $nfit_enable_windowed_decay = 0;
my $nfit_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT;
my $nfit_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT;
my $nfit_decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT;
my $nfit_analysis_reference_date_str;
my $nfit_runq_avg_method_str = $DEFAULT_NFIT_RUNQ_AVG_METHOD;

GetOptions(
    'physc-data|pc=s'         => \$physc_data_file,
    'runq-data|rq=s'          => \$runq_data_file_arg,
    'config=s'                => \$vm_config_file_arg,
    'profiles-config=s'       => \$profiles_config_file_arg,
    'startdate|s=s'           => \$start_date_str,
    'vm|lpar=s'               => \$target_vm_name,
    'round|r:f'               => \$round_arg,
    'roundup|u:f'             => \$roundup_arg,
    'default-smt|smt=i'       => \$default_smt_arg,
    'runq-norm-percentiles=s' => \$runq_norm_perc_list_str,
    'runq-abs-percentiles=s'  => \$runq_abs_perc_list_str,
    'help|h'                  => \$help,
    'nfit-path=s'             => \$nfit_script_path,
    'version|v'               => \$show_version,
    'nfit-enable-windowed-decay'     => \$nfit_enable_windowed_decay,
    'nfit-process-window-unit=s'     => \$nfit_window_unit_str,
    'nfit-process-window-size=i'     => \$nfit_window_size_val,
    'nfit-decay-half-life-days=i'    => \$nfit_decay_half_life_days_val,
    'nfit-analysis-reference-date=s' => \$nfit_analysis_reference_date_str,
    'nfit-runq-avg-method=s'         => \$nfit_runq_avg_method_str,
) or die usage_wrapper();

# --- Validation ---
my $nfit_ver = "N/A";
if ($show_version)
{
    print STDERR "nfit-profile version $SCRIPT_VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver_output = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver) = ($nfit_ver_output =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        if (defined $parsed_nfit_ver)
        {
            $nfit_ver = $parsed_nfit_ver;
            print STDERR "Uses nfit version: $nfit_ver\n";
            my $required_nfit_ver_for_windowing = "2.27.0";
            my $required_nfit_ver_for_runq_avg_and_decay = "2.28.0.4";

            if ($nfit_enable_windowed_decay && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_windowing))
            {
                print STDERR "Warning: --nfit-enable-windowed-decay requires nfit version $required_nfit_ver_for_windowing or higher. Your nfit version ($nfit_ver) may not support this.\n";
            }
            if (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none' && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_runq_avg_and_decay))
            {
                 print STDERR "Warning: --nfit-runq-avg-method (sma/ema) may require nfit features from version $required_nfit_ver_for_runq_avg_and_decay or higher. Your nfit version ($nfit_ver) behavior might differ for RunQ processing, especially if --runq-decay is intended.\n";
            }
        }
        else
        {
            print STDERR "Could not determine nfit version from output: $nfit_ver_output\n";
            if ($nfit_enable_windowed_decay || (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none'))
            {
                print STDERR "Warning: Advanced nfit features are enabled but nfit version cannot be verified.\n";
            }
        }
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}

if ($help || !$physc_data_file)
{
    print STDERR usage_wrapper();
    exit 0;
}
if (! -f $physc_data_file)
{
    die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n";
}
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg)
{
    die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n";
}
if ($default_smt_arg <= 0)
{
    die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n";
}
if (! -x $nfit_script_path)
{
    die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n";
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}

if ($nfit_enable_windowed_decay)
{
    if ($nfit_window_unit_str ne "days" && $nfit_window_unit_str ne "weeks")
    {
        die "Error: --nfit-process-window-unit must be 'days' or 'weeks'.\n";
    }
    if ($nfit_window_size_val < 1)
    {
        die "Error: --nfit-process-window-size must be at least 1.\n";
    }
    if ($nfit_decay_half_life_days_val < 1)
    {
        die "Error: --nfit-decay-half-life-days must be at least 1.\n";
    }
    if (defined $nfit_analysis_reference_date_str && $nfit_analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
    {
        die "Error: Invalid --nfit-analysis-reference-date format. Use YYYY-MM-DD.\n";
    }
    print STDERR "nfit's internal windowed decay processing is enabled via nfit-profile.\n";
}

if (defined $nfit_runq_avg_method_str)
{
    $nfit_runq_avg_method_str = lc($nfit_runq_avg_method_str);
    unless ($nfit_runq_avg_method_str eq 'none' || $nfit_runq_avg_method_str eq 'sma' || $nfit_runq_avg_method_str eq 'ema')
    {
        die "Error: --nfit-runq-avg-method must be 'none', 'sma', or 'ema'. Got '$nfit_runq_avg_method_str'.\n";
    }
    print STDERR "Instructing nfit to use RunQ averaging method: $nfit_runq_avg_method_str.\n";
}

# --- Open Log File ---
my $LOG_FH = IO::File->new($LOG_FILE_PATH, '>')
    or warn "Error: Cannot open rationale log file '$LOG_FILE_PATH' for writing: $!. Rationale logging will be skipped.\n";

if ($LOG_FH)
{
    $LOG_FH->autoflush(1);
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nFit Profile Rationale Log\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nfit-profile.pl Run Started: $PROFILE_SCRIPT_START_TIME_STR\n";
    print {$LOG_FH} "nfit-profile.pl Version  : $SCRIPT_VERSION\n";

    if ($nfit_ver eq "N/A" && -x $nfit_script_path) {
        my $nfit_ver_output_log = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver_log) = ($nfit_ver_output_log =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        $nfit_ver = $parsed_nfit_ver_log // "Unknown (parse failed)";
    }
    print {$LOG_FH} "nfit.pl Version Used     : $nfit_ver\n";

    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Invocation:\n";
    my @quoted_original_argv_log = map { $_ =~ /\s/ ? qq/"$_"/ : $_ } @original_argv;
    print {$LOG_FH} "  $0 " . join(" ", @quoted_original_argv_log) . "\n";
    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Key Global Settings:\n";
    print {$LOG_FH} "  - PhysC Data File          : $physc_data_file\n";
    print {$LOG_FH} "  - RunQ Data File           : " . ($runq_data_file_arg // "Not Provided") . "\n";
}

# --- Load Profile Definitions ---
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE";
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
if ($LOG_FH) { print {$LOG_FH} "  - Profiles Config File     : $profiles_config_path_to_load\n"; }
@profiles = load_profile_definitions($profiles_config_path_to_load);
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}
print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";

# --- Locate and Load VM Configuration Data ---
my $vm_config_file_path = undef;
my $vm_config_found = 0;
my %vm_config_data;
my %vm_config_col_idx;
my $vm_config_header_count = 0;
if (defined $vm_config_file_arg)
{
    if (-f $vm_config_file_arg)
    {
        $vm_config_file_path = $vm_config_file_arg;
        $vm_config_found = 1;
        print STDERR "Using specified VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n";
    }
}
else
{
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE";
    my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE";
    if (-f $dp_etc)
    {
        $vm_config_file_path = $dp_etc;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    elsif (-f $dp_root)
    {
        $vm_config_file_path = $dp_root;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n";
    }
}
if ($LOG_FH) { print {$LOG_FH} "  - VM Config File           : " . ($vm_config_file_path // "Not Provided/Default Attempted") . "\n"; }

if ($vm_config_found)
{
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>;
    unless (defined $hdr)
    {
        die "Error: Could not read header from VM config '$vm_config_file_path'\n";
    }
    chomp $hdr;
    $hdr =~ s/\r$//;
    $hdr =~ s/^\x{FEFF}//;
    my @rhdrs = split /,/, $hdr;
    $vm_config_header_count = scalar @rhdrs;
    my %hmap;
    for my $i (0 .. $#rhdrs)
    {
        my $cn = $rhdrs[$i];
        $cn =~ s/^\s*"?|"?\s*$//g;
        if ($cn ne '')
        {
            $hmap{lc($cn)} = $i;
        }
    }
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'};
    unless (exists $hmap{'maxcpu'})
    {
        warn "Warning: 'maxcpu' column not found in VM config. Final MaxCPU capping logic will be affected.\n";
    }
    if ($has_smt_col)
    {
        print STDERR "Found 'SMT' column in VM configuration file.\n";
    }
    else
    {
        print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n";
    }
    foreach my $rc (@req_cols)
    {
        unless (exists $hmap{$rc})
        {
            die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n";
        }
        $vm_config_col_idx{$rc} = $hmap{$rc};
    }
    if ($has_smt_col)
    {
        $vm_config_col_idx{'smt'} = $hmap{'smt'};
    }
    while (my $ln = <$cfg_fh>)
    {
        chomp $ln;
        $ln =~ s/\r$//;
        next if $ln =~ /^\s*$/;
        my @rvals = ($ln =~ /"([^"]*)"/g);
        if (scalar @rvals != $vm_config_header_count)
        {
            @rvals = split /,/, $ln;
            if (scalar @rvals != $vm_config_header_count)
            {
                warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n";
                next;
            }
            $_ =~ s/^\s+|\s+$//g for @rvals;
        }
        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ];
        if (defined $hn && $hn ne '')
        {
            my $smt_v = $default_smt_arg;
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '')
            {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/)
                {
                    $smt_v = $1;
                    if ($smt_v <= 0)
                    {
                        warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                        $smt_v = $default_smt_arg;
                    }
                }
                else
                {
                    warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                }
            }
            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0)
            {
                $max_cpu_val = 0;
            }
            $vm_config_data{$hn} = {
                serial      => $rvals[$vm_config_col_idx{'serial'}],
                systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name   => $rvals[$vm_config_col_idx{'procpool_name'}],
                pool_id     => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}],
                maxcpu      => ($max_cpu_val + 0),
                smt         => $smt_v,
            };
        }
        else
        {
            warn "Warning: Missing hostname on VM config line $. Skipping.\n";
        }
    }
    close $cfg_fh;
    print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
}
else
{
     print STDERR "Warning: VM configuration file not loaded. MaxCPU capping logic will be affected, and SMT will use default.\n";
}

# --- Construct Common Flags for nfit ---
my $common_nfit_flags_base = "-k --physc-data \"$physc_data_file\"";
if (defined $runq_data_file_arg)
{
    $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
    $common_nfit_flags_base .= " --runq-norm-perc \"$runq_norm_perc_list_str\"";
    $common_nfit_flags_base .= " --runq-abs-perc \"$runq_abs_perc_list_str\"";
    if (defined $nfit_runq_avg_method_str)
    {
        $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
    }
}
if (defined $start_date_str)
{
    $common_nfit_flags_base .= " -s $start_date_str";
}

my $rounding_flags_for_nfit = "";
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit;

my $nfit_windowing_decay_flags = "";
if ($nfit_enable_windowed_decay)
{
    $nfit_windowing_decay_flags .= " --enable-windowed-decay";
    $nfit_windowing_decay_flags .= " --process-window-unit \"$nfit_window_unit_str\"";
    $nfit_windowing_decay_flags .= " --process-window-size $nfit_window_size_val";
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
$common_nfit_flags_base .= $nfit_windowing_decay_flags;

if ($LOG_FH) {
    print {$LOG_FH} "  - nfit Common Base Flags   : $common_nfit_flags_base\n";
    print {$LOG_FH} "  - nfit Windowed Decay Opts : " . ($nfit_windowing_decay_flags ne "" ? $nfit_windowing_decay_flags : "Not Enabled") . "\n";
    print {$LOG_FH} "  - nfit RunQ Avg Method     : $nfit_runq_avg_method_str\n";
    print {$LOG_FH} "  - Default SMT for Profile  : $default_smt_arg\n";
    print {$LOG_FH} "======================================================================\n\n";
    print {$LOG_FH} "===== Per-VM / Per-Profile RunQ Adjustment Details =====\n\n";
}

# --- Main Logic: Run nfit Profiles ---
my %results_table;
my @vm_order;
my %vm_seen;
my %primary_runq_metrics_captured_for_vm;
my %source_profile_for_global_runq;
my %per_profile_runq_metrics;

print STDERR "nfit-profile version $SCRIPT_VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles)
{
    # ... (Profile run logic as per user's file, with parsing into %per_profile_runq_metrics
    #      and first-capture into %results_table for global RunQ keys) ...
    my $profile_name = $profile->{name};
    my $profile_specific_flags = $profile->{flags};
    my $profile_runq_behavior = $profile->{runq_behavior} // 'default';

    print STDERR "Running profile: $profile_name ($profile_specific_flags";
    print STDERR " ; RunQBehavior: $profile_runq_behavior" if $profile_runq_behavior ne 'default';
    print STDERR ")...\n";
    
    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg";
    my $nfit_vm_flag_for_current_run = "";

    if (defined $target_vm_name)
    {
        $nfit_vm_flag_for_current_run = " -vm \"$target_vm_name\"";
        if ($vm_config_found && exists $vm_config_data{$target_vm_name} && defined $vm_config_data{$target_vm_name}{'smt'})
        {
            $nfit_smt_flag_for_current_run = "--smt " . $vm_config_data{$target_vm_name}{'smt'};
        }
    }
    
    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags";
    my $output = `$command`;
    my $exit_status = $? >> 8;

    if ($exit_status != 0)
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Command was: $command. Output: $output. Skip.\n";
        if ($LOG_FH)
        {
             print {$LOG_FH} "ERROR: nfit.pl execution FAILED for profile '$profile_name' on VM(s) '". ($target_vm_name // "All") ."'.\n";
             print {$LOG_FH} "  Command: $command\n";
             print {$LOG_FH} "  Exit Status: $exit_status\n";
             my $short_output = substr($output, 0, 1000) . (length($output) > 1000 ? "..." : "");
             print {$LOG_FH} "  Output (first 1000 chars): $short_output\n";
        }
        next;
    }

    my @output_lines = split /\n/, $output;
    foreach my $line (@output_lines)
    {
        chomp $line;
        if ($line =~ /^(.+?):\s*(.*)$/)
        {
            my $vm_name_from_nfit = $1;
            my $metrics_str = $2;

            unless ($vm_seen{$vm_name_from_nfit}++)
            {
                push @vm_order, $vm_name_from_nfit;
            }
            
            $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit} //= {
                'NormRunQ_P50' => 0,
                'NormRunQ_P90' => 0,
                'AbsRunQ_P90'  => 0,
            };

            my ($profile_p_flag_val_num) = ($profile_specific_flags =~ /-p\s+([0-9.]+)/);
            if (defined $profile_p_flag_val_num)
            {
                my $expected_metric_key_base = sprintf("%.2f", $profile_p_flag_val_num);
                $expected_metric_key_base =~ s/\.?0+$//;
                $expected_metric_key_base = "0" if $expected_metric_key_base eq "" && abs($profile_p_flag_val_num - 0) < 0.001;
                my $expected_metric_key = "P$expected_metric_key_base";
                
                if ($metrics_str =~ /\Q$expected_metric_key\E=([0-9.NA\/ -]+?)(?:\s+|$)/)
                {
                    my $p_value_val = $1;
                    $p_value_val =~ s/^\s+|\s+$//g;
                    $results_table{$vm_name_from_nfit}{$profile_name} = $p_value_val;
                }
            }

            if ($metrics_str =~ /Peak=([0-9.NA\/ -]+?)(?:\s+|$)/)
            {
                my $peak_value = $1;
                $peak_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name_from_nfit}{$PEAK_PROFILE_NAME} = $peak_value;
            }

            my %first_capture_target_keys = (
                'NormRunQ_P50' => 1,
                'NormRunQ_P90' => 1,
                'AbsRunQ_P90'  => 1,
            );

            while ($metrics_str =~ /(NormRunQ_P\d+\.?\d*|AbsRunQ_P\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/g)
            {
                my ($rq_metric_name, $rq_value) = ($1, $2);
                $rq_value =~ s/^\s+|\s+$//g;

                $per_profile_runq_metrics{$vm_name_from_nfit}{$profile_name}{$rq_metric_name} = $rq_value;

                if (exists $first_capture_target_keys{$rq_metric_name})
                {
                    if (!$primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name})
                    {
                        $results_table{$vm_name_from_nfit}{$rq_metric_name} = $rq_value;
                        $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name} = 1;
                        $source_profile_for_global_runq{$vm_name_from_nfit} //= $profile_name;
                    }
                }
            }
        }
        elsif ($line ne '')
        {
            warn "Warning: Could not parse VM name from nfit output line for profile '$profile_name': $line\n";
        }
    }
}
print STDERR "Finished nfit profile runs. Generating CSV output and rationale log...\n";

# --- Generate CSV Output ---
# ... (CSV Header and Data Row generation as per your file, with RunQ columns removed from output) ...
my @output_header_cols_csv;
@output_header_cols_csv = (
    "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT",
    "Serial", "SystemType", "Pool Name", "Pool ID", $PEAK_PROFILE_NAME
);
push @output_header_cols_csv, map { $_->{name} } @profiles;
push @output_header_cols_csv, ("Current_ENT", "NFIT_ENT_UserFormula", "NETT_UserFormula", "NETT_Perc_UserFormula");
print STDOUT join(",", map { quote_csv($_) } @output_header_cols_csv) . "\n";

foreach my $vm_name (@vm_order)
{
    my @data_row_csv;
    my $cfg_csv = $vm_config_data{$vm_name};
    my $smt_used_for_vm_csv = (defined $cfg_csv && defined $cfg_csv->{smt}) ? $cfg_csv->{smt} : $default_smt_arg;
    my $max_cpu_for_vm_csv  = (defined $cfg_csv && defined $cfg_csv->{maxcpu} && $cfg_csv->{maxcpu} > 0) ? $cfg_csv->{maxcpu} : 0;
    
    my $hint_norm_runq_p90_str = $results_table{$vm_name}{'NormRunQ_P90'} // "N/A";
    my $hint_abs_runq_p90_str  = $results_table{$vm_name}{'AbsRunQ_P90'}  // "N/A";
    my $runq_metrics_source_profile_name_for_hint = $source_profile_for_global_runq{$vm_name} // "First Profile Processed";

    my ($hint_type_tier_csv, $hint_pattern_shape_csv, $hint_pressure_bool_csv, $pressure_detail_str_csv) =
        generate_sizing_hint(
            'results_ref'              => \%results_table, 
            'vm' => $vm_name,
            'config_ref' => $cfg_csv,
            'norm_runq_p90_for_vm_str' => $hint_norm_runq_p90_str, 
            'abs_runq_p90_for_vm_str'  => $hint_abs_runq_p90_str,
            'max_cpu_for_vm_numeric'   => $max_cpu_for_vm_csv,
            'smt_used_for_vm_numeric'  => $smt_used_for_vm_csv
        );
    my $pressure_bool_str_csv = $hint_pressure_bool_csv ? "True" : "False";
    
    push @data_row_csv, $vm_name, "", $hint_type_tier_csv, $hint_pattern_shape_csv, $pressure_bool_str_csv, $pressure_detail_str_csv, $smt_used_for_vm_csv;
    
    push @data_row_csv, (defined $cfg_csv ? $cfg_csv->{serial} : ""), (defined $cfg_csv ? $cfg_csv->{systemtype} : ""), (defined $cfg_csv ? $cfg_csv->{pool_name} : ""), (defined $cfg_csv ? $cfg_csv->{pool_id} : "");
    push @data_row_csv, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // "");
    
    foreach my $profile (@profiles)
    {
        my $profile_name_being_adjusted = $profile->{name};
        my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name_being_adjusted};
        my $adjusted_value_str = "N/A";
        my $current_profile_runq_behavior = $profile->{runq_behavior} // 'default';
        my $debug_info_ref_profile_for_log;

        my $this_profile_norm_p50 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P50'} // "N/A";
        my $this_profile_norm_p90 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P90'} // "N/A";
        my $this_profile_abs_p90  = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'AbsRunQ_P90'}  // "N/A";

        if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/)
        {
            my $raw_physc_profile_value = $raw_physc_profile_value_str + 0;
            my $is_non_default_pool = (defined $cfg_csv && defined $cfg_csv->{pool_name} && lc($cfg_csv->{pool_name}) ne 'defaultpool' && $cfg_csv->{pool_name} ne '');
            
            my ($runq_modified_physc_for_profile, $debug_info_ref) = calculate_runq_modified_physc(
                $raw_physc_profile_value,
                $this_profile_norm_p50,
                $this_profile_norm_p90,
                $this_profile_abs_p90,
                $smt_used_for_vm_csv, (defined $cfg_csv ? $cfg_csv->{entitlement} : "0"), $max_cpu_for_vm_csv, $is_non_default_pool,
                $current_profile_runq_behavior
            );
            $debug_info_ref_profile_for_log = $debug_info_ref;
            
            my $current_profile_nfit_flags = $profile->{flags};
            my $current_profile_output_dp = get_nfit_output_dp_from_flags($rounding_flags_for_nfit . " " . $current_profile_nfit_flags);
            my $current_sprintf_format = "%." . $current_profile_output_dp . "f";
            $adjusted_value_str = sprintf($current_sprintf_format, $runq_modified_physc_for_profile);
        }
        else
        {
            $adjusted_value_str = $raw_physc_profile_value_str // "N/A";
            $debug_info_ref_profile_for_log = {
                 BasePhysC => $raw_physc_profile_value_str // "N/A",
                 ReasonForNoModification => "Base PhysC for profile '$profile_name_being_adjusted' was N/A or not numeric.",
                 FinalAdjustedPhysC => $adjusted_value_str,
            };
        }
        push @data_row_csv, $adjusted_value_str;

        if ($LOG_FH)
        {
            log_profile_rationale(
                $LOG_FH, $vm_name, $profile_name_being_adjusted,
                $raw_physc_profile_value_str,
                $profile_name_being_adjusted, 
                $this_profile_abs_p90,
                $this_profile_norm_p50,
                $this_profile_norm_p90,
                $cfg_csv, $smt_used_for_vm_csv, $max_cpu_for_vm_csv,
                $current_profile_runq_behavior,
                $debug_info_ref_profile_for_log,
                $adjusted_value_str
            );
        }
    }
    
    my $current_ent_display_csv_out = (defined $cfg_csv && defined $cfg_csv->{entitlement}) ? $cfg_csv->{entitlement} : "";
    if ($current_ent_display_csv_out ne "" && $current_ent_display_csv_out =~ /^-?[0-9.]+$/)
    {
        $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out);
    }
    push @data_row_csv, $current_ent_display_csv_out, "NFIT_Formula", "NETT_UserFormula", "NETT_Perc_UserFormula";
    
    print STDOUT join(",", map { quote_csv($_) } @data_row_csv) . "\n";
}

# ... (Footer for script, including log closing) ...
print STDERR "CSV output generated successfully.\n";
if ($nfit_enable_windowed_decay)
{
    print STDERR "Note: nfit was instructed to use internal windowed decay processing.\n";
}
if ($LOG_FH)
{
    my $PROFILE_SCRIPT_END_TIME_EPOCH = time();
    my $PROFILE_SCRIPT_END_TIME_STR = localtime($PROFILE_SCRIPT_END_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");
    my $PROFILE_SCRIPT_DURATION = $PROFILE_SCRIPT_END_TIME_EPOCH - $PROFILE_SCRIPT_START_TIME_EPOCH;

    print {$LOG_FH} "\n----------------------------------------------------------------------\n";
    print {$LOG_FH} "nfit-profile.pl Run Ended  : $PROFILE_SCRIPT_END_TIME_STR\n";
    print {$LOG_FH} "Total Duration             : $PROFILE_SCRIPT_DURATION seconds\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "End of Rationale Log.\n";
    print {$LOG_FH} "======================================================================\n";
    close $LOG_FH;
    print STDERR "Rationale log written to: $LOG_FILE_PATH\n";
}

exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================


# --- log_profile_rationale (Updated for new debug_info keys and clarity) ---
sub log_profile_rationale
{
    my ($fh, $vm_name, $profile_being_adjusted,
        $raw_physc_for_profile,
        # This next argument is the name of the profile that sourced the RunQ metrics
        # For per-profile RunQ logic, it's the same as $profile_being_adjusted
        $runq_metrics_source_profile_name_for_this_calc,
        $absP90_for_this_calc, $normP50_for_this_calc, $normP90_for_this_calc,
        $vm_cfg_ref, $smt_val, $lpar_max_cpu_cfg_val_from_config, # Renamed for clarity
        $profile_rq_behavior,
        $calc_debug_info_ref, # Hash ref with detailed calculation steps
        $final_csv_value_for_profile
    ) = @_;

    return unless $fh;

    my $na = 'N/A'; # Consistent N/A string

    # --- Print Header for this VM/Profile section ---
    print {$fh} "----------------------------------------------------------------------\n";
    print {$fh} "VM Name                 : $vm_name\n";
    print {$fh} "Profile Adjusted        : $profile_being_adjusted\n";
    print {$fh} "----------------------------------------------------------------------\n\n";

    # --- Section A: Inputs for RunQ Adjustment ---
    print {$fh} "Section A: Inputs for RunQ Adjustment\n";
    printf {$fh} "  1. Base PhysC for this Profile : %s cores (Value from nfit for profile '%s')\n", ($raw_physc_for_profile // $na), $profile_being_adjusted;
    printf {$fh} "  2. RunQ Metrics for this Adjustment (sourced from this profile's ['%s'] nfit run):\n", $runq_metrics_source_profile_name_for_this_calc;
    printf {$fh} "     - AbsRunQ P90             : %s threads\n", ($absP90_for_this_calc // $na);
    printf {$fh} "     - NormRunQ P50            : %s\n", ($normP50_for_this_calc // $na);
    printf {$fh} "     - NormRunQ P90            : %s\n", ($normP90_for_this_calc // $na);
    print {$fh} "  3. VM Configuration:\n";
    printf {$fh} "     - SMT                     : %s\n", ($smt_val // $na);
    my $entitlement_display = (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} && $vm_cfg_ref->{entitlement} ne '') ? $vm_cfg_ref->{entitlement} : $na;
    printf {$fh} "     - Current Entitlement     : %s cores\n", $entitlement_display;
    my $lpar_max_cpu_display = ($lpar_max_cpu_cfg_val_from_config > 0) ? sprintf("%.2f", $lpar_max_cpu_cfg_val_from_config) : $na;
    printf {$fh} "     - LPAR MaxCPU             : %s cores\n", $lpar_max_cpu_display;
    my $is_non_default_pool_log = (defined $vm_cfg_ref && defined $vm_cfg_ref->{pool_name} && lc($vm_cfg_ref->{pool_name}) ne 'defaultpool' && $vm_cfg_ref->{pool_name} ne '') ? "Yes" : "No";
    printf {$fh} "     - In Non-Default Pool     : %s\n", $is_non_default_pool_log;
    printf {$fh} "  4. Profile RunQ Behavior    : %s\n\n", ($profile_rq_behavior // $na);

    # --- Check if modification was skipped early ---
    if (defined $calc_debug_info_ref->{'ReasonForNoModification'} && $calc_debug_info_ref->{'ReasonForNoModification'} ne '')
    {
        printf {$fh} "RunQ Modification Skipped: %s\n", $calc_debug_info_ref->{'ReasonForNoModification'};
        printf {$fh} "Final Value for Profile '%s': %s cores (same as Base PhysC due to skip)\n\n", $profile_being_adjusted, ($raw_physc_for_profile // $na);
        return;
    }

    # --- Section B: RunQ-Driven CPU Adjustment Calculation ---
    print {$fh} "Section B: RunQ-Driven CPU Adjustment Calculation\n";
    print {$fh} "  1. Efficiency Adjustment:\n";
    printf {$fh} "     - Efficiency Factor       : %s (Reason: %s)\n", ($calc_debug_info_ref->{'EffFactor'} // $na), ($calc_debug_info_ref->{'EffFactorReason'} // $na);
    printf {$fh} "     - PhysC after Efficiency  : %s cores\n\n", ($calc_debug_info_ref->{'BaseAdjustedPhysC'} // $na);

    print {$fh} "  2. Pressure Assessment (based on RunQ Metrics for profile '$profile_being_adjusted'):\n";

    # --- RunQ Pressure (Absolute Queue vs LPAR Max Capacity) ---
    my $runq_pressure_val_numeric_from_debug = ($calc_debug_info_ref->{'RunQPressure_P90_Val'} ne $na && $calc_debug_info_ref->{'RunQPressure_P90_Val'} =~ /^-?[0-9.]+$/)
                                          ? ($calc_debug_info_ref->{'RunQPressure_P90_Val'} + 0)
                                          : undef;
    my $runq_pressure_interpretation = $na;
    my $runq_pressure_calc_display = $na;

    # Reconstruct calculation string for display if inputs available
    my $abs_p90_num_for_display = ($absP90_for_this_calc ne $na && $absP90_for_this_calc =~ /^-?[0-9.]+$/) ? ($absP90_for_this_calc + 0) : undef;
    my $max_cpu_num_for_display = ($lpar_max_cpu_cfg_val_from_config > 0) ? $lpar_max_cpu_cfg_val_from_config : 0;
    my $smt_num_for_display = ($smt_val > 0) ? $smt_val : 0;

    if (defined $abs_p90_num_for_display && $max_cpu_num_for_display > 0 && $smt_num_for_display > 0)
    {
        my $denominator_rp_log_disp = $max_cpu_num_for_display * $smt_num_for_display;
        $runq_pressure_calc_display = sprintf("%.2f / (%.2f * %d)", $abs_p90_num_for_display, $max_cpu_num_for_display, $smt_num_for_display);
    }

    if (defined $runq_pressure_val_numeric_from_debug)
    {
        if ($runq_pressure_val_numeric_from_debug > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD) { $runq_pressure_interpretation = "HIGH PRESSURE"; }
        elsif ($runq_pressure_val_numeric_from_debug > 0.70) { $runq_pressure_interpretation = "MODERATE"; } # Example interpretive band
        else { $runq_pressure_interpretation = "LOW"; }
    }

    print {$fh} "     - RunQ Pressure (Absolute Queue vs LPAR Max Capacity):\n";
    printf {$fh} "         Value                   : %s (Calculated as: %s = %s)\n", 
                 ($calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na), 
                 $runq_pressure_calc_display, 
                 ($calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na);
    printf {$fh} "         Interpretation          : %s (Flag threshold: > %.2f)\n", $runq_pressure_interpretation, $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD;
    printf {$fh} "         IsRunQPressure Flag     : %s\n", ($calc_debug_info_ref->{'IsRunQPressure'} // $na);

    # --- Workload Pressure (Normalized Queue vs Active CPUs) ---
    my $norm_p90_val_for_display = ($normP90_for_this_calc ne $na && $normP90_for_this_calc =~ /^-?[0-9.]+$/) ? ($normP90_for_this_calc + 0) : undef;
    my $workload_pressure_interpretation = $na;
    if (defined $norm_p90_val_for_display)
    {
        if ($norm_p90_val_for_display > 1.5) { $workload_pressure_interpretation = "HIGH QUEUING per active LCPU"; } 
        elsif ($norm_p90_val_for_display > 1.0) { $workload_pressure_interpretation = "MODERATE QUEUING per active LCPU"; } 
        else { $workload_pressure_interpretation = "OPTIMAL/LOW QUEUING per active LCPU"; }
    }

    print {$fh} "     - Workload Pressure (Normalized Queue vs Active CPUs):\n";
    printf {$fh} "         NormRunQ P90 Value      : %s (from profile '%s')\n", ($normP90_for_this_calc // $na), $profile_being_adjusted;
    printf {$fh} "         Interpretation          : %s (Flag threshold: > %.2f)\n", $workload_pressure_interpretation, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD;
    printf {$fh} "         Workload Pressure Reason: %s\n", ($calc_debug_info_ref->{'WorkloadPressureReason'} // $na);
    printf {$fh} "         IsWorkloadPressure Flag : %s\n", ($calc_debug_info_ref->{'IsWorkloadPressure'} // $na);

    # --- Additive Logic Applies ---
    my $is_rq_pressure_bool_log = ($calc_debug_info_ref->{'IsRunQPressure'} // "False") eq "True";
    my $is_wl_pressure_bool_log = ($calc_debug_info_ref->{'IsWorkloadPressure'} // "False") eq "True";
    my $apply_additive_log = $is_rq_pressure_bool_log || $is_wl_pressure_bool_log;
    printf {$fh} "     >> Additive Logic Applies  : %s\n\n", ($apply_additive_log ? "Yes" : "No");

    # --- Section B: Item 3. Additive CPU Calculation ---
    my $final_additive_val_log = $calc_debug_info_ref->{'FinalAdditive'} // "0.0000";
    if ($apply_additive_log)
    {
        print {$fh} "  3. Additive CPU Calculation:\n";
        my $base_physc_for_add_log = $calc_debug_info_ref->{'BasePhysC'} // $na;
        if ($base_physc_for_add_log ne $na && $base_physc_for_add_log =~ /^-?[0-9.]+$/)
        {
            printf {$fh} "     - Base PhysC for Additive : %.4f cores (Raw PhysC of profile '%s')\n", $base_physc_for_add_log, $profile_being_adjusted;
        }
        else
        {
            printf {$fh} "     - Base PhysC for Additive : %s (Raw PhysC of profile '%s')\n", $base_physc_for_add_log, $profile_being_adjusted;
        }
        printf {$fh} "     - Effective Base LCPUs    : %s threads (Base PhysC * SMT)\n", ($calc_debug_info_ref->{'EffectiveLCPUsAtBase'} // $na);
        printf {$fh} "     - Excess Threads          : %s threads (AbsRunQ P90 vs. Tolerated Run-Queue Capacity)\n", ($calc_debug_info_ref->{'ExcessThreads'} // $na);
        printf {$fh} "     - Raw Additive CPU        : %s cores (Excess Threads / SMT)\n", ($calc_debug_info_ref->{'RawAdditive'} // $na);
        printf {$fh} "     - Max Additive Cap        : %s cores (Derived from Entitlement: %s)\n", ($calc_debug_info_ref->{'MaxAdditiveCap'} // $na), $entitlement_display;
        printf {$fh} "     - Capped Raw Additive     : %s cores (Min(Raw Additive, Max Cap))\n", ($calc_debug_info_ref->{'CappedRawAdditive'} // $na);
        printf {$fh} "     - Volatility Factor       : %s (Reason: %s)\n", ($calc_debug_info_ref->{'VoltFactor'} // $na), ($calc_debug_info_ref->{'VoltFactorReason'} // $na);
        printf {$fh} "     - Pool Factor             : %s\n", ($calc_debug_info_ref->{'PoolFactor'} // $na);
        printf {$fh} "     - Final Additive CPU      : %s cores\n\n", ($final_additive_val_log eq $na ? $na : sprintf "%.4f", $final_additive_val_log);
    }
    else
    {
        print {$fh} "  3. Additive CPU Calculation : Skipped (No significant pressure detected or other condition prevented additive logic).\n\n";
    }

    # --- Section B: Item 4. CPU Recommendation (Pre LPAR MaxCPU Cap) ---
    print {$fh} "  4. CPU Recommendation (Pre LPAR MaxCPU Cap):\n";
    my $pre_cap_rec_val_log = $calc_debug_info_ref->{'PreMaxCpuCapRec'} // $na;
    printf {$fh} "     - Pre-Cap Value           : %s cores (PhysC after Efficiency + Final Additive)\n\n", ($pre_cap_rec_val_log eq $na ? $na : sprintf "%.4f", $pre_cap_rec_val_log);

    # --- Section C: LPAR MaxCPU Capping ---
    print {$fh} "Section C: LPAR MaxCPU Capping\n";
    printf {$fh} "  1. LPAR MaxCPU (from config)  : %s cores\n", $lpar_max_cpu_display;
    printf {$fh} "  2. Entitlement (for multiplier): %s cores\n", $entitlement_display;
    my $fm_val_log = $calc_debug_info_ref->{'ForecastMultiplier'};
    if (defined $fm_val_log && $fm_val_log ne $na && $fm_val_log =~ /^-?[0-9.]+$/)
    {
         printf {$fh} "  3. Forecast Multiplier        : %.2f\n", $fm_val_log;
    }
    else
    {
         printf {$fh} "  3. Forecast Multiplier        : %s\n", ($fm_val_log // $na);
    }
    my $eff_max_cap_val_log = $calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na;
    printf {$fh} "  4. Effective MaxCPU Cap       : %s cores (LPAR MaxCPU * Forecast Multiplier)\n", ($eff_max_cap_val_log eq $na ? $na : sprintf "%.4f", $eff_max_cap_val_log);
    printf {$fh} "  5. Is Capped by MaxCPU?       : %s\n\n", ($calc_debug_info_ref->{'CappedByMaxCPU'} // $na);

    # --- Section D: Final Result ---
    print {$fh} "Section D: Final Result for Profile '$profile_being_adjusted'\n";
    printf {$fh} "  - Final Adjusted Value      : %s cores\n", ($final_csv_value_for_profile // $na);
    print {$fh} "\n"; # Blank line for readability before next profile/VM
}

sub quote_csv
{
    my ($field) = @_;
    if (!defined $field)
    {
        $field = '';
    }
    $field =~ s/"/""/g; # Escape double quotes within the field
    return qq/"$field"/; # Enclose the entire field in double quotes
}

sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef;
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath
        or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//;    # Remove comments starting with #
        $line =~ s/\s*;.*//;    # Remove comments starting with ;
        $line =~ s/^\s+|\s+$//g; # Trim leading/trailing whitespace
        next if $line eq '';    # Skip empty lines

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/) # Section header
        {
            # Check if the previous section was potentially incomplete (only name, no flags)
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags} &&
                (!defined $loaded_profiles_list[-1]{runq_behavior} || $loaded_profiles_list[-1]{runq_behavior} eq 'default') )
            {
                 my $is_incomplete = 1;
                 if (defined $loaded_profiles_list[-1]{flags}) # Actually, a profile needs flags to be valid
                 {
                    $is_incomplete = 0;
                 }
                 if ($is_incomplete)
                 {
                    warn "Warning: Profile section '[$current_section_name]' in '$filepath' (line $line_number) appears incomplete (missing nfit_flags). Skipping this potentially malformed entry.\n";
                    pop @loaded_profiles_list;
                 }
            }

            $current_section_name = $1;
            $current_section_name =~ s/^\s+|\s+$//g;
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef;
                next;
            }
            # Initialize with name and default runq_behavior
            push @loaded_profiles_list, { name => $current_section_name, flags => undef, runq_behavior => 'default' };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/) # Key-value pair
        {
            my $key = lc($1);
            my $value = $2;
            $key =~ s/^\s+|\s+$//g;
            $value =~ s/^\s+|\s+$//g;

            if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
            {
                if ($key eq 'nfit_flags')
                {
                    if (defined $loaded_profiles_list[-1]{flags})
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                elsif ($key eq 'runq_modifier_behavior')
                {
                     if (defined $loaded_profiles_list[-1]{runq_behavior} && $loaded_profiles_list[-1]{runq_behavior} ne 'default')
                    {
                        warn "Warning: Duplicate 'runq_modifier_behavior' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    # Validate the value for runq_modifier_behavior
                    if ($value eq 'additive_only' || $value eq 'default')
                    {
                        $loaded_profiles_list[-1]{runq_behavior} = $value;
                    }
                    else
                    {
                        warn "Warning: Invalid value '$value' for 'runq_modifier_behavior' in profile '[$current_section_name]' (line $line_number). Using default. Allowed: additive_only, default.\n";
                        $loaded_profiles_list[-1]{runq_behavior} = 'default'; # Fallback to default
                    }
                }
                # Add other potential profile-specific keys here if needed in the future
            }
            else
            {
                 warn "Warning: Key-value pair '$key=$value' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping.\n";
            }
        }
        elsif ($line ne '') # Non-empty line that doesn't match section or key-value
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    }
    close $fh;

    # Final validation of loaded profiles
    my @valid_profiles;
    foreach my $p_ref (@loaded_profiles_list)
    {
        if (defined $p_ref->{flags} && $p_ref->{flags} ne '')
        {
            # runq_behavior is already defaulted during push or set if key found
            push @valid_profiles, $p_ref;
        }
        else
        {
            warn "Warning: Profile '[" . $p_ref->{name} . "]' in '$filepath' missing mandatory 'nfit_flags'. Removing.\n";
        }
    }
    return @valid_profiles;
}


# --- calculate_runq_modified_physc (with enhanced efficiency logic) ---
sub calculate_runq_modified_physc
{
    my ($selected_tier_physc_value_str, $norm_runq_p50_str, $norm_runq_p90_str, $abs_runq_p90_str,
        $smt_used, $current_entitlement_str, $max_cpu_config_str, $is_in_non_default_pool,
        $profile_runq_behavior_setting
    ) = @_;

    my %debug_info;
    my $na_str = "N/A";

    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // $na_str;
    $profile_runq_behavior_setting //= 'default';

    my $base_physc = ($selected_tier_physc_value_str ne $na_str && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/) ? ($selected_tier_physc_value_str + 0) : undef;

    # Initialize all debug fields
    $debug_info{'EffFactorReason'} = "Efficiency calculation not applicable or skipped";
    $debug_info{'EffFactor'} = "1.00";
    $debug_info{'BaseAdjustedPhysC'} = defined($base_physc) ? sprintf("%.4f", $base_physc) : $na_str;
    $debug_info{'RunQPressure_P90_Val'} = $na_str; $debug_info{'IsRunQPressure'} = "False";
    $debug_info{'IsWorkloadPressure'} = "False"; $debug_info{'WorkloadPressureReason'} = "Conditions not met or N/A inputs";
    $debug_info{'EffectiveLCPUsAtBase'} = $na_str; $debug_info{'ExcessThreads'} = $na_str;
    $debug_info{'RawAdditive'} = "0.0000"; $debug_info{'MaxAdditiveCap'} = "0.0000"; $debug_info{'CappedRawAdditive'} = "0.0000";
    $debug_info{'VoltFactorReason'} = "Default"; $debug_info{'VoltFactor'} = "1.00";
    $debug_info{'PoolFactor'} = "1.00";
    $debug_info{'FinalAdditive'} = "0.0000";
    $debug_info{'PreMaxCpuCapRec'} = $debug_info{'BaseAdjustedPhysC'};
    $debug_info{'LPARMaxCPUConfig'} = ($max_cpu_config_str ne "" && $max_cpu_config_str =~ /^[0-9.]+$/ && ($max_cpu_config_str+0) > 0) ? ($max_cpu_config_str+0) : $na_str;
    $debug_info{'EntitlementForForecast'} = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/) ? ($current_entitlement_str + 0) : 0;
    $debug_info{'ForecastMultiplier'} = $na_str; $debug_info{'EffectiveMaxCPUCap'} = $na_str;
    $debug_info{'CappedByMaxCPU'} = $na_str;
    $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BasePhysC'};
    $debug_info{'ReasonForNoModification'} = "";

    my $curr_ent_numeric = $debug_info{'EntitlementForForecast'};

    unless (defined $base_physc)
    {
        $debug_info{'ReasonForNoModification'} = "BasePhysC for profile not numeric or N/A";
        $debug_info{'FinalAdjustedPhysC'} = $selected_tier_physc_value_str // $na_str;
        return ($selected_tier_physc_value_str // $na_str, \%debug_info);
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne $na_str && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne $na_str && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_p90_numeric  = ($abs_runq_p90_str  ne $na_str && $abs_runq_p90_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_str + 0)  : undef;
    my $max_cpu_for_lpar_numeric = ($debug_info{'LPARMaxCPUConfig'} ne $na_str) ? $debug_info{'LPARMaxCPUConfig'} : 0;

    # --- Enhanced Efficiency Factor Logic ---
    my $efficiency_factor_numeric = 1.00;
    # Guard: Skip efficiency reduction if Base PhysC > Entitlement (and entitlement > 0)
    if (defined $curr_ent_numeric && $curr_ent_numeric > 0 && $base_physc > $curr_ent_numeric)
    {
        $debug_info{'EffFactorReason'} = sprintf("Skipped: Base PhysC (%.4f) > Entitlement (%.2f)", $base_physc, $curr_ent_numeric);
    }
    elsif ($profile_runq_behavior_setting eq 'additive_only')
    {
        $debug_info{'EffFactorReason'} = "Skipped: Profile runq_behavior=additive_only";
    }
    elsif (defined $norm_p50_numeric && defined $norm_p90_numeric && defined $abs_p90_numeric && $smt_used > 0)
    {
        my $effective_p50_for_volatility = ($norm_p50_numeric > 0.0001)
                                         ? max($norm_p50_numeric, $MIN_P50_DENOMINATOR_FOR_VOLATILITY)
                                         : $MIN_P50_DENOMINATOR_FOR_VOLATILITY;
        my $volatility_ratio = (defined $norm_p90_numeric && $effective_p50_for_volatility > 0.0001)
                               ? ($norm_p90_numeric / $effective_p50_for_volatility)
                               : 1.0;

        if ($volatility_ratio >= $VOLATILITY_CAUTION_THRESHOLD)
        {
            $debug_info{'EffFactorReason'} = sprintf("Skipped: Workload volatile (NormP90/P50 ratio %.2f >= %.2f)",
                                                     $volatility_ratio, $VOLATILITY_CAUTION_THRESHOLD);
        }
        elsif ($norm_p50_numeric < $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION)
        {
            my $target_norm_runq_eff_calc = $DEFAULT_TARGET_NORM_RUNQ_FOR_EFFICIENCY_CALC;
            if    ($smt_used >= 8) { $target_norm_runq_eff_calc = 0.90; }
            elsif ($smt_used >= 4) { $target_norm_runq_eff_calc = 0.75; }
            else                   { $target_norm_runq_eff_calc = 0.60; }

            my $p_efficient_target = ($smt_used * $target_norm_runq_eff_calc > 0.0001)
                                   ? ($abs_p90_numeric / ($smt_used * $target_norm_runq_eff_calc))
                                   : $base_physc + 1;

            if ($base_physc > $p_efficient_target)
            {
                my $potential_reduction_cores = $base_physc - $p_efficient_target;
                my $max_allowable_reduction_cores = $base_physc * $MAX_EFFICIENCY_REDUCTION_PERCENTAGE;
                my $actual_reduction_cores = min($potential_reduction_cores, $max_allowable_reduction_cores);
                
                if ($actual_reduction_cores > 0.0001)
                {
                    my $new_physc_after_reduction = $base_physc - $actual_reduction_cores;
                    $efficiency_factor_numeric = ($base_physc > 0.0001) ? ($new_physc_after_reduction / $base_physc) : 1.00;
                    
                    my $min_expected_eff_factor = 1 - $MAX_EFFICIENCY_REDUCTION_PERCENTAGE;
                    if ($efficiency_factor_numeric < ($min_expected_eff_factor - 0.001) ) {$efficiency_factor_numeric = $min_expected_eff_factor;}
                    $efficiency_factor_numeric = 1.00 if $efficiency_factor_numeric > 1.00;

                    $debug_info{'EffFactorReason'} = sprintf("Analytical: NormP50 %.2f low (< %.2f), not volatile (ratio %.2f). P_base %.4f, P_efficient_target(SMT%d-based NormRunQ_target %.2f) %.4f. Reduction of %.4f cores (capped at %.0f%% of P_base). New factor %.2f.",
                                                             $norm_p50_numeric, $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION,
                                                             $volatility_ratio, $base_physc, $smt_used, $target_norm_runq_eff_calc, $p_efficient_target, 
                                                             $actual_reduction_cores, $MAX_EFFICIENCY_REDUCTION_PERCENTAGE * 100,
                                                             $efficiency_factor_numeric);
                }
                else
                {
                    $debug_info{'EffFactorReason'} = sprintf("Analytical: NormP50 %.2f low, but P_base %.4f already near/below P_efficient_target %.4f or calculated reduction (%.4f) negligible. No adjustment.", 
                                                             $norm_p50_numeric, $base_physc, $p_efficient_target, $actual_reduction_cores // 0);
                }
            }
            else 
            {
                $debug_info{'EffFactorReason'} = sprintf("Analytical: NormP50 %.2f low, but P_base %.4f already efficient for AbsRunQ P90 %.2f (P_efficient_target %.4f). No adjustment.", 
                                                         $norm_p50_numeric, $base_physc, ($abs_p90_numeric // $na_str), $p_efficient_target);
            }
        }
        else 
        {
            $debug_info{'EffFactorReason'} = sprintf("NormRunQ P50 (%.2f) >= threshold (%.2f). No efficiency adjustment.",
                                                     $norm_p50_numeric, $NORM_P50_THRESHOLD_FOR_EFFICIENCY_CONSIDERATION);
        }
    }
    else 
    {
        $debug_info{'EffFactorReason'} = $debug_info{'EffFactorReason'} eq "Efficiency calculation not applicable or skipped" ? "Key metrics N/A for full analytical efficiency check. Using default EffFactor." : $debug_info{'EffFactorReason'};
    }
    $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor_numeric);
    my $base_adjusted_physc = $base_physc * $efficiency_factor_numeric; 
    $debug_info{'BaseAdjustedPhysC'} = sprintf("%.4f", $base_adjusted_physc);
    # --- End of Enhanced Efficiency Factor Logic ---

    # Ensure modifier logic proceeds only if essential metrics are still valid post-efficiency
    unless (defined $abs_p90_numeric && $smt_used > 0 && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) )
    {
        $debug_info{'ReasonForNoModification'} = $debug_info{'ReasonForNoModification'} || "Missing essential RunQ or contextual metrics for further modifier logic after efficiency step.";
        $debug_info{'VoltFactorReason'} = "Skipped: " . ($debug_info{'ReasonForNoModification'} || "Essential metrics N/A");
        $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BaseAdjustedPhysC'}; # Value after efficiency factor
        return ($base_adjusted_physc, \%debug_info);
    }
    
    # --- RunQ Pressure (Absolute vs LPAR Max) ---
    # (Logic remains the same, using $abs_p90_numeric, $max_cpu_for_lpar_numeric, $smt_used)
    # ... (This section from your file) ...
    my $runq_pressure_p90_val = 0;
    if ($max_cpu_for_lpar_numeric > 0 && $smt_used > 0)
    {
        $runq_pressure_p90_val = $abs_p90_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
    }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p90_val);
    my $is_runq_pressure = ($runq_pressure_p90_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False";


    # --- Workload Pressure (Normalized) ---
    my $is_workload_pressure_calc = 0;
    my $workload_pressure_reason_str_calc = "Workload pressure conditions not met or inputs N/A.";
    my $min_absrunq_for_workload_pressure_check = $smt_used;

    if (defined $norm_p90_numeric)
    {
        if ($norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
        {
            if (defined $abs_p90_numeric && $abs_p90_numeric >= $min_absrunq_for_workload_pressure_check)
            {
                $is_workload_pressure_calc = 1;
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f) AND AbsRunQ P90 (%.2f) >= SMT-based min threshold (%.2f)",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $abs_p90_numeric, $min_absrunq_for_workload_pressure_check);
            }
            else
            {
                $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f), BUT AbsRunQ P90 (%.2f) < SMT-based min threshold (%.2f). Workload Pressure NOT flagged.",
                                                      $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                                      $abs_p90_numeric // $na_str, $min_absrunq_for_workload_pressure_check);
            }
        }
        else
        {
            $workload_pressure_reason_str_calc = sprintf("NormRunQ P90 (%.2f) <= threshold (%.2f)",
                                                  $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
        }
    }
    else
    {
        $workload_pressure_reason_str_calc = "NormRunQ P90 N/A";
    }
    $debug_info{'IsWorkloadPressure'} = $is_workload_pressure_calc ? "True" : "False";
    $debug_info{'WorkloadPressureReason'} = $workload_pressure_reason_str_calc;
    
    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure_calc);

    # --- Additive CPU Calculation ---
    # (Logic remains largely the same, ensures it uses original $base_physc for EffectiveLCPUsAtBase)
    # ... (This section from your file, ensure $base_adjusted_physc is used as starting point for adding additive_cpu) ...
    my $additive_cpu = 0.0; 
    my $raw_additive_cpu = 0.0;
    my $max_additive_cap_sliding = 0.0;
    my $capped_raw_additive_val = 0.0;
    my $volatility_confidence_factor = 1.0;
    my $pool_confidence_factor = 1.0;
    $debug_info{'VoltFactorReason'} = "Default (no overriding condition met or additive not applied)";

    if ($apply_additive_logic) 
    {
        my $effective_lcpus_at_original_base = $base_physc * $smt_used; 
        $debug_info{'EffectiveLCPUsAtBase'} = sprintf("%.4f", $effective_lcpus_at_original_base);

		  # Apply the tolerance factor to the capacity threshold
		  my $capacity_threshold_for_excess = $RUNQ_ADDITIVE_TOLERANCE_FACTOR * $effective_lcpus_at_original_base;
		  my $excess_threads = $abs_p90_numeric - $capacity_threshold_for_excess; # Check against tolerated capacity
        
        if ($excess_threads > 0)
        {
            $debug_info{'ExcessThreads'} = sprintf("%.4f (AbsRunQ P90 %.2f > Tolerated Capacity %.2f)",
                                                   $excess_threads, $abs_p90_numeric, $capacity_threshold_for_excess);
            $raw_additive_cpu = $excess_threads / $smt_used;
            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; }
            else { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            
            $capped_raw_additive_val = min($raw_additive_cpu, $max_additive_cap_sliding);
            
            if ($is_runq_pressure)
            {
                $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR;
                $debug_info{'VoltFactorReason'} = sprintf("RunQPressure Saturation (Factor set to %.2f)", $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR);
            }
            elsif ($is_workload_pressure_calc && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01)
            {
                my $volatility_ratio_for_factor = ($norm_p50_numeric > 0.01) 
                                                 ? ($norm_p90_numeric / $norm_p50_numeric) 
                                                 : 999; 
                if ($volatility_ratio_for_factor < $VOLATILITY_SPIKY_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; }
                elsif ($volatility_ratio_for_factor < $VOLATILITY_MODERATE_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; }
                else { $volatility_confidence_factor = 1.0; } 
                $debug_info{'VoltFactorReason'} = sprintf("Calculated (NormRQ P50/P90 ratio %.2f for WorkloadPressure -> Factor %.2f)", $volatility_ratio_for_factor, $volatility_confidence_factor);
            }
            else
            {
                 $debug_info{'VoltFactorReason'} = "Additive logic applied, but conditions for specific Volatility Factor adjustment not met (e.g., WorkloadPressure False or P50/P90 N/A).";
            }
            $additive_cpu = $capped_raw_additive_val * $volatility_confidence_factor;
            if ($is_in_non_default_pool && $additive_cpu > 0)
            {
                $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR;
                $additive_cpu *= $pool_confidence_factor;
            }
        }
        else
        {
            $debug_info{'ExcessThreads'} = sprintf("0.0000 (No excess above tolerated capacity of %.2f; AbsRunQ P90 was %.2f)",
                                                   $capacity_threshold_for_excess, $abs_p90_numeric // $na_str);
            $raw_additive_cpu = 0.0; # Ensure it's zero if no excess above tolerance
        }
    }
    else 
    {
        $debug_info{'ExcessThreads'} = "N/A (Additive logic not applied)";
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu);
    $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding);
    $debug_info{'CappedRawAdditive'} = sprintf("%.4f", $capped_raw_additive_val);
    $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor);
    $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor);
    $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);
    
    my $calculated_demand = $base_adjusted_physc + $additive_cpu; 
    my $runq_modified_rec = $calculated_demand;
    $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    # --- Final MaxCPU capping logic ---
    # ... (This section from your file, ensure Allman style) ...
    my $forecast_multiplier_val = 1.25;
    if ($curr_ent_numeric < 0.5) { $forecast_multiplier_val = 2.5; }
    elsif ($curr_ent_numeric < 1.0) { $forecast_multiplier_val = 2.0; }
    elsif ($curr_ent_numeric < 2.0) { $forecast_multiplier_val = 1.75; }
    elsif ($curr_ent_numeric < 4.0) { $forecast_multiplier_val = 1.5; }
    $debug_info{'ForecastMultiplier'} = $forecast_multiplier_val;

    my $effective_max_cpu_cap_val = ($max_cpu_for_lpar_numeric > 0) ? ($max_cpu_for_lpar_numeric * $forecast_multiplier_val) : undef;
    $debug_info{'EffectiveMaxCPUCap'} = defined($effective_max_cpu_cap_val) ? sprintf("%.4f", $effective_max_cpu_cap_val) : $na_str;
    
    if (defined $effective_max_cpu_cap_val && $calculated_demand > $effective_max_cpu_cap_val)
    {
        $runq_modified_rec = $effective_max_cpu_cap_val;
        $debug_info{'CappedByMaxCPU'} = "True";
    }
    else
    {
      $debug_info{'CappedByMaxCPU'} = (defined $effective_max_cpu_cap_val) ? "False" : "N/A (No LPAR MaxCPU for cap check)";
    }

    if ($runq_modified_rec < 0) { $runq_modified_rec = 0; }
    $debug_info{'FinalAdjustedPhysC'} = sprintf("%.4f", $runq_modified_rec);


    return ($runq_modified_rec, \%debug_info);
}

# --- generate_sizing_hint (Update Workload Pressure part) ---
sub generate_sizing_hint
{
    my %args = @_;
    my $results_ref = $args{'results_ref'};
    my $vm = $args{'vm'};
    my $config_ref = $args{'config_ref'};
    my $norm_runq_p90_for_vm_str = $args{'norm_runq_p90_for_vm_str'};
    my $abs_runq_p90_for_vm_str  = $args{'abs_runq_p90_for_vm_str'};
    my $max_cpu_for_vm_numeric   = $args{'max_cpu_for_vm_numeric'};
    my $smt_used_for_vm_numeric  = $args{'smt_used_for_vm_numeric'};
    my $na_str_hint = "N/A"; # Local N/A string

    # ... (Existing VIO server check, profile value parsing, pattern, peakiness - Allman style maintained) ...
    if (defined $config_ref && defined $config_ref->{'systemtype'} && $config_ref->{'systemtype'} =~ /VIO Server/i)
    {
        return ("P", "VIO Server", 0, "");
    }
    
    my $o3_val = $results_ref->{$vm}{'O3-95W15'} // "0"; $o3_val = ($o3_val ne $na_str_hint && $o3_val =~ /^-?[0-9.]+\z/) ? ($o3_val+0) : 0;
    my $b3_val = $results_ref->{$vm}{'B3-95W15'} // "0"; $b3_val = ($b3_val ne $na_str_hint && $b3_val =~ /^-?[0-9.]+\z/) ? ($b3_val+0) : 0;
    my $g3_val = $results_ref->{$vm}{'G3-95W15'} // "0"; $g3_val = ($g3_val ne $na_str_hint && $g3_val =~ /^-?[0-9.]+\z/) ? ($g3_val+0) : 0;
    my $p99w1_val = $results_ref->{$vm}{'P-99W1'} // "0"; $p99w1_val = ($p99w1_val ne $na_str_hint && $p99w1_val =~ /^-?[0-9.]+\z/) ? ($p99w1_val+0) : 0;
    
    my $suggested_pattern = "G";
    if ($b3_val > 0.01 && $o3_val > ($b3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "O";
    }
    elsif ($o3_val > 0.01 && $b3_val > ($o3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "B";
    }
    
    my $peakiness_ratio = 0;
    if ($g3_val > 0.01)
    {
        $peakiness_ratio = ($p99w1_val / $g3_val);
    }
    
    my $shape_descriptor = "Steady";
    if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Very Peaky";
    }
    elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Moderately Peaky";
    }
    
    my $pressure_detected_maxcpu_limit = 0;
    my $pressure_detected_runq_pressure = 0;
    my $pressure_detected_workload_pressure = 0; 
    my $pressure_detail_str = "";
    
    my $maxcpu_val_from_config = (defined $config_ref && defined $config_ref->{'maxcpu'} && $config_ref->{'maxcpu'} =~ /^[0-9.]+$/ && ($config_ref->{'maxcpu'}+0) > 0) ? ($config_ref->{'maxcpu'}+0) : undef;
    if (defined $maxcpu_val_from_config && $p99w1_val >= ($maxcpu_val_from_config * $LIMIT_THRESHOLD_PERC))
    {
        $pressure_detected_maxcpu_limit = 1;
    }
    
    my $abs_runq_p90_for_hint_numeric = ($abs_runq_p90_for_vm_str ne $na_str_hint && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;
    my $runq_pressure_p90_calculated_value = 0;
    if (defined $abs_runq_p90_for_hint_numeric && defined $max_cpu_for_vm_numeric && $max_cpu_for_vm_numeric > 0 && defined $smt_used_for_vm_numeric && $smt_used_for_vm_numeric > 0)
    {
        $runq_pressure_p90_calculated_value = $abs_runq_p90_for_hint_numeric / ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric);
    }
    if ($runq_pressure_p90_calculated_value > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD)
    {
        $pressure_detected_runq_pressure = 1;
    }
    
    my $norm_runq_p90_for_hint_numeric = ($norm_runq_p90_for_vm_str ne $na_str_hint && $norm_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_for_vm_str + 0) : undef;
    # Use SMT passed to this sub for the threshold check
    my $min_absrunq_threshold_for_hint_check = $smt_used_for_vm_numeric; 

    if (defined $norm_runq_p90_for_hint_numeric && $norm_runq_p90_for_hint_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
    {
        if (defined $abs_runq_p90_for_hint_numeric && $abs_runq_p90_for_hint_numeric >= $min_absrunq_threshold_for_hint_check)
        {
            $pressure_detected_workload_pressure = 1;
        }
    }
    
    my $overall_pressure_detected = $pressure_detected_maxcpu_limit || $pressure_detected_runq_pressure || $pressure_detected_workload_pressure;
    # ... (rest of generate_sizing_hint logic, Allman style maintained) ...
    if ($overall_pressure_detected)
    {
        my @pressure_points;
        if ($pressure_detected_maxcpu_limit) { push @pressure_points, "MaxCPU"; }
        if ($pressure_detected_runq_pressure) { push @pressure_points, "RunQPressure(P90=" . sprintf("%.2f", $runq_pressure_p90_calculated_value) . ")"; }
        if ($pressure_detected_workload_pressure) { push @pressure_points, "Workload(NormP90=" . sprintf("%.2f", $norm_runq_p90_for_hint_numeric // 0) . ")"; } # Ensure numeric for sprintf
        if (defined $config_ref && defined $config_ref->{'pool_name'} && lc($config_ref->{'pool_name'}) ne 'defaultpool' && $config_ref->{'pool_name'} ne '')
        {
            push @pressure_points, "Pool(" . $config_ref->{'pool_name'} . ")?";
        }
        $pressure_detail_str = join(", ", @pressure_points);
    }
    
    my $initial_tier_range_str = "3/4";
    if ($shape_descriptor eq "Very Peaky")
    {
        $initial_tier_range_str = "1/2";
    }
    elsif ($shape_descriptor eq "Moderately Peaky")
    {
        $initial_tier_range_str = "2/3";
    }
    
    my $adjusted_tier_str = $initial_tier_range_str;
    if ($overall_pressure_detected)
    {
        if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; }
        elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; }
        elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; }
    }
    
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str;
    return ($pattern_tier_string, $shape_descriptor, $overall_pressure_detected, $pressure_detail_str);
}

# ... (Other subroutines: quote_csv, load_profile_definitions, etc. - ensure they are complete and Allman styled as per user's file) ...
sub parse_percentile_list_for_header
{
    my ($perc_str, $clean_zeros) = @_;
    $clean_zeros = 1 if !defined $clean_zeros;
    my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100)
            {
                my $p_label = $p;
                if ($clean_zeros)
                {
                    $p_label = sprintf("%.2f", $p);
                    $p_label =~ s/\.?0+$//;
                    $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00");
                }
                push @percentiles_cleaned, $p_label;
            }
            else
            {
                die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return \@percentiles_cleaned;
}

sub ensure_percentiles_requested
{
    my ($perc_list_str, @required_percs) = @_;
    return 1 unless defined $perc_list_str && $perc_list_str ne '';
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0);
    my %present_map = map { $_ => 1 } @{$parsed_percs_ref};
    foreach my $req_p (@required_percs)
    {
        unless (exists $present_map{$req_p})
        {
            return 0;
        }
    }
    return 1;
}

sub get_nfit_output_dp_from_flags
{
    my ($nfit_flags_str_for_this_run) = @_;
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/)
    {
        my $increment_val = $1 // $2;
        if (!(defined $increment_val && $increment_val ne ""))
        {
            $increment_val = $DEFAULT_ROUND_INCREMENT;
        }
        return get_decimal_places($increment_val);
    }
    return 4;
}

sub get_decimal_places
{
    my ($number) = @_;
    $number = sprintf("%.15f", $number) if ($number =~ /e/i);
    if ($number =~ /\.(\d+)$/)
    {
        return length($1);
    }
    else
    {
        return 0;
    }
}

sub usage_wrapper
{
    my $script_name = $0;
    $script_name =~ s{.*/}{};
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [options]

Runs 'nfit' for multiple profiles. Applies RunQ modifiers and generates hints.
The RunQ modifier behavior (standard vs. additive-only) can be controlled
per profile via the 'runq_modifier_behavior' attribute in nfit.profiles.cfg.
Optionally passes flags to nfit for its internal windowed decay processing.
A detailed rationale log is written to $LOG_FILE_PATH.

Core Input:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
  --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --default-smt, --smt <N> : Optional. Default SMT level (Default: $DEFAULT_SMT_VALUE_PROFILE).

RunQ Metric Configuration (for nfit calls):
  --runq-norm-percentiles <list> : For Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERCS").
  --runq-abs-percentiles <list>  : For Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERCS").

Configuration Files:
  -config <vm_cfg_csv>       : Optional. VM configuration CSV file.
  --profiles-config <path>   : Optional. Profiles definition file (INI format).
                               Can contain 'runq_modifier_behavior = additive_only' per profile.

Filtering (Global or passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Global start date for analysis (passed to nfit).
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name (passed to nfit).

Control nfit's Internal Windowed Recency Decay (Optional):
  --nfit-enable-windowed-decay    : Enable nfit's internal windowed processing.
                                    (Requires nfit v2.28.0.4+ for full RunQ decay support)
  --nfit-process-window-unit <days|weeks> : Unit for nfit's window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT).
  --nfit-process-window-size <N>  : Size of nfit's window in units (Default: $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT).
  --nfit-decay-half-life-days <N> : Half-life for nfit's recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT).
  --nfit-analysis-reference-date <YYYY-MM-DD> : "Current" date for nfit's recency calculation
                                    (Default: nfit uses date of last record in its filtered NMON data).
  --nfit-runq-avg-method <none|sma|ema> : Averaging method for RunQ data within nfit before percentile.
                                          (Default: $DEFAULT_NFIT_RUNQ_AVG_METHOD). Uses main -w/--decay/--runq-decay from profile.

Rounding (Passed to nfit for its output):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Default increment: $DEFAULT_ROUND_INCREMENT)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are potentially recency-weighted by nfit & RunQ-modified by nfit-profile)...],
  Current_ENT,NFIT_ENT_UserFormula,NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
