#!/usr/bin/env perl

# NAME     : nfit-profile
# VERSION  : 2.29.147.0 # Updated version for syntax fixes & confidence factor change
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' multiple times with user-defined profiles (from INI config file).
#            For each profile, it applies a "Unified RunQ Modifier" to the PhysC result
#            based on run-queue metrics (RunQPressure saturation and/or WorkloadPressure),
#            with differentiated impact. Calculates absolute peak, optionally merges
#            config data, suggests workload pattern/tier/shape/pressure hints,
#            and aggregates final adjusted results into a single CSV output.
# REQUIRES : Perl, nfit script

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);

# --- Version ---
my $SCRIPT_VERSION = '2.29.147.0';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90";
my $DEFAULT_RUNQ_ABS_PERCS  = "90";

# Heuristic Thresholds
my $PATTERN_RATIO_THRESHOLD = 2.0;
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;
my $LIMIT_THRESHOLD_PERC = 0.98;

# RunQ Modifier Thresholds
my $RUNQ_EFFICIENCY_NORM_P50_THRESHOLD = 0.5;
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 1.2;
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 0.75;

# Max_Additive_CPU Sliding Scale Thresholds
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;
my $MAX_ADD_PERC_VAL_ELSE = 0.5;

# RunQ Volatility Confidence Factor Thresholds & Values
my $VOLATILITY_SPIKY_THRESHOLD = 0.5; my $VOLATILITY_SPIKY_FACTOR = 0.70;
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85;
# Factor for confirmed RunQPressure (LPAR Saturation) - User requested 1.0
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0;

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80;

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak";

# --- Argument Parsing (Wrapper) ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;
my $roundup_arg;
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS;
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;
my $debug_runq_modifier = 0;
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit";

GetOptions(
    'physc-data|pc=s'         => \$physc_data_file,
    'runq-data|rq=s'          => \$runq_data_file_arg,
    'config=s'                => \$vm_config_file_arg,
    'profiles-config=s'       => \$profiles_config_file_arg,
    'startdate|s=s'           => \$start_date_str,
    'vm|lpar=s'               => \$target_vm_name,
    'round|r:f'               => \$round_arg,
    'roundup|u:f'             => \$roundup_arg,
    'default-smt|smt=i'       => \$default_smt_arg,
    'runq-norm-percentiles=s' => \$runq_norm_perc_list_str,
    'runq-abs-percentiles=s'  => \$runq_abs_perc_list_str,
    'debug-runq'              => \$debug_runq_modifier,
    'help|h'                  => \$help,
    'nfit-path=s'             => \$nfit_script_path,
    'version|v'               => \$show_version,
) or die usage_wrapper();

# --- Validation (Wrapper) ---
if ($show_version)
{
    print STDERR "nfit-profile version $SCRIPT_VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver = `$nfit_script_path -v 2>&1`;
        chomp $nfit_ver;
        $nfit_ver =~ s/^nfit version\s*//i;
        print STDERR "Uses nfit version: $nfit_ver\n";
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}
if ($help || !$physc_data_file)
{
    print STDERR usage_wrapper();
    exit 0;
}
if (! -f $physc_data_file)
{
    die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n";
}
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg)
{
    die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n";
}
if ($default_smt_arg <= 0)
{
    die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n";
}
if (! -x $nfit_script_path)
{
    die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n";
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $round_arg && length $round_arg && $round_arg !~ /^[0-9.]*$/)
{
    die "Error: Invalid numeric value for -r increment: '$round_arg'\n";
}
if (defined $roundup_arg && length $roundup_arg && $roundup_arg !~ /^[0-9.]*$/)
{
    die "Error: Invalid numeric value for -u increment: '$roundup_arg'\n";
}
if (defined $runq_data_file_arg)
{
    unless (ensure_percentiles_requested($runq_norm_perc_list_str, "50"))
    {
        die "Error: --runq-norm-percentiles ('$runq_norm_perc_list_str') must include a request for P50 for modifier logic when --runq-data is used.\n";
    }
    unless (ensure_percentiles_requested($runq_norm_perc_list_str, "90"))
    {
        die "Error: --runq-norm-percentiles ('$runq_norm_perc_list_str') must include a request for P90 for modifier logic when --runq-data is used.\n";
    }
    unless (ensure_percentiles_requested($runq_abs_perc_list_str, "90"))
    {
        die "Error: --runq-abs-percentiles ('$runq_abs_perc_list_str') must include a request for P90 for modifier logic when --runq-data is used.\n";
    }
}

# --- Load Profile Definitions ---
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE";
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
@profiles = load_profile_definitions($profiles_config_path_to_load);
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}
print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";

# --- Locate and Load VM Configuration Data ---
my $vm_config_file_path = undef;
my $vm_config_found = 0;
my %vm_config_data;
my %vm_config_col_idx;
my $vm_config_header_count = 0;
if (defined $vm_config_file_arg)
{
    if (-f $vm_config_file_arg)
    {
        $vm_config_file_path = $vm_config_file_arg;
        $vm_config_found = 1;
        print STDERR "Using specified VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n";
    }
}
else
{
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE";
    my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE";
    if (-f $dp_etc)
    {
        $vm_config_file_path = $dp_etc;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    elsif (-f $dp_root)
    {
        $vm_config_file_path = $dp_root;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n";
    }
}

if ($vm_config_found)
{
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>;
    unless (defined $hdr)
    {
        die "Error: Could not read header from VM config '$vm_config_file_path'\n";
    }
    chomp $hdr;
    $hdr =~ s/\r$//;
    $hdr =~ s/^\x{FEFF}//; 
    my @rhdrs = split /,/, $hdr;
    $vm_config_header_count = scalar @rhdrs;
    my %hmap;
    for my $i (0 .. $#rhdrs)
    {
        my $cn = $rhdrs[$i];
        $cn =~ s/^\s*"?|"?\s*$//g;
        if ($cn ne '')
        {
            $hmap{lc($cn)} = $i;
        }
    }
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'};
    unless (exists $hmap{'maxcpu'})
    {
        warn "Warning: 'maxcpu' column not found in VM config. RunQPressure_P90 calculation will be N/A.\n";
    }

    if ($has_smt_col)
    {
        print STDERR "Found 'SMT' column in VM configuration file.\n";
    }
    else
    {
        print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n";
    }

    foreach my $rc (@req_cols)
    {
        unless (exists $hmap{$rc})
        {
            die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n";
        }
        $vm_config_col_idx{$rc} = $hmap{$rc};
    }
    if ($has_smt_col)
    {
        $vm_config_col_idx{'smt'} = $hmap{'smt'};
    }

    while (my $ln = <$cfg_fh>)
    {
        chomp $ln;
        $ln =~ s/\r$//;
        next if $ln =~ /^\s*$/;
        my @rvals = ($ln =~ /"([^"]*)"/g); 
        if (scalar @rvals != $vm_config_header_count)
        {
            @rvals = split /,/, $ln;
            if (scalar @rvals != $vm_config_header_count)
            {
                warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n";
                next;
            }
            $_ =~ s/^\s+|\s+$//g for @rvals;
        }

        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ];
        if (defined $hn && $hn ne '')
        {
            my $smt_v = $default_smt_arg;
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '')
            {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/)
                {
                    $smt_v = $1;
                    if ($smt_v <= 0)
                    {
                        warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                        $smt_v = $default_smt_arg;
                    }
                }
                else
                {
                    warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                }
            }
            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0)
            {
                 $max_cpu_val = 0; 
            }

            $vm_config_data{$hn} = {
                serial      => $rvals[$vm_config_col_idx{'serial'}],
                systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name   => $rvals[$vm_config_col_idx{'procpool_name'}],
                pool_id     => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}],
                maxcpu      => ($max_cpu_val + 0), 
                smt         => $smt_v,
            };
        }
        else
        {
            warn "Warning: Missing hostname on VM config line $. Skipping.\n";
        }
    }
    close $cfg_fh;
    print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
}
else
{
     print STDERR "Warning: VM configuration file not loaded. RunQPressure_P90 calculation will be N/A and SMT will use default.\n";
}

# --- Construct Common Flags for nfit ---
my $common_nfit_flags_base = "-k --physc-data \"$physc_data_file\"";
if (defined $runq_data_file_arg)
{
    $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
    $common_nfit_flags_base .= " --runq-norm-perc \"$runq_norm_perc_list_str\"";
    $common_nfit_flags_base .= " --runq-abs-perc \"$runq_abs_perc_list_str\"";
}
if (defined $start_date_str)
{
    $common_nfit_flags_base .= " -s $start_date_str";
}
my $rounding_flags_for_nfit = "";
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit;

# --- Main Logic: Run nfit Profiles ---
my %results_table;
my @vm_order;
my %vm_seen;
print STDERR "nfit-profile version $SCRIPT_VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles)
{
    my $profile_name = $profile->{name};
    my $profile_specific_flags = $profile->{flags};
    print STDERR "Running profile: $profile_name ($profile_specific_flags)...\n";

    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg";
    my $nfit_vm_flag_for_current_run = "";

    if (defined $target_vm_name)
    {
        $nfit_vm_flag_for_current_run = " -vm \"$target_vm_name\"";
        if ($vm_config_found && exists $vm_config_data{$target_vm_name} && defined $vm_config_data{$target_vm_name}{'smt'})
        {
            $nfit_smt_flag_for_current_run = "--smt " . $vm_config_data{$target_vm_name}{'smt'};
        }
    }

    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags";
    my $output = `$command`;
    my $exit_status = $? >> 8;

    if ($exit_status != 0)
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Skip.\n";
        next;
    }

    my @output_lines = split /\n/, $output;
    foreach my $line (@output_lines)
    {
        chomp $line;
        if ($line =~ /^(.+?):\s*(.*)$/) 
        {
            my $vm_name = $1;
            my $metrics_str = $2;
            unless ($vm_seen{$vm_name}++)
            {
                push @vm_order, $vm_name;
            }

            my ($profile_p_val_str) = ($metrics_str =~ /P(\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/); 
            if (defined $profile_p_val_str)
            {
                 my $p_value_num_from_label = $1; 
                 my $p_value_val = $2;
                 $p_value_val =~ s/^\s+|\s+$//g;

                my ($profile_p_flag_val_from_nfit_flags) = ($profile_specific_flags =~ /-p\s+([0-9.]+)/);
                if (defined $profile_p_flag_val_from_nfit_flags)
                {
                    my $expected_p_label = sprintf("%.2f", $profile_p_flag_val_from_nfit_flags);
                    $expected_p_label =~ s/\.?0+$//;
                    $expected_p_label = "0" if $expected_p_label eq ""; 

                    my $parsed_p_label   = sprintf("%.2f", $p_value_num_from_label);
                    $parsed_p_label =~ s/\.?0+$//;
                    $parsed_p_label = "0" if $parsed_p_label eq ""; 

                    if ($parsed_p_label eq $expected_p_label)
                    {
                        $results_table{$vm_name}{$profile_name} = $p_value_val;
                    }
                }
            }
            else
            {
                 warn "Warning: Could not parse primary PXX value for profile '$profile_name' from nfit output for VM '$vm_name': $metrics_str\n";
            }

            if ($metrics_str =~ /Peak=([0-9.NA\/ -]+?)(?:\s+|$)/) 
            {
                my $peak_value = $1;
                $peak_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name}{$PEAK_PROFILE_NAME} = $peak_value;
            }

            while ($metrics_str =~ /(NormRunQ_P\d+\.?\d*|AbsRunQ_P\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/g) 
            {
                my ($rq_metric_name, $rq_value) = ($1, $2);
                $rq_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name}{$rq_metric_name} = $rq_value;
            }
        }
        else
        {
            if ($line ne '')
            {
                warn "Warning: Could not parse VM name from nfit output line for profile '$profile_name': $line\n";
            }
        }
    }
}
print STDERR "Finished all nfit profile runs. Generating CSV output...\n";

# --- Generate CSV Output ---
my @output_header_cols = (
    "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT",
    "NormRunQ_P50", "NormRunQ_P90", "AbsRunQ_P90",
    "RunQPressure_P90_Value", 
    "Serial", "SystemType", "Pool Name", "Pool ID",
    $PEAK_PROFILE_NAME
);
push @output_header_cols, map { $_->{name} } @profiles; 
push @output_header_cols, ("Current_ENT", "NFIT_ENT_UserFormula", "NETT_UserFormula", "NETT_Perc_UserFormula");

my @debug_column_keys; 
if ($debug_runq_modifier)
{
    @debug_column_keys = (
        "RunQ_BasePhysC_Profile", "RunQ_BasePhysC_Value",
        "RunQ_RunQPressure_P90_Val", "RunQ_IsRunQPressure", "RunQ_IsWorkloadPressure",
        "RunQ_VoltFactorReason", "RunQ_EffFactor",
        "RunQ_RawAdditive", "RunQ_MaxAdditiveCap", "RunQ_VoltFactor",
        "RunQ_PoolFactor", "RunQ_FinalAdditive", "RunQ_PreMaxCpuCapRec", "RunQ_CappedByMaxCPU"
    );
    push @output_header_cols, @debug_column_keys;
}

print STDOUT join(",", map { quote_csv($_) } @output_header_cols) . "\n";

foreach my $vm_name (@vm_order)
{
    my @data_row;
    my $cfg = $vm_config_data{$vm_name}; 
    my $smt_used_for_vm = (defined $cfg && defined $cfg->{smt}) ? $cfg->{smt} : $default_smt_arg;
    my $max_cpu_for_vm  = (defined $cfg && defined $cfg->{maxcpu} && $cfg->{maxcpu} > 0) ? $cfg->{maxcpu} : 0; 

    my $norm_runq_p50_for_vm_str = $results_table{$vm_name}{'NormRunQ_P50'} // "N/A";
    my $norm_runq_p90_for_vm_str = $results_table{$vm_name}{'NormRunQ_P90'} // "N/A";
    my $abs_runq_p90_for_vm_str  = $results_table{$vm_name}{'AbsRunQ_P90'}  // "N/A";

    my $runq_pressure_p90_value_for_csv = "N/A"; 
    my $abs_runq_p90_numeric_for_calc = ($abs_runq_p90_for_vm_str ne "N/A" && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;
    if (defined $abs_runq_p90_numeric_for_calc && $max_cpu_for_vm > 0 && $smt_used_for_vm > 0)
    {
        $runq_pressure_p90_value_for_csv = sprintf("%.4f", $abs_runq_p90_numeric_for_calc / ($max_cpu_for_vm * $smt_used_for_vm));
    }

    my ($hint_type_tier, $hint_pattern_shape, $hint_pressure_bool, $pressure_detail_str) =
        generate_sizing_hint(
            'results_ref'              => \%results_table, # Pass as hash for named params
            'vm'                       => $vm_name,
            'config_ref'               => $cfg,
            'norm_runq_p90_for_vm_str' => $norm_runq_p90_for_vm_str,
            'abs_runq_p90_for_vm_str'  => $abs_runq_p90_for_vm_str,
            'max_cpu_for_vm_numeric'   => $max_cpu_for_vm,
            'smt_used_for_vm_numeric'  => $smt_used_for_vm
        );
    my $pressure_bool_str = $hint_pressure_bool ? "True" : "False";

    push @data_row, $vm_name;
    push @data_row, ""; 
    push @data_row, $hint_type_tier;
    push @data_row, $hint_pattern_shape;
    push @data_row, $pressure_bool_str;
    push @data_row, $pressure_detail_str;
    push @data_row, $smt_used_for_vm;
    push @data_row, $norm_runq_p50_for_vm_str;
    push @data_row, $norm_runq_p90_for_vm_str; 
    push @data_row, $abs_runq_p90_for_vm_str;
    push @data_row, $runq_pressure_p90_value_for_csv; 

    my %current_vm_debug_info_for_csv; 

    push @data_row, (defined $cfg ? $cfg->{serial} : "");
    push @data_row, (defined $cfg ? $cfg->{systemtype} : "");
    push @data_row, (defined $cfg ? $cfg->{pool_name} : "");
    push @data_row, (defined $cfg ? $cfg->{pool_id} : "");
    push @data_row, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // ""); 

    my $first_profile_debug_done = 0;
    foreach my $profile (@profiles)
    {
        my $profile_name = $profile->{name};
        my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name};
        my $adjusted_value_str = "N/A";

        if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/)
        {
            my $raw_physc_profile_value = $raw_physc_profile_value_str + 0;
            my $is_non_default_pool = (defined $cfg && defined $cfg->{pool_name} && lc($cfg->{pool_name}) ne 'defaultpool' && $cfg->{pool_name} ne '');

            my ($runq_modified_physc_for_profile, $debug_info_ref_profile) = calculate_runq_modified_physc(
                $raw_physc_profile_value,
                $norm_runq_p50_for_vm_str, $norm_runq_p90_for_vm_str, $abs_runq_p90_for_vm_str,
                $smt_used_for_vm,
                (defined $cfg ? $cfg->{entitlement} : "0"),
                $max_cpu_for_vm,
                $is_non_default_pool
            );

            my $current_profile_nfit_flags = $profile->{flags};
            my $current_profile_output_dp = get_nfit_output_dp_from_flags($rounding_flags_for_nfit . " " . $current_profile_nfit_flags);
            my $current_sprintf_format = "%." . $current_profile_output_dp . "f";

            if (defined $runq_data_file_arg)
            {
                 $adjusted_value_str = sprintf($current_sprintf_format, $runq_modified_physc_for_profile);
                 if ($debug_runq_modifier && defined $debug_info_ref_profile && !$first_profile_debug_done)
                 {
                     %current_vm_debug_info_for_csv = %{$debug_info_ref_profile};
                     $current_vm_debug_info_for_csv{'BasePhysC_Profile'} = $profile_name;
                     $first_profile_debug_done = 1;
                 }
            }
            else
            {
                 my $formatted_raw_value = $raw_physc_profile_value_str;
                 if ($rounding_flags_for_nfit eq "")
                 {
                     $formatted_raw_value = sprintf("%.4f", $raw_physc_profile_value);
                 }
                 $adjusted_value_str = $formatted_raw_value;
            }
        }
        else
        {
            $adjusted_value_str = $raw_physc_profile_value_str // "N/A";
        }
        push @data_row, $adjusted_value_str;
    }
    my $current_ent_display = (defined $cfg && defined $cfg->{entitlement}) ? $cfg->{entitlement} : "";
    if ($current_ent_display ne "" && $current_ent_display =~ /^-?[0-9.]+$/)
    {
        $current_ent_display = sprintf("%.2f", $current_ent_display);
    }
    push @data_row, $current_ent_display;
    push @data_row, "NFIT_Formula";
    push @data_row, "NETT_UserFormula";
    push @data_row, "NETT_Perc_UserFormula";

    if ($debug_runq_modifier)
    {
        push @data_row, ($current_vm_debug_info_for_csv{'BasePhysC_Profile'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'BasePhysC'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'RunQPressure_P90_Val'} // "N/A"); 
        push @data_row, ($current_vm_debug_info_for_csv{'IsRunQPressure'} // "N/A");      
        push @data_row, ($current_vm_debug_info_for_csv{'IsWorkloadPressure'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'VoltFactorReason'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'EffFactor'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'RawAdditive'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'MaxAdditiveCap'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'VoltFactor'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'PoolFactor'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'FinalAdditive'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'PreMaxCpuCapRec'} // "N/A");
        push @data_row, ($current_vm_debug_info_for_csv{'CappedByMaxCPU'} // "N/A");
    }

    print STDOUT join(",", map { quote_csv($_) } @data_row) . "\n";
}

print STDERR "CSV output generated successfully.\n";
exit 0;

# ==============================================================================
# Subroutines
# ==============================================================================

sub quote_csv
{
    my ($field) = @_;
    if (!defined $field)
    {
        $field = '';
    }
    $field =~ s/"/""/g; 
    return qq/"$field"/; 
}

sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef;
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//; 
        $line =~ s/\s*;.*//; 
        $line =~ s/^\s+|\s+$//g; 
        next if $line eq ''; 

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/) 
        {
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags})
            {
                 warn "Warning: Profile section '[$current_section_name]' in '$filepath' (line $line_number) ended without 'nfit_flags'. Skipping previous section entry.\n";
                 pop @loaded_profiles_list;
            }

            $current_section_name = $1;
            $current_section_name =~ s/^\s+|\s+$//g; 
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef;
                next;
            }
            push @loaded_profiles_list, { name => $current_section_name, flags => undef };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/) 
        {
            my $key = $1;
            my $value = $2;
            $key =~ s/^\s+|\s+$//g;
            $value =~ s/^\s+|\s+$//g;

            if (lc($key) eq 'nfit_flags')
            {
                if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
                {
                    if (defined $loaded_profiles_list[-1]{flags})
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                else
                {
                     warn "Warning: 'nfit_flags' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping flags.\n";
                }
            }
        }
        elsif ($line ne '') 
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    }
    close $fh;

    if (@loaded_profiles_list && defined $loaded_profiles_list[-1]{name} &&
        !defined $loaded_profiles_list[-1]{flags})
    {
        warn "Warning: Last profile '[" . $loaded_profiles_list[-1]{name} . "]' in '$filepath' missing 'nfit_flags'. Removing.\n";
        pop @loaded_profiles_list;
    }
    
    my @valid_profiles = grep { defined $_->{flags} && $_->{flags} ne '' } @loaded_profiles_list;
    return @valid_profiles;
}

sub calculate_runq_modified_physc
{
    my ($selected_tier_physc_value_str,
        $norm_runq_p50_str, $norm_runq_p90_str, $abs_runq_p90_str,
        $smt_used, $current_entitlement_str, $max_cpu_config_str,
        $is_in_non_default_pool) = @_;

    my %debug_info;
    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // "N/A";

    my $base_physc = ($selected_tier_physc_value_str ne "N/A" && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/) ? ($selected_tier_physc_value_str + 0) : undef;
    
    unless (defined $base_physc)
    {
        $debug_info{'ReasonForNoModification'} = "BasePhysC not numeric";
        return ($selected_tier_physc_value_str // "N/A", \%debug_info);
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne "N/A" && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne "N/A" && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_p90_numeric  = ($abs_runq_p90_str  ne "N/A" && $abs_runq_p90_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_str + 0)  : undef;
    my $curr_ent_numeric = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/) ? ($current_entitlement_str + 0) : 0;
    my $max_cpu_for_lpar_numeric = (defined $max_cpu_config_str && $max_cpu_config_str ne "" && $max_cpu_config_str =~ /^-?[0-9.]+$/ && ($max_cpu_config_str+0) > 0) ? ($max_cpu_config_str + 0) : 0;

    unless (defined $abs_p90_numeric && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) )
    {
        $debug_info{'ReasonForNoModification'} = "Missing essential RunQ metrics for modifier logic (AbsP90 and (NormP90 for WorkloadPressure or MaxCPU for RunQPressure))";
        return ($base_physc, \%debug_info); 
    }

    my $runq_pressure_p90_val = 0; 
    if (defined $abs_p90_numeric && $max_cpu_for_lpar_numeric > 0 && $smt_used > 0)
    {
        $runq_pressure_p90_val = $abs_p90_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
    }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p90_val); 

    my $is_runq_pressure = ($runq_pressure_p90_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD); 
    my $is_workload_pressure = (defined $norm_p90_numeric && $norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False"; 
    $debug_info{'IsWorkloadPressure'} = $is_workload_pressure ? "True" : "False";

    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure);

    my $efficiency_factor = 1.0;
    if (defined $norm_p50_numeric && $norm_p50_numeric < $RUNQ_EFFICIENCY_NORM_P50_THRESHOLD)
    {
        $efficiency_factor = 0.90;
    }
    my $base_adjusted_physc = $base_physc * $efficiency_factor;
    $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor);

    my $additive_cpu = 0;
    my $raw_additive_cpu = 0;
    my $max_additive_cap_sliding = 0;
    my $volatility_confidence_factor = 1.0; 
    my $pool_confidence_factor = 1.0;
    $debug_info{'VoltFactorReason'} = "Default (No pressure or P50/P90 NormRQ not usable for volatility)";

    if ($apply_additive_logic && defined $abs_p90_numeric && $smt_used > 0)
    {
        my $effective_lcpus_at_base_profile_recommendation = $base_physc * $smt_used;
        my $excess_threads = $abs_p90_numeric - $effective_lcpus_at_base_profile_recommendation;

        if ($excess_threads > 0)
        {
            $raw_additive_cpu = $excess_threads / $smt_used;

            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; }
            else { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0)
            {
                $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1;
            }

            my $capped_additive_cpu = ($raw_additive_cpu < $max_additive_cap_sliding) ? $raw_additive_cpu : $max_additive_cap_sliding;

            if ($is_runq_pressure) 
            {
                $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR; # Now 1.0
                $debug_info{'VoltFactorReason'} = "RunQPressure Saturation (Factor set to " . $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR . ")";
            }
            elsif ($is_workload_pressure && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01)
            {
                my $volatility_ratio = $norm_p50_numeric / $norm_p90_numeric;
                if ($volatility_ratio < $VOLATILITY_SPIKY_THRESHOLD)
                {
                    $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; 
                }
                elsif ($volatility_ratio < $VOLATILITY_MODERATE_THRESHOLD)
                {
                    $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; 
                }
                else 
                {
                     $volatility_confidence_factor = 1.0; 
                }
                $debug_info{'VoltFactorReason'} = "Calculated (NormRQ P50/P90 ratio for WorkloadPressure)";
            }
            # Default $volatility_confidence_factor remains 1.0 if no specific condition above changes it.

            $additive_cpu = $capped_additive_cpu * $volatility_confidence_factor;

            if ($is_in_non_default_pool && $additive_cpu > 0)
            {
                $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR;
                $additive_cpu *= $pool_confidence_factor;
            }
        }
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu);
    $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding);
    $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor);
    $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor);
    $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);

    my $calculated_demand = $base_adjusted_physc + $additive_cpu;
    my $runq_modified_rec = $calculated_demand;
    $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    if (defined $max_cpu_for_lpar_numeric && $max_cpu_for_lpar_numeric > 0 && $calculated_demand > $max_cpu_for_lpar_numeric)
    {
        $runq_modified_rec = $max_cpu_for_lpar_numeric;
        $debug_info{'CappedByMaxCPU'} = "True";
    }
    else
    {
        $debug_info{'CappedByMaxCPU'} = "False";
    }
    if ($runq_modified_rec < 0)
    {
        $runq_modified_rec = 0;
    }

    return ($runq_modified_rec, \%debug_info);
}

sub generate_sizing_hint
{
    my %args = @_; 
    # Explicitly quoting hash keys for robustness with strictures
    my $results_ref              = $args{'results_ref'};
    my $vm                       = $args{'vm'};
    my $config_ref               = $args{'config_ref'};
    my $norm_runq_p90_for_vm_str = $args{'norm_runq_p90_for_vm_str'};
    my $abs_runq_p90_for_vm_str  = $args{'abs_runq_p90_for_vm_str'};
    my $max_cpu_for_vm_numeric   = $args{'max_cpu_for_vm_numeric'};
    my $smt_used_for_vm_numeric  = $args{'smt_used_for_vm_numeric'};

    if (defined $config_ref && defined $config_ref->{systemtype} && $config_ref->{systemtype} =~ /VIO Server/i)
    {
        return ("P", "VIO Server", 0, "");
    }

    my $o3_val = $results_ref->{$vm}{'O3-95W15'} // 0;
    $o3_val = 0 unless ($o3_val =~ /^-?[0-9.]+\z/);
    my $b3_val = $results_ref->{$vm}{'B3-95W15'} // 0;
    $b3_val = 0 unless ($b3_val =~ /^-?[0-9.]+\z/);
    my $g3_val = $results_ref->{$vm}{'G3-95W15'} // 0;
    $g3_val = 0 unless ($g3_val =~ /^-?[0-9.]+\z/);
    my $p99w1_val = $results_ref->{$vm}{'P-99W1'} // 0;
    $p99w1_val = 0 unless ($p99w1_val =~ /^-?[0-9.]+\z/);

    my $suggested_pattern = "G";
    if ($b3_val > 0.01 && $o3_val > ($b3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "O";
    }
    elsif ($o3_val > 0.01 && $b3_val > ($o3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "B";
    }
    my $peakiness_ratio = 0;
    if ($g3_val > 0.01)
    {
        $peakiness_ratio = ($p99w1_val / $g3_val);
    }
    my $shape_descriptor = "Steady";
    if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Very Peaky";
    }
    elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Moderately Peaky";
    }

    my $pressure_detected_maxcpu_limit = 0;
    my $pressure_detected_runq_pressure = 0; 
    my $pressure_detected_workload_pressure = 0;
    my $pressure_detail_str = "";

    my $maxcpu_val_from_config = (defined $config_ref && defined $config_ref->{'maxcpu'} && $config_ref->{'maxcpu'} =~ /^[0-9.]+$/ && ($config_ref->{'maxcpu'}+0) > 0) ? ($config_ref->{'maxcpu'}+0) : undef;
    if (defined $maxcpu_val_from_config && $p99w1_val >= ($maxcpu_val_from_config * $LIMIT_THRESHOLD_PERC))
    {
        $pressure_detected_maxcpu_limit = 1;
    }

    my $abs_runq_p90_numeric = ($abs_runq_p90_for_vm_str ne "N/A" && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;
    my $runq_pressure_p90_calculated_value = 0; 
    if (defined $abs_runq_p90_numeric && defined $max_cpu_for_vm_numeric && $max_cpu_for_vm_numeric > 0 && defined $smt_used_for_vm_numeric && $smt_used_for_vm_numeric > 0)
    {
        $runq_pressure_p90_calculated_value = $abs_runq_p90_numeric / ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric);
    }
    if ($runq_pressure_p90_calculated_value > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD) 
    {
        $pressure_detected_runq_pressure = 1; 
    }

    my $norm_runq_p90_numeric = ($norm_runq_p90_for_vm_str ne "N/A" && $norm_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_for_vm_str + 0) : undef;
    if (defined $norm_runq_p90_numeric && $norm_runq_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
    {
        $pressure_detected_workload_pressure = 1;
    }

    my $overall_pressure_detected = $pressure_detected_maxcpu_limit || $pressure_detected_runq_pressure || $pressure_detected_workload_pressure; 
    if ($overall_pressure_detected)
    {
        my @pressure_points;
        if ($pressure_detected_maxcpu_limit)
        {
            push @pressure_points, "MaxCPU";
        }
        if ($pressure_detected_runq_pressure) 
        {
            push @pressure_points, "RunQPressure(P90=" . sprintf("%.2f", $runq_pressure_p90_calculated_value) . ")"; 
        }
        if ($pressure_detected_workload_pressure)
        {
            push @pressure_points, "Workload(NormP90=" . sprintf("%.2f", $norm_runq_p90_numeric) . ")";
        }

        if (defined $config_ref && defined $config_ref->{'pool_name'} && lc($config_ref->{'pool_name'}) ne 'defaultpool' && $config_ref->{'pool_name'} ne '')
        {
            push @pressure_points, "Pool(" . $config_ref->{'pool_name'} . ")?";
        }
        $pressure_detail_str = join(", ", @pressure_points);
    }

    my $initial_tier_range_str = "3/4";
    if ($shape_descriptor eq "Very Peaky")
    {
        $initial_tier_range_str = "1/2";
    }
    elsif ($shape_descriptor eq "Moderately Peaky")
    {
        $initial_tier_range_str = "2/3";
    }
    my $adjusted_tier_str = $initial_tier_range_str;
    if ($overall_pressure_detected) 
    {
        if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; }
        elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; }
        elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; }
    }
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str;

    return ($pattern_tier_string, $shape_descriptor, $overall_pressure_detected, $pressure_detail_str);
}

sub parse_percentile_list_for_header
{
    my ($perc_str, $clean_zeros) = @_;
    $clean_zeros = 1 if !defined $clean_zeros;
    my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100)
            {
                 my $p_label = $p;
                 if ($clean_zeros)
                 {
                     $p_label = sprintf("%.2f", $p);
                     $p_label =~ s/\.?0+$//;
                     $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00"); 
                 }
                 push @percentiles_cleaned, $p_label;
            }
            else
            {
                die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return \@percentiles_cleaned;
}

sub ensure_percentiles_requested
{
    my ($perc_list_str, @required_percs) = @_;
    return 1 unless defined $perc_list_str && $perc_list_str ne '';
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0);
    my %present_map = map { $_ => 1 } @{$parsed_percs_ref};
    foreach my $req_p (@required_percs)
    {
        unless (exists $present_map{$req_p})
        {
            return 0;
        }
    }
    return 1;
}

sub get_nfit_output_dp_from_flags
{
    my ($nfit_flags_str_for_this_run) = @_;
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/)
    {
        my $increment_val = $1 // $2;
        if (!(defined $increment_val && $increment_val ne ""))
        {
            $increment_val = $DEFAULT_ROUND_INCREMENT; 
        }
        return get_decimal_places($increment_val);
    }
    return 4; 
}

sub get_decimal_places
{
    my ($number) = @_;
    $number = sprintf("%.15f", $number) if ($number =~ /e/i);
    if ($number =~ /\.(\d+)$/)
    {
        return length($1);
    }
    else
    {
        return 0;
    }
}

sub usage_wrapper
{
    my $script_name = $0;
    $script_name =~ s{.*/}{};
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [--runq-data <rq_file>] [--default-smt <N>]
                  [--runq-norm-percentiles <list>] [--runq-abs-percentiles <list>]
                  [-config <vm_cfg>] [--profiles-config <prof_cfg>]
                  [-s <date>] [-vm <name>] [-r[=inc]|-u[=inc]] [--nfit-path <path>]
                  [--debug-runq] [-h|v]

Runs 'nfit' for multiple profiles. Applies a unified RunQ-based modifier to each
profile's PhysC result, considering LPAR saturation (RunQPressure_P90) and/or
momentary workload pressure (NormRunQ_P90), with differentiated impact.
Aggregates final adjusted results and hints into CSV.

Core Input:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
  --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --default-smt, --smt <N> : Optional. Default SMT level if not in VM config
                               (Default: $DEFAULT_SMT_VALUE_PROFILE). Used by nfit & RunQPressure_P90 calc.

RunQ Metric Configuration (for nfit, and used by this script's modifier logic):
  --runq-norm-percentiles <list> : Comma-separated percentiles for Normalised RunQ (momentary PhysC based)
                                   (Default: "$DEFAULT_RUNQ_NORM_PERCS").
                                   P50 and P90 are required for full modifier logic.
  --runq-abs-percentiles <list>  : Comma-separated percentiles for Absolute RunQ
                                   (Default: "$DEFAULT_RUNQ_ABS_PERCS").
                                   P90 is required for full modifier logic.
Configuration Files:
  -config <vm_cfg_csv>       : Optional. Path to VM configuration CSV file.
                               Required for accurate RunQPressure_P90 calculation (needs 'maxcpu').
  --profiles-config <path>   : Optional. Path to profiles definition file (INI format).

Filtering (Passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Ignore NMON data before this date.
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name.

Rounding (Passed to nfit for its output, which becomes input to modifier):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Defaults to increment $DEFAULT_ROUND_INCREMENT if not specified)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  --debug-runq               : Optional. Output intermediate RunQ modifier calculation columns.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  NormRunQ_P50,NormRunQ_P90,AbsRunQ_P90,RunQPressure_P90_Value,
  [Debug RunQ Cols if --debug-runq], Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are RunQ-modified)...], Current_ENT,NFIT_ENT_UserFormula,
  NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
