#!/usr/bin/env perl

# NAME     : nfit-profile
# VERSION  : 2.34.147.0 # Added --nfit-runq-avg-method to pass to nfit
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' (which can now do internal windowed decay and RunQ smoothing)
#            multiple times with user-defined profiles.
#            Applies RunQ modifiers (behavior controllable per profile),
#            generates hints, and aggregates to CSV.
# REQUIRES : Perl, nfit script (v2.28.0+ with internal windowed decay & runq-avg-method),
#            Time::Piece, List::Util, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);
use Time::Piece;
use List::Util qw(sum min max);
use version;

# --- Version ---
my $SCRIPT_VERSION = '2.34.147.0';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90";
my $DEFAULT_RUNQ_ABS_PERCS  = "90";
my $DEFAULT_NFIT_RUNQ_AVG_METHOD = "ema"; # Default to ema for RunQ smoothing in nfit

# Windowed Decay Defaults (passed to nfit if enabled)
my $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT = 30;

# Heuristic Thresholds (remain in nfit-profile)
my $PATTERN_RATIO_THRESHOLD = 2.0;
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;
my $LIMIT_THRESHOLD_PERC = 0.98;

# RunQ Modifier Thresholds (remain in nfit-profile)
my $RUNQ_EFFICIENCY_NORM_P50_THRESHOLD = 0.5;
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 1.2;
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 0.75;

# Max_Additive_CPU Sliding Scale Thresholds (remain in nfit-profile)
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;
my $MAX_ADD_PERC_VAL_ELSE = 0.5;

# RunQ Volatility Confidence Factor Thresholds & Values (remain in nfit-profile)
my $VOLATILITY_SPIKY_THRESHOLD = 0.5; my $VOLATILITY_SPIKY_FACTOR = 0.70;
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85;
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0;

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80;

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak";

# --- Argument Parsing ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;
my $roundup_arg;
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS;
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;
my $debug_runq_modifier = 0;
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit";
my $nfit_enable_windowed_decay = 0;
my $nfit_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT;
my $nfit_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT;
my $nfit_decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT;
my $nfit_analysis_reference_date_str;
my $nfit_runq_avg_method_str = $DEFAULT_NFIT_RUNQ_AVG_METHOD; # New option

GetOptions(
    'physc-data|pc=s'         => \$physc_data_file,
    'runq-data|rq=s'          => \$runq_data_file_arg,
    'config=s'                => \$vm_config_file_arg,
    'profiles-config=s'       => \$profiles_config_file_arg,
    'startdate|s=s'           => \$start_date_str,
    'vm|lpar=s'               => \$target_vm_name,
    'round|r:f'               => \$round_arg,
    'roundup|u:f'             => \$roundup_arg,
    'default-smt|smt=i'       => \$default_smt_arg,
    'runq-norm-percentiles=s' => \$runq_norm_perc_list_str,
    'runq-abs-percentiles=s'  => \$runq_abs_perc_list_str,
    'debug-runq'              => \$debug_runq_modifier,
    'help|h'                  => \$help,
    'nfit-path=s'             => \$nfit_script_path,
    'version|v'               => \$show_version,
    'nfit-enable-windowed-decay'     => \$nfit_enable_windowed_decay,
    'nfit-process-window-unit=s'     => \$nfit_window_unit_str,
    'nfit-process-window-size=i'     => \$nfit_window_size_val,
    'nfit-decay-half-life-days=i'    => \$nfit_decay_half_life_days_val,
    'nfit-analysis-reference-date=s' => \$nfit_analysis_reference_date_str,
    'nfit-runq-avg-method=s'         => \$nfit_runq_avg_method_str, # New CLI option
) or die usage_wrapper();

# --- Validation ---
if ($show_version)
{
    print STDERR "nfit-profile version $SCRIPT_VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver_output = `$nfit_script_path -v 2>&1`;
        my ($nfit_ver) = ($nfit_ver_output =~ /nfit version\s*([0-9.]+)/i);
        if (defined $nfit_ver)
        {
            print STDERR "Uses nfit version: $nfit_ver\n";
            my $required_nfit_ver_for_windowing = "2.27.0"; # nfit version with internal windowed decay
            my $required_nfit_ver_for_runq_avg = "2.28.0"; # Hypothetical nfit version with runq-avg-method
            
            if ($nfit_enable_windowed_decay && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_windowing))
            {
                print STDERR "Warning: --nfit-enable-windowed-decay requires nfit version $required_nfit_ver_for_windowing or higher. Your nfit version ($nfit_ver) may not support this.\n";
            }
            if (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none' && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_runq_avg))
            {
                 print STDERR "Warning: --nfit-runq-avg-method (sma/ema) requires nfit version $required_nfit_ver_for_runq_avg or higher. Your nfit version ($nfit_ver) may not support this specific RunQ processing.\n";
            }
        }
        else
        {
            print STDERR "Could not determine nfit version from output: $nfit_ver_output\n";
            if ($nfit_enable_windowed_decay || (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none'))
            {
                print STDERR "Warning: Advanced nfit features are enabled but nfit version cannot be verified.\n";
            }
        }
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}
# ... (Other validations from your provided script)
if ($help || !$physc_data_file) { print STDERR usage_wrapper(); exit 0; }
if (! -f $physc_data_file) { die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n"; }
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg) { die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n"; }
if ($default_smt_arg <= 0) { die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n"; }
if (! -x $nfit_script_path) { die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n"; }
if (defined($round_arg) && defined($roundup_arg)) { die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n"; }
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n"; }

if ($nfit_enable_windowed_decay) {
    if ($nfit_window_unit_str ne "days" && $nfit_window_unit_str ne "weeks") { die "Error: --nfit-process-window-unit must be 'days' or 'weeks'.\n"; }
    if ($nfit_window_size_val < 1) { die "Error: --nfit-process-window-size must be at least 1.\n"; }
    if ($nfit_decay_half_life_days_val < 1) { die "Error: --nfit-decay-half-life-days must be at least 1.\n"; }
    if (defined $nfit_analysis_reference_date_str && $nfit_analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/) { die "Error: Invalid --nfit-analysis-reference-date format. Use YYYY-MM-DD.\n"; }
    print STDERR "nfit's internal windowed decay processing is enabled via nfit-profile.\n";
}

if (defined $nfit_runq_avg_method_str) {
    $nfit_runq_avg_method_str = lc($nfit_runq_avg_method_str);
    unless ($nfit_runq_avg_method_str eq 'none' || $nfit_runq_avg_method_str eq 'sma' || $nfit_runq_avg_method_str eq 'ema') {
        die "Error: --nfit-runq-avg-method must be 'none', 'sma', or 'ema'. Got '$nfit_runq_avg_method_str'.\n";
    }
    print STDERR "Instructing nfit to use RunQ averaging method: $nfit_runq_avg_method_str.\n";
}


# --- Load Profile Definitions ---
# (Code from your uploaded nfit-profile.20250528T17h57.pl)
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE";
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
@profiles = load_profile_definitions($profiles_config_path_to_load); # Updated to load new attribute
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}
print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";

# --- Locate and Load VM Configuration Data ---
# (Code from your uploaded nfit-profile.20250528T17h57.pl)
my $vm_config_file_path = undef; my $vm_config_found = 0; my %vm_config_data; my %vm_config_col_idx; my $vm_config_header_count = 0;
if (defined $vm_config_file_arg) {
    if (-f $vm_config_file_arg) { $vm_config_file_path = $vm_config_file_arg; $vm_config_found = 1; print STDERR "Using specified VM configuration file: $vm_config_file_path\n"; }
    else { die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n"; }
} else {
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE"; my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE";
    if (-f $dp_etc) {$vm_config_file_path = $dp_etc; $vm_config_found = 1; print STDERR "Found default VM configuration file: $vm_config_file_path\n";}
    elsif (-f $dp_root) {$vm_config_file_path = $dp_root; $vm_config_found = 1; print STDERR "Found default VM configuration file: $vm_config_file_path\n";}
    else { print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n"; }
}
if ($vm_config_found) {
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>; unless (defined $hdr) { die "Error: Could not read header from VM config '$vm_config_file_path'\n"; }
    chomp $hdr; $hdr =~ s/\r$//; $hdr =~ s/^\x{FEFF}//; my @rhdrs = split /,/, $hdr; $vm_config_header_count = scalar @rhdrs; my %hmap;
    for my $i (0 .. $#rhdrs) { my $cn = $rhdrs[$i]; $cn =~ s/^\s*"?|"?\s*$//g; if ($cn ne '') { $hmap{lc($cn)} = $i; } }
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'}; unless (exists $hmap{'maxcpu'}) { warn "Warning: 'maxcpu' column not found in VM config. RunQPressure_P90 calculation will be N/A.\n"; }
    if ($has_smt_col) { print STDERR "Found 'SMT' column in VM configuration file.\n"; } else { print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n"; }
    foreach my $rc (@req_cols) { unless (exists $hmap{$rc}) { die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n"; } $vm_config_col_idx{$rc} = $hmap{$rc}; }
    if ($has_smt_col) { $vm_config_col_idx{'smt'} = $hmap{'smt'}; }
    while (my $ln = <$cfg_fh>) {
        chomp $ln; $ln =~ s/\r$//; next if $ln =~ /^\s*$/; my @rvals = ($ln =~ /"([^"]*)"/g);
        if (scalar @rvals != $vm_config_header_count) {
            @rvals = split /,/, $ln;
            if (scalar @rvals != $vm_config_header_count) { warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n"; next; }
             $_ =~ s/^\s+|\s+$//g for @rvals;
        }
        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ];
        if (defined $hn && $hn ne '') {
            my $smt_v = $default_smt_arg;
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '') {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/) { $smt_v = $1; if ($smt_v <= 0) { warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n"; $smt_v = $default_smt_arg;}}
                else { warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";}
            }
            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0) { $max_cpu_val = 0; }
            $vm_config_data{$hn} = {
                serial => $rvals[$vm_config_col_idx{'serial'}], systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name => $rvals[$vm_config_col_idx{'procpool_name'}], pool_id => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}], maxcpu => ($max_cpu_val + 0), smt => $smt_v,
            };
        } else { warn "Warning: Missing hostname on VM config line $. Skipping.\n"; }
    }
    close $cfg_fh; print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
} else {
     print STDERR "Warning: VM configuration file not loaded. RunQPressure_P90 calculation will be N/A and SMT will use default.\n";
}


# --- Construct Common Flags for nfit ---
my $common_nfit_flags_base = "-k --physc-data \"$physc_data_file\"";
if (defined $runq_data_file_arg)
{
    $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
    $common_nfit_flags_base .= " --runq-norm-perc \"$runq_norm_perc_list_str\"";
    $common_nfit_flags_base .= " --runq-abs-perc \"$runq_abs_perc_list_str\"";
    # Add the new RunQ averaging method flag for nfit
    if (defined $nfit_runq_avg_method_str) {
        $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
        # Note: nfit will use its global --decay and -w for RunQ EMA/SMA if this is set to ema/sma
    }
}
if (defined $start_date_str) 
{
    $common_nfit_flags_base .= " -s $start_date_str";
}

my $rounding_flags_for_nfit = "";
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit;

my $nfit_windowing_decay_flags = ""; # Renamed from $nfit_windowing_decay_flags_str for clarity
if ($nfit_enable_windowed_decay)
{
    $nfit_windowing_decay_flags .= " --enable-windowed-decay";
    $nfit_windowing_decay_flags .= " --process-window-unit \"$nfit_window_unit_str\"";
    $nfit_windowing_decay_flags .= " --process-window-size $nfit_window_size_val";
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
$common_nfit_flags_base .= $nfit_windowing_decay_flags;


# --- Main Logic: Run nfit Profiles ---
# (Code from your uploaded nfit-profile.20250528T17h57.pl - main loop structure)
my %results_table;
my @vm_order;
my %vm_seen;
print STDERR "nfit-profile version $SCRIPT_VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles)
{
    my $profile_name = $profile->{name};
    my $profile_specific_flags = $profile->{flags}; 
    my $profile_runq_behavior = $profile->{runq_behavior} // 'default'; 

    print STDERR "Running profile: $profile_name ($profile_specific_flags";
    print STDERR " ; RunQBehavior: $profile_runq_behavior" if $profile_runq_behavior ne 'default';
    print STDERR ")...\n";
    
    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg"; 
    my $nfit_vm_flag_for_current_run = "";

    if (defined $target_vm_name)
    {
        $nfit_vm_flag_for_current_run = " -vm \"$target_vm_name\"";
        if ($vm_config_found && exists $vm_config_data{$target_vm_name} && defined $vm_config_data{$target_vm_name}{'smt'})
        {
            # For a single target VM, nfit gets SMT from --smt if passed directly for it
            # $nfit_smt_flag_for_current_run will already contain this.
            # No, nfit will use the LAST --smt. So if target VM, pass its SMT specifically.
            $nfit_smt_flag_for_current_run = "--smt " . $vm_config_data{$target_vm_name}{'smt'};
        }
    }
    # If processing all VMs, nfit handles SMT per VM, or uses the --smt default $default_smt_arg
    # The $nfit_vm_flag_for_current_run ensures -vm is only added if $target_vm_name is specified.
    # So the $nfit_smt_flag_for_current_run should just be the default unless a target VM overrides it.
    
    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags";
    my $output = `$command`;
    my $exit_status = $? >> 8;

    if ($exit_status != 0)
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Command was: $command. Output: $output. Skip.\n";
        next;
    }

    my @output_lines = split /\n/, $output;
    foreach my $line (@output_lines)
    {
        chomp $line;

        if ($line =~ /^(.+?):\s*(.*)$/) 
        {
            my $vm_name_from_nfit = $1;
            my $metrics_str = $2;

            unless ($vm_seen{$vm_name_from_nfit}++) 
            { 
                push @vm_order, $vm_name_from_nfit; 
            }

            my ($profile_p_flag_val_num) = ($profile_specific_flags =~ /-p\s+([0-9.]+)/);
            if (defined $profile_p_flag_val_num) {
                my $expected_metric_key_base = sprintf("%.2f", $profile_p_flag_val_num);
                $expected_metric_key_base =~ s/\.?0+$//;
                $expected_metric_key_base = "0" if $expected_metric_key_base eq "" && abs($profile_p_flag_val_num - 0) < 0.001;
                my $expected_metric_key = "P$expected_metric_key_base";
                
                if ($metrics_str =~ /\Q$expected_metric_key\E=([0-9.NA\/ -]+?)(?:\s+|$)/)
                {
                    my $p_value_val = $1; 
                    $p_value_val =~ s/^\s+|\s+$//g;
                    $results_table{$vm_name_from_nfit}{$profile_name} = $p_value_val;
                } else {
                    # warn "Warning: Could not parse expected PXX value '$expected_metric_key' for profile '$profile_name' from nfit output for VM '$vm_name_from_nfit': $metrics_str\n";
                }
            } else {
                 warn "Warning: Profile '$profile_name' does not specify a primary -p percentile in its flags: '$profile_specific_flags'. Cannot reliably extract its main value.\n";
            }

            if ($metrics_str =~ /Peak=([0-9.NA\/ -]+?)(?:\s+|$)/) 
            {
                my $peak_value = $1; 
                $peak_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name_from_nfit}{$PEAK_PROFILE_NAME} = $peak_value;
            }

            while ($metrics_str =~ /(NormRunQ_P\d+\.?\d*|AbsRunQ_P\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/g) 
            {
                my ($rq_metric_name, $rq_value) = ($1, $2);
                $rq_value =~ s/^\s+|\s+$//g;

                $results_table{$vm_name_from_nfit}{$rq_metric_name} = $rq_value;
            }
        }
        elsif ($line ne '') 
        {
            warn "Warning: Could not parse VM name from nfit output line for profile '$profile_name': $line\n";
        }
    }
}
print STDERR "Finished nfit profile runs. Generating CSV output...\n";

# --- Generate CSV Output ---
# (This section remains identical to your provided v2.33 - the debug info populating fix is there)
my @output_header_cols_csv;
@output_header_cols_csv = ( "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT", "NormRunQ_P50", "NormRunQ_P90", "AbsRunQ_P90", "RunQPressure_P90_Value", "Serial", "SystemType", "Pool Name", "Pool ID", $PEAK_PROFILE_NAME );
push @output_header_cols_csv, map { $_->{name} } @profiles; 
push @output_header_cols_csv, ("Current_ENT", "NFIT_ENT_UserFormula", "NETT_UserFormula", "NETT_Perc_UserFormula");
my @debug_column_keys_list_csv; 
if ($debug_runq_modifier) {
    @debug_column_keys_list_csv = ( "RunQ_BasePhysC_Profile", "RunQ_BasePhysC_Value", "RunQ_RunQPressure_P90_Val", "RunQ_IsRunQPressure", "RunQ_IsWorkloadPressure", "RunQ_VoltFactorReason", "RunQ_EffFactorReason", "RunQ_EffFactor", "RunQ_RawAdditive", "RunQ_MaxAdditiveCap", "RunQ_VoltFactor", "RunQ_PoolFactor", "RunQ_FinalAdditive", "RunQ_PreMaxCpuCapRec", "RunQ_CappedByMaxCPU" );
    push @output_header_cols_csv, @debug_column_keys_list_csv;
}
print STDOUT join(",", map { quote_csv($_) } @output_header_cols_csv) . "\n";

foreach my $vm_name (@vm_order) {
    my @data_row_csv; 
    my $cfg_csv = $vm_config_data{$vm_name}; 
    my $smt_used_for_vm_csv = (defined $cfg_csv && defined $cfg_csv->{smt}) ? $cfg_csv->{smt} : $default_smt_arg;
    my $max_cpu_for_vm_csv  = (defined $cfg_csv && defined $cfg_csv->{maxcpu} && $cfg_csv->{maxcpu} > 0) ? $cfg_csv->{maxcpu} : 0; 
    my $norm_runq_p50_for_vm_str_csv = $results_table{$vm_name}{'NormRunQ_P50'} // "N/A";
    my $norm_runq_p90_for_vm_str_csv = $results_table{$vm_name}{'NormRunQ_P90'} // "N/A";
    my $abs_runq_p90_for_vm_str_csv  = $results_table{$vm_name}{'AbsRunQ_P90'}  // "N/A";
    my $runq_pressure_p90_value_for_csv_out = "N/A"; 
    my $abs_runq_p90_numeric_for_calc_csv = ($abs_runq_p90_for_vm_str_csv ne "N/A" && $abs_runq_p90_for_vm_str_csv =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str_csv + 0) : undef;
    if (defined $abs_runq_p90_numeric_for_calc_csv && $max_cpu_for_vm_csv > 0 && $smt_used_for_vm_csv > 0) {
        $runq_pressure_p90_value_for_csv_out = sprintf("%.4f", $abs_runq_p90_numeric_for_calc_csv / ($max_cpu_for_vm_csv * $smt_used_for_vm_csv));
    }
    my ($hint_type_tier_csv, $hint_pattern_shape_csv, $hint_pressure_bool_csv, $pressure_detail_str_csv) =
        generate_sizing_hint(
            'results_ref'              => \%results_table, 'vm' => $vm_name, 'config_ref' => $cfg_csv,
            'norm_runq_p90_for_vm_str' => $norm_runq_p90_for_vm_str_csv, 'abs_runq_p90_for_vm_str'  => $abs_runq_p90_for_vm_str_csv,
            'max_cpu_for_vm_numeric'   => $max_cpu_for_vm_csv, 'smt_used_for_vm_numeric'  => $smt_used_for_vm_csv
        );
    my $pressure_bool_str_csv = $hint_pressure_bool_csv ? "True" : "False";
    push @data_row_csv, $vm_name, "", $hint_type_tier_csv, $hint_pattern_shape_csv, $pressure_bool_str_csv, $pressure_detail_str_csv, $smt_used_for_vm_csv;
    push @data_row_csv, $norm_runq_p50_for_vm_str_csv, $norm_runq_p90_for_vm_str_csv, $abs_runq_p90_for_vm_str_csv, $runq_pressure_p90_value_for_csv_out;
    my %captured_debug_info_for_vm_csv; 
    push @data_row_csv, (defined $cfg_csv ? $cfg_csv->{serial} : ""), (defined $cfg_csv ? $cfg_csv->{systemtype} : ""), (defined $cfg_csv ? $cfg_csv->{pool_name} : ""), (defined $cfg_csv ? $cfg_csv->{pool_id} : "");
    push @data_row_csv, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // ""); 
    my $debug_info_captured_flag_csv = 0; 
    foreach my $profile (@profiles) {
        my $profile_name = $profile->{name}; my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name}; my $adjusted_value_str = "N/A";
        my $current_profile_runq_behavior = $profile->{runq_behavior} // 'default'; # Get profile specific behavior

        if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/) {
            my $raw_physc_profile_value = $raw_physc_profile_value_str + 0;
            my $is_non_default_pool = (defined $cfg_csv && defined $cfg_csv->{pool_name} && lc($cfg_csv->{pool_name}) ne 'defaultpool' && $cfg_csv->{pool_name} ne '');
            my ($runq_modified_physc_for_profile, $debug_info_ref_profile) = calculate_runq_modified_physc(
                $raw_physc_profile_value, $norm_runq_p50_for_vm_str_csv, $norm_runq_p90_for_vm_str_csv, $abs_runq_p90_for_vm_str_csv,
                $smt_used_for_vm_csv, (defined $cfg_csv ? $cfg_csv->{entitlement} : "0"), $max_cpu_for_vm_csv, $is_non_default_pool,
                $current_profile_runq_behavior # Pass new parameter
            );
            my $current_profile_nfit_flags = $profile->{flags};
            my $current_profile_output_dp = get_nfit_output_dp_from_flags($rounding_flags_for_nfit . " " . $current_profile_nfit_flags);
            my $current_sprintf_format = "%." . $current_profile_output_dp . "f";
            $adjusted_value_str = sprintf($current_sprintf_format, $runq_modified_physc_for_profile);
            
            if ($debug_runq_modifier && defined $debug_info_ref_profile && !$debug_info_captured_flag_csv) {
                if (defined $debug_info_ref_profile->{'BasePhysC'} && 
                    $debug_info_ref_profile->{'BasePhysC'} ne "N/A" && 
                    (!exists $debug_info_ref_profile->{'ReasonForNoModification'} || 
                     $debug_info_ref_profile->{'ReasonForNoModification'} ne 'BasePhysC not numeric')
                   ) 
                {
                    %captured_debug_info_for_vm_csv = %{$debug_info_ref_profile}; 
                    $captured_debug_info_for_vm_csv{'BasePhysC_Profile'} = $profile_name; 
                    $debug_info_captured_flag_csv = 1; 
                }
            }
        } else { $adjusted_value_str = $raw_physc_profile_value_str // "N/A"; }
        push @data_row_csv, $adjusted_value_str;
    }
    my $current_ent_display_csv_out = (defined $cfg_csv && defined $cfg_csv->{entitlement}) ? $cfg_csv->{entitlement} : ""; 
    if ($current_ent_display_csv_out ne "" && $current_ent_display_csv_out =~ /^-?[0-9.]+$/) { $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out); }
    push @data_row_csv, $current_ent_display_csv_out, "NFIT_Formula", "NETT_UserFormula", "NETT_Perc_UserFormula";
    if ($debug_runq_modifier) {
        foreach my $csv_col_key (@debug_column_keys_list_csv) { 
            my $val_to_push = "N/A"; 
            my $hash_key = $csv_col_key;
            if ($csv_col_key eq "RunQ_BasePhysC_Profile") { $hash_key = 'BasePhysC_Profile'; } 
            elsif ($csv_col_key eq "RunQ_BasePhysC_Value") { $hash_key = 'BasePhysC'; } 
            elsif ($csv_col_key eq "RunQ_RunQPressure_P90_Val") { $val_to_push = $runq_pressure_p90_value_for_csv_out; push @data_row_csv, $val_to_push; next; } 
            else { $hash_key =~ s/^RunQ_//; }
            if (exists $captured_debug_info_for_vm_csv{$hash_key}) { $val_to_push = $captured_debug_info_for_vm_csv{$hash_key}; }
            push @data_row_csv, $val_to_push;
        }
    }
    print STDOUT join(",", map { quote_csv($_) } @data_row_csv) . "\n";
}

print STDERR "CSV output generated successfully.\n";
if ($nfit_enable_windowed_decay) { 
    print STDERR "Note: nfit was instructed to use internal windowed decay processing.\n";
}
exit 0;

# ==============================================================================
# Subroutines 
# ==============================================================================
sub quote_csv { my ($field) = @_; if (!defined $field) { $field = ''; } $field =~ s/"/""/g; return qq/"$field"/; }

sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef;
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//; 
        $line =~ s/\s*;.*//; 
        $line =~ s/^\s+|\s+$//g; 
        next if $line eq ''; 

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/) 
        {
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags} && 
                !defined $loaded_profiles_list[-1]{runq_behavior} ) 
            {
                 my $is_incomplete = 1;
                 if (defined $loaded_profiles_list[-1]{flags}) { $is_incomplete = 0; } 
                 if ($is_incomplete) {
                    warn "Warning: Profile section '[$current_section_name]' in '$filepath' (line $line_number) seems incomplete. Skipping previous section entry if only name was present.\n";
                    pop @loaded_profiles_list;
                 }
            }

            $current_section_name = $1;
            $current_section_name =~ s/^\s+|\s+$//g; 
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef;
                next;
            }
            # Initialize with name and default runq_behavior
            push @loaded_profiles_list, { name => $current_section_name, flags => undef, runq_behavior => 'default' };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/) 
        {
            my $key = lc($1); 
            my $value = $2;
            $key =~ s/^\s+|\s+$//g;
            $value =~ s/^\s+|\s+$//g;

            if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
            {
                if ($key eq 'nfit_flags')
                {
                    if (defined $loaded_profiles_list[-1]{flags})
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                elsif ($key eq 'runq_modifier_behavior') # New attribute
                {
                     if (defined $loaded_profiles_list[-1]{runq_behavior} && $loaded_profiles_list[-1]{runq_behavior} ne 'default')
                    {
                        warn "Warning: Duplicate 'runq_modifier_behavior' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    # Validate the value for runq_modifier_behavior
                    if ($value eq 'additive_only' || $value eq 'default') {
                        $loaded_profiles_list[-1]{runq_behavior} = $value;
                    } else {
                        warn "Warning: Invalid value '$value' for 'runq_modifier_behavior' in profile '[$current_section_name]' (line $line_number). Using default. Allowed: additive_only, default.\n";
                        $loaded_profiles_list[-1]{runq_behavior} = 'default'; # Fallback to default
                    }
                }
                # Add other potential profile-specific keys here
            }
            else
            {
                 warn "Warning: Key-value pair '$key=$value' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping.\n";
            }
        }
        elsif ($line ne '') 
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    }
    close $fh;

    my @valid_profiles;
    foreach my $p_ref (@loaded_profiles_list) {
        if (defined $p_ref->{flags} && $p_ref->{flags} ne '') {
            # Ensure runq_behavior is set if it was never explicitly defined (should be 'default' from init)
            $p_ref->{runq_behavior} //= 'default'; 
            push @valid_profiles, $p_ref;
        } else {
            warn "Warning: Profile '[" . $p_ref->{name} . "]' in '$filepath' missing mandatory 'nfit_flags'. Removing.\n";
        }
    }
    return @valid_profiles;
}


sub calculate_runq_modified_physc { 
    my ($selected_tier_physc_value_str, $norm_runq_p50_str, $norm_runq_p90_str, $abs_runq_p90_str, 
        $smt_used, $current_entitlement_str, $max_cpu_config_str, $is_in_non_default_pool,
        $profile_runq_behavior_setting # New parameter
    ) = @_;

    my %debug_info; 
    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // "N/A";
    $profile_runq_behavior_setting //= 'default'; # Ensure it has a default

    my $base_physc = ($selected_tier_physc_value_str ne "N/A" && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/) ? ($selected_tier_physc_value_str + 0) : undef;
    unless (defined $base_physc) { 
        $debug_info{'ReasonForNoModification'} = "BasePhysC not numeric"; 
        $debug_info{'RunQPressure_P90_Val'} = "N/A"; $debug_info{'IsRunQPressure'} = "N/A"; $debug_info{'IsWorkloadPressure'} = "N/A";
        $debug_info{'EffFactorReason'} = "BasePhysC N/A"; $debug_info{'EffFactor'} = "N/A";
        $debug_info{'VoltFactorReason'} = "BasePhysC N/A"; $debug_info{'VoltFactor'} = "N/A";
        $debug_info{'RawAdditive'} = "N/A"; $debug_info{'MaxAdditiveCap'} = "N/A"; 
        $debug_info{'PoolFactor'} = "N/A"; $debug_info{'FinalAdditive'} = "N/A";
        $debug_info{'PreMaxCpuCapRec'} = "N/A"; $debug_info{'CappedByMaxCPU'} = "N/A";
        return ($selected_tier_physc_value_str // "N/A", \%debug_info); 
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne "N/A" && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne "N/A" && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_p90_numeric  = ($abs_runq_p90_str  ne "N/A" && $abs_runq_p90_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_str + 0)  : undef;
    my $curr_ent_numeric = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/) ? ($current_entitlement_str + 0) : 0;
    my $max_cpu_for_lpar_numeric = (defined $max_cpu_config_str && $max_cpu_config_str ne "" && $max_cpu_config_str =~ /^-?[0-9.]+$/ && ($max_cpu_config_str+0) > 0) ? ($max_cpu_config_str + 0) : 0;
    
    unless (defined $abs_p90_numeric && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) ) { 
        $debug_info{'ReasonForNoModification'} = "Missing essential RunQ metrics for modifier logic (AbsP90 and (NormP90 for WorkloadPressure or MaxCPU for RunQPressure))"; 
        $debug_info{'RunQPressure_P90_Val'} = "N/A"; $debug_info{'IsRunQPressure'} = "N/A"; $debug_info{'IsWorkloadPressure'} = "N/A";
        $debug_info{'EffFactorReason'} = "Missing RunQ"; $debug_info{'EffFactor'} = "1.00"; # Default EffFactor if no mod
        $debug_info{'VoltFactorReason'} = "Missing RunQ"; $debug_info{'VoltFactor'} = "1.00"; # Default VoltFactor
        $debug_info{'RawAdditive'} = "0.0000"; $debug_info{'MaxAdditiveCap'} = "0.0000"; 
        $debug_info{'PoolFactor'} = "1.00"; $debug_info{'FinalAdditive'} = "0.0000";
        $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $base_physc); # If no mod, pre-cap is base * default EffFactor (1.0)
        $debug_info{'CappedByMaxCPU'} = "False"; # Or N/A if MaxCPU also N/A
        return ($base_physc, \%debug_info); 
    }

    my $runq_pressure_p90_val = 0; 
    if (defined $abs_p90_numeric && $max_cpu_for_lpar_numeric > 0 && $smt_used > 0) { $runq_pressure_p90_val = $abs_p90_numeric / ($max_cpu_for_lpar_numeric * $smt_used); }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p90_val); 
    my $is_runq_pressure = ($runq_pressure_p90_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD); 
    my $is_workload_pressure = (defined $norm_p90_numeric && $norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False"; $debug_info{'IsWorkloadPressure'} = $is_workload_pressure ? "True" : "False";
    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure);

    my $efficiency_factor = 1.0; 
    if ($profile_runq_behavior_setting eq 'additive_only') {
        $debug_info{'EffFactorReason'} = "Profile additive_only";
    } 
    elsif (defined $norm_p50_numeric && $norm_p50_numeric < $RUNQ_EFFICIENCY_NORM_P50_THRESHOLD) { 
        $efficiency_factor = 0.90; 
        $debug_info{'EffFactorReason'} = "NormRunQ P50 < threshold";
    } 
    else {
        $debug_info{'EffFactorReason'} = defined($norm_p50_numeric) ? "NormRunQ P50 >= threshold" : "NormRunQ P50 N/A";
    }
    my $base_adjusted_physc = $base_physc * $efficiency_factor; $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor);
    
    my $additive_cpu = 0; my $raw_additive_cpu = 0; my $max_additive_cap_sliding = 0; my $volatility_confidence_factor = 1.0; my $pool_confidence_factor = 1.0;
    $debug_info{'VoltFactorReason'} = "Default"; 

    if ($apply_additive_logic && defined $abs_p90_numeric && $smt_used > 0) {
        my $effective_lcpus_at_base_profile_recommendation = $base_physc * $smt_used; my $excess_threads = $abs_p90_numeric - $effective_lcpus_at_base_profile_recommendation;
        if ($excess_threads > 0) {
            $raw_additive_cpu = $excess_threads / $smt_used;
            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; } elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; } elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; } else { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            my $capped_additive_cpu = ($raw_additive_cpu < $max_additive_cap_sliding) ? $raw_additive_cpu : $max_additive_cap_sliding;
            if ($is_runq_pressure) { $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR; $debug_info{'VoltFactorReason'} = "RunQPressure Saturation (Factor set to " . $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR . ")"; }
            elsif ($is_workload_pressure && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01) {
                my $volatility_ratio = $norm_p50_numeric / $norm_p90_numeric;
                if ($volatility_ratio < $VOLATILITY_SPIKY_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; } elsif ($volatility_ratio < $VOLATILITY_MODERATE_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; } else { $volatility_confidence_factor = 1.0; }
                $debug_info{'VoltFactorReason'} = "Calculated (NormRQ P50/P90 ratio for WorkloadPressure)";
            } else {
                 $debug_info{'VoltFactorReason'} = "Additive conditions met but P50/P90 NormRQ not usable for volatility calc";
            }
            $additive_cpu = $capped_additive_cpu * $volatility_confidence_factor;
            if ($is_in_non_default_pool && $additive_cpu > 0) { $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR; $additive_cpu *= $pool_confidence_factor; }
        }
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu); $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding); $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor); $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor); $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);
    my $calculated_demand = $base_adjusted_physc + $additive_cpu; my $runq_modified_rec = $calculated_demand; $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    # Final cap on RunQ based increases - using a sliding scale of the LPAR entitlement - User Provided
	 my $forecast_multiplier = 1.25;
	 if ($curr_ent_numeric < 0.5) {
		 $forecast_multiplier = 2.5;
	 } elsif ($curr_ent_numeric < 1.0) {
		 $forecast_multiplier = 2.0;
	 } elsif ($curr_ent_numeric < 2.0) {
		 $forecast_multiplier = 1.75;
	 } elsif ($curr_ent_numeric < 4.0) {
		 $forecast_multiplier = 1.5;
	 }

	 if (defined $max_cpu_for_lpar_numeric && $max_cpu_for_lpar_numeric > 0 && $calculated_demand > ($max_cpu_for_lpar_numeric * $forecast_multiplier)) {
		 $runq_modified_rec = $max_cpu_for_lpar_numeric * $forecast_multiplier;
		 $debug_info{'CappedByMaxCPU'} = "True";
	 } else {
      $debug_info{'CappedByMaxCPU'} = "False";
    }
    if ($runq_modified_rec < 0) { $runq_modified_rec = 0; }
    return ($runq_modified_rec, \%debug_info);
}

# ... (generate_sizing_hint and other subroutines are the same as your v2.32.147.1) ...
sub generate_sizing_hint { 
    my %args = @_; 
    my $results_ref = $args{'results_ref'}; my $vm = $args{'vm'}; my $config_ref = $args{'config_ref'};
    my $norm_runq_p90_for_vm_str = $args{'norm_runq_p90_for_vm_str'}; my $abs_runq_p90_for_vm_str = $args{'abs_runq_p90_for_vm_str'};
    my $max_cpu_for_vm_numeric = $args{'max_cpu_for_vm_numeric'}; my $smt_used_for_vm_numeric = $args{'smt_used_for_vm_numeric'};
    if (defined $config_ref && defined $config_ref->{'systemtype'} && $config_ref->{'systemtype'} =~ /VIO Server/i) { return ("P", "VIO Server", 0, ""); } 
    my $o3_val = $results_ref->{$vm}{'O3-95W15'} // 0; $o3_val = 0 unless ($o3_val =~ /^-?[0-9.]+\z/);
    my $b3_val = $results_ref->{$vm}{'B3-95W15'} // 0; $b3_val = 0 unless ($b3_val =~ /^-?[0-9.]+\z/);
    my $g3_val = $results_ref->{$vm}{'G3-95W15'} // 0; $g3_val = 0 unless ($g3_val =~ /^-?[0-9.]+\z/);
    my $p99w1_val = $results_ref->{$vm}{'P-99W1'} // 0; $p99w1_val = 0 unless ($p99w1_val =~ /^-?[0-9.]+\z/);
    my $suggested_pattern = "G"; if ($b3_val > 0.01 && $o3_val > ($b3_val * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "O"; } elsif ($o3_val > 0.01 && $b3_val > ($o3_val * $PATTERN_RATIO_THRESHOLD)) { $suggested_pattern = "B"; }
    my $peakiness_ratio = 0; if ($g3_val > 0.01) { $peakiness_ratio = ($p99w1_val / $g3_val); }
    my $shape_descriptor = "Steady"; if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Very Peaky"; } elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD) { $shape_descriptor = "Moderately Peaky"; }
    my $pressure_detected_maxcpu_limit = 0; my $pressure_detected_runq_pressure = 0; my $pressure_detected_workload_pressure = 0; my $pressure_detail_str = "";
    my $maxcpu_val_from_config = (defined $config_ref && defined $config_ref->{'maxcpu'} && $config_ref->{'maxcpu'} =~ /^[0-9.]+$/ && ($config_ref->{'maxcpu'}+0) > 0) ? ($config_ref->{'maxcpu'}+0) : undef;
    if (defined $maxcpu_val_from_config && $p99w1_val >= ($maxcpu_val_from_config * $LIMIT_THRESHOLD_PERC)) { $pressure_detected_maxcpu_limit = 1; }
    my $abs_runq_p90_numeric = ($abs_runq_p90_for_vm_str ne "N/A" && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;
    my $runq_pressure_p90_calculated_value = 0; 
    if (defined $abs_runq_p90_numeric && defined $max_cpu_for_vm_numeric && $max_cpu_for_vm_numeric > 0 && defined $smt_used_for_vm_numeric && $smt_used_for_vm_numeric > 0) { $runq_pressure_p90_calculated_value = $abs_runq_p90_numeric / ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric); }
    if ($runq_pressure_p90_calculated_value > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD) { $pressure_detected_runq_pressure = 1; }
    my $norm_runq_p90_numeric = ($norm_runq_p90_for_vm_str ne "N/A" && $norm_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_for_vm_str + 0) : undef;
    if (defined $norm_runq_p90_numeric && $norm_runq_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD) { $pressure_detected_workload_pressure = 1; }
    my $overall_pressure_detected = $pressure_detected_maxcpu_limit || $pressure_detected_runq_pressure || $pressure_detected_workload_pressure; 
    if ($overall_pressure_detected) { my @pressure_points; if ($pressure_detected_maxcpu_limit) { push @pressure_points, "MaxCPU"; } if ($pressure_detected_runq_pressure) { push @pressure_points, "RunQPressure(P90=" . sprintf("%.2f", $runq_pressure_p90_calculated_value) . ")"; } if ($pressure_detected_workload_pressure) { push @pressure_points, "Workload(NormP90=" . sprintf("%.2f", $norm_runq_p90_numeric) . ")"; } if (defined $config_ref && defined $config_ref->{'pool_name'} && lc($config_ref->{'pool_name'}) ne 'defaultpool' && $config_ref->{'pool_name'} ne '') { push @pressure_points, "Pool(" . $config_ref->{'pool_name'} . ")?"; } $pressure_detail_str = join(", ", @pressure_points); }
    my $initial_tier_range_str = "3/4"; if ($shape_descriptor eq "Very Peaky") { $initial_tier_range_str = "1/2"; } elsif ($shape_descriptor eq "Moderately Peaky") { $initial_tier_range_str = "2/3"; }
    my $adjusted_tier_str = $initial_tier_range_str; if ($overall_pressure_detected) { if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; } elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; } elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; } }
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str; return ($pattern_tier_string, $shape_descriptor, $overall_pressure_detected, $pressure_detail_str);
}

sub parse_percentile_list_for_header { 
    my ($perc_str, $clean_zeros) = @_; $clean_zeros = 1 if !defined $clean_zeros; my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '') { my @raw_percentiles = split /,\s*/, $perc_str; foreach my $p (@raw_percentiles) {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100) { my $p_label = $p; if ($clean_zeros) { $p_label = sprintf("%.2f", $p); $p_label =~ s/\.?0+$//; $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00"); } push @percentiles_cleaned, $p_label; }
            else { die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n"; }}}
    return \@percentiles_cleaned;
}

sub ensure_percentiles_requested { 
    my ($perc_list_str, @required_percs) = @_; return 1 unless defined $perc_list_str && $perc_list_str ne '';
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0); my %present_map = map { $_ => 1 } @{$parsed_percs_ref};
    foreach my $req_p (@required_percs) { unless (exists $present_map{$req_p}) { return 0; }} return 1;
}

sub get_nfit_output_dp_from_flags { 
    my ($nfit_flags_str_for_this_run) = @_;
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/) {
        my $increment_val = $1 // $2; if (!(defined $increment_val && $increment_val ne "")) { $increment_val = $DEFAULT_ROUND_INCREMENT; } return get_decimal_places($increment_val); }
    return 4; 
}

sub get_decimal_places { 
    my ($number) = @_; $number = sprintf("%.15f", $number) if ($number =~ /e/i); if ($number =~ /\.(\d+)$/) { return length($1); } else { return 0; }
}

sub usage_wrapper { 
    my $script_name = $0; $script_name =~ s{.*/}{};
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [options]

Runs 'nfit' for multiple profiles. Applies RunQ modifiers and generates hints.
The RunQ modifier behavior (standard vs. additive-only) can be controlled
per profile via the 'runq_modifier_behavior' attribute in nfit.profiles.cfg.
Optionally passes flags to nfit for its internal windowed decay processing.

Core Input:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
  --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --default-smt, --smt <N> : Optional. Default SMT level (Default: $DEFAULT_SMT_VALUE_PROFILE).

RunQ Metric Configuration (for nfit, and used by this script's modifier logic):
  --runq-norm-percentiles <list> : For Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERCS").
  --runq-abs-percentiles <list>  : For Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERCS").

Configuration Files:
  -config <vm_cfg_csv>       : Optional. VM configuration CSV file.
  --profiles-config <path>   : Optional. Profiles definition file (INI format).
                               Can contain 'runq_modifier_behavior = additive_only' per profile.

Filtering (Global or passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Global start date for analysis (passed to nfit).
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name (passed to nfit).

Control nfit's Internal Windowed Recency Decay (Optional):
  --nfit-enable-windowed-decay    : Enable nfit's internal windowed processing.
                                    (Requires nfit v2.27.0+ with this feature)
  --nfit-process-window-unit <days|weeks> : Unit for nfit's window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT).
  --nfit-process-window-size <N>  : Size of nfit's window in units (Default: $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT).
  --nfit-decay-half-life-days <N> : Half-life for nfit's recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT).
  --nfit-analysis-reference-date <YYYY-MM-DD> : "Current" date for nfit's recency calculation
                                    (Default: nfit uses date of last record in its filtered NMON data).
  --nfit-runq-avg-method <none|sma|ema> : Averaging method for RunQ data within nfit before percentile.
                                          (Default: $DEFAULT_NFIT_RUNQ_AVG_METHOD). Uses main -w/--decay from profile.

Rounding (Passed to nfit for its output):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Default increment: $DEFAULT_ROUND_INCREMENT)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  --debug-runq               : Optional. Output intermediate RunQ modifier calculation columns.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  NormRunQ_P50,NormRunQ_P90,AbsRunQ_P90,RunQPressure_P90_Value,
  [Debug RunQ Cols if --debug-runq], Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are potentially recency-weighted by nfit & RunQ-modified by nfit-profile)...],
  Current_ENT,NFIT_ENT_UserFormula,NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
