#!/usr/bin/env perl

# NAME     : nfit-profile
# VERSION  : 2.35.0.1 # Per-profile RunQ metrics for additive; Allman style
# AUTHOR   : NiÃ«l Lambrechts (https://github.com/niel-lambrechts)
# PURPOSE  : Runs 'nfit' (which can now do internal windowed decay and RunQ smoothing)
#            multiple times with user-defined profiles.
#            Applies RunQ modifiers (behavior controllable per profile),
#            generates hints, logs rationale, and aggregates to CSV.
# REQUIRES : Perl, nfit script (v2.28.0.4+), Time::Piece, List::Util, IO::File, version

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(abs_path);
use File::Basename qw(dirname);
use Time::Piece;
use List::Util qw(sum min max);
use IO::File;
use version;

# --- Store original ARGV for logging ---
my @original_argv = @ARGV;

# --- Capture nfit-profile.pl start time ---
my $PROFILE_SCRIPT_START_TIME_EPOCH = time(); # Store epoch seconds for duration calculation
my $PROFILE_SCRIPT_START_TIME_STR = localtime($PROFILE_SCRIPT_START_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");

# --- Version ---
my $SCRIPT_VERSION = '2.35.0.1';

# --- Configuration ---
my $DEFAULT_ROUND_INCREMENT = 0.05;
my $DEFAULT_VM_CONFIG_FILE = "config-all.csv";
my $DEFAULT_PROFILES_CONFIG_FILE = "nfit.profiles.cfg";
my $DEFAULT_SMT_VALUE_PROFILE = 8;
my $DEFAULT_RUNQ_NORM_PERCS = "50,90"; # Still needed for nfit calls
my $DEFAULT_RUNQ_ABS_PERCS  = "90";  # Still needed for nfit calls
my $DEFAULT_NFIT_RUNQ_AVG_METHOD = "ema";

# Windowed Decay Defaults (passed to nfit if enabled)
my $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT = "weeks";
my $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT = 1;
my $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT = 30;

# Heuristic Thresholds
my $PATTERN_RATIO_THRESHOLD = 2.0;
my $HIGH_PEAK_RATIO_THRESHOLD = 5.0;
my $LOW_PEAK_RATIO_THRESHOLD  = 2.0;
my $LIMIT_THRESHOLD_PERC = 0.98;

# RunQ Modifier Thresholds
my $RUNQ_EFFICIENCY_NORM_P50_THRESHOLD = 0.5;
my $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD = 1.2;
my $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD = 0.90; # User changed this from 0.75

# Max_Additive_CPU Sliding Scale Thresholds
my $MAX_ADD_ENT_THRESH1 = 1.0; my $MAX_ADD_ABS_VAL1 = 1.0;
my $MAX_ADD_ENT_THRESH2 = 2.0; my $MAX_ADD_PERC_VAL2 = 1.0;
my $MAX_ADD_ENT_THRESH3 = 4.0; my $MAX_ADD_PERC_VAL3 = 0.75;
my $MAX_ADD_PERC_VAL_ELSE = 0.5;

# RunQ Volatility Confidence Factor Thresholds & Values
my $VOLATILITY_SPIKY_THRESHOLD = 0.5; my $VOLATILITY_SPIKY_FACTOR = 0.70;
my $VOLATILITY_MODERATE_THRESHOLD = 0.8; my $VOLATILITY_MODERATE_FACTOR = 0.85;
my $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR = 1.0;

my $POOL_CONSTRAINT_CONFIDENCE_FACTOR = 0.80;

my $LOG_FILE_PATH = "/tmp/nfit-profile.log"; # User specified path

# --- Profile Definitions (Loaded from file) ---
my @profiles;
my $PEAK_PROFILE_NAME = "Peak";

# --- Argument Parsing ---
my $physc_data_file;
my $runq_data_file_arg;
my $vm_config_file_arg;
my $profiles_config_file_arg;
my $start_date_str;
my $target_vm_name;
my $round_arg;
my $roundup_arg;
my $default_smt_arg = $DEFAULT_SMT_VALUE_PROFILE;
my $runq_norm_perc_list_str = $DEFAULT_RUNQ_NORM_PERCS;
my $runq_abs_perc_list_str  = $DEFAULT_RUNQ_ABS_PERCS;
my $help = 0;
my $show_version = 0;
my $script_dir = dirname(abs_path($0));
my $nfit_script_path = "$script_dir/nfit"; # User confirmed this is their preference
my $nfit_enable_windowed_decay = 0;
my $nfit_window_unit_str = $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT;
my $nfit_window_size_val = $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT;
my $nfit_decay_half_life_days_val = $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT;
my $nfit_analysis_reference_date_str;
my $nfit_runq_avg_method_str = $DEFAULT_NFIT_RUNQ_AVG_METHOD;

GetOptions(
    'physc-data|pc=s'         => \$physc_data_file,
    'runq-data|rq=s'          => \$runq_data_file_arg,
    'config=s'                => \$vm_config_file_arg,
    'profiles-config=s'       => \$profiles_config_file_arg,
    'startdate|s=s'           => \$start_date_str,
    'vm|lpar=s'               => \$target_vm_name,
    'round|r:f'               => \$round_arg,
    'roundup|u:f'             => \$roundup_arg,
    'default-smt|smt=i'       => \$default_smt_arg,
    'runq-norm-percentiles=s' => \$runq_norm_perc_list_str,
    'runq-abs-percentiles=s'  => \$runq_abs_perc_list_str,
    'help|h'                  => \$help,
    'nfit-path=s'             => \$nfit_script_path,
    'version|v'               => \$show_version,
    'nfit-enable-windowed-decay'     => \$nfit_enable_windowed_decay,
    'nfit-process-window-unit=s'     => \$nfit_window_unit_str,
    'nfit-process-window-size=i'     => \$nfit_window_size_val,
    'nfit-decay-half-life-days=i'    => \$nfit_decay_half_life_days_val,
    'nfit-analysis-reference-date=s' => \$nfit_analysis_reference_date_str,
    'nfit-runq-avg-method=s'         => \$nfit_runq_avg_method_str,
) or die usage_wrapper();

# --- Validation ---
my $nfit_ver = "N/A";
if ($show_version)
{
    print STDERR "nfit-profile version $SCRIPT_VERSION\n";
    if (-x $nfit_script_path)
    {
        my $nfit_ver_output = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver) = ($nfit_ver_output =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        if (defined $parsed_nfit_ver)
        {
            $nfit_ver = $parsed_nfit_ver;
            print STDERR "Uses nfit version: $nfit_ver\n";
            my $required_nfit_ver_for_windowing = "2.27.0";
            my $required_nfit_ver_for_runq_avg_and_decay = "2.28.0.4";
            
            if ($nfit_enable_windowed_decay && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_windowing))
            {
                print STDERR "Warning: --nfit-enable-windowed-decay requires nfit version $required_nfit_ver_for_windowing or higher. Your nfit version ($nfit_ver) may not support this.\n";
            }
            if (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none' && version->parse($nfit_ver) < version->parse($required_nfit_ver_for_runq_avg_and_decay))
            {
                 print STDERR "Warning: --nfit-runq-avg-method (sma/ema) may require nfit features from version $required_nfit_ver_for_runq_avg_and_decay or higher. Your nfit version ($nfit_ver) behavior might differ for RunQ processing, especially if --runq-decay is intended.\n";
            }
        }
        else
        {
            print STDERR "Could not determine nfit version from output: $nfit_ver_output\n";
            if ($nfit_enable_windowed_decay || (defined $nfit_runq_avg_method_str && $nfit_runq_avg_method_str ne 'none'))
            {
                print STDERR "Warning: Advanced nfit features are enabled but nfit version cannot be verified.\n";
            }
        }
    }
    else
    {
        print STDERR "nfit script at '$nfit_script_path' not found or not executable.\n";
    }
    exit 0;
}

# ... (rest of validations from nfit-profile.20250529T17H57.pl - assumed correct and Allman styled)
if ($help || !$physc_data_file)
{
    print STDERR usage_wrapper();
    exit 0;
}
if (! -f $physc_data_file)
{
    die "Error: Input PhysC data file (--physc-data) not found: $physc_data_file\n";
}
if (defined $runq_data_file_arg && ! -f $runq_data_file_arg)
{
    die "Error: Specified RunQ data file (--runq-data) not found: $runq_data_file_arg\n";
}
if ($default_smt_arg <= 0)
{
    die "Error: --default-smt value must be a positive integer (e.g., 4, 8).\n";
}
if (! -x $nfit_script_path)
{
    die "Error: Cannot find or execute 'nfit' script at '$nfit_script_path'. Use --nfit-path.\n";
}
if (defined($round_arg) && defined($roundup_arg))
{
    die "Error: -round (-r) and -roundup (-u) options are mutually exclusive.\n";
}
if (defined $start_date_str && $start_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
{
    die "Error: Invalid startdate (-s) format '$start_date_str'. Use YYYY-MM-DD.\n";
}

if ($nfit_enable_windowed_decay)
{
    if ($nfit_window_unit_str ne "days" && $nfit_window_unit_str ne "weeks")
    {
        die "Error: --nfit-process-window-unit must be 'days' or 'weeks'.\n";
    }
    if ($nfit_window_size_val < 1)
    {
        die "Error: --nfit-process-window-size must be at least 1.\n";
    }
    if ($nfit_decay_half_life_days_val < 1)
    {
        die "Error: --nfit-decay-half-life-days must be at least 1.\n";
    }
    if (defined $nfit_analysis_reference_date_str && $nfit_analysis_reference_date_str !~ /^\d{4}-\d{2}-\d{2}$/)
    {
        die "Error: Invalid --nfit-analysis-reference-date format. Use YYYY-MM-DD.\n";
    }
    print STDERR "nfit's internal windowed decay processing is enabled via nfit-profile.\n";
}

if (defined $nfit_runq_avg_method_str)
{
    $nfit_runq_avg_method_str = lc($nfit_runq_avg_method_str);
    unless ($nfit_runq_avg_method_str eq 'none' || $nfit_runq_avg_method_str eq 'sma' || $nfit_runq_avg_method_str eq 'ema')
    {
        die "Error: --nfit-runq-avg-method must be 'none', 'sma', or 'ema'. Got '$nfit_runq_avg_method_str'.\n";
    }
    print STDERR "Instructing nfit to use RunQ averaging method: $nfit_runq_avg_method_str.\n";
}


# --- Open Log File ---
my $LOG_FH = IO::File->new($LOG_FILE_PATH, '>')
    or warn "Error: Cannot open rationale log file '$LOG_FILE_PATH' for writing: $!. Rationale logging will be skipped.\n";

if ($LOG_FH)
{
    $LOG_FH->autoflush(1);
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "nFit Profile Rationale Log\n";
    print {$LOG_FH} "======================================================================\n";
    # Use the captured start time string here
    print {$LOG_FH} "nfit-profile.pl Run Started: $PROFILE_SCRIPT_START_TIME_STR\n";
    print {$LOG_FH} "nfit-profile.pl Version  : $SCRIPT_VERSION\n";
    
    if ($nfit_ver eq "N/A" && -x $nfit_script_path) { # Attempt to get nfit version if not already via -v
        my $nfit_ver_output_log = `$nfit_script_path -v 2>&1`;
        my ($parsed_nfit_ver_log) = ($nfit_ver_output_log =~ /nfit version\s*([0-9.a-zA-Z-]+)/i);
        $nfit_ver = $parsed_nfit_ver_log // "Unknown (parse failed)";
    }
    print {$LOG_FH} "nfit.pl Version Used     : $nfit_ver\n";

    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Invocation:\n";
    my @quoted_original_argv_log = map { $_ =~ /\s/ ? qq/"$_"/ : $_ } @original_argv; # Quote args with spaces
    print {$LOG_FH} "  $0 " . join(" ", @quoted_original_argv_log) . "\n";
    print {$LOG_FH} "----------------------------------------------------------------------\n";
    print {$LOG_FH} "Key Global Settings:\n";
    print {$LOG_FH} "  - PhysC Data File          : $physc_data_file\n";
    print {$LOG_FH} "  - RunQ Data File           : " . ($runq_data_file_arg // "Not Provided") . "\n";
}

# --- Load Profile Definitions ---
# ... (This section is assumed to be correctly Allman styled from user's provided file) ...
my $profiles_config_path_to_load;
if (defined $profiles_config_file_arg)
{
    if (-f $profiles_config_file_arg)
    {
        $profiles_config_path_to_load = $profiles_config_file_arg;
    }
    else
    {
        die "Error: Specified profiles config (--profiles-config) not found: $profiles_config_file_arg\n";
    }
}
else
{
    $profiles_config_path_to_load = "$script_dir/etc/$DEFAULT_PROFILES_CONFIG_FILE";
    unless (-f $profiles_config_path_to_load)
    {
        $profiles_config_path_to_load = "$script_dir/$DEFAULT_PROFILES_CONFIG_FILE";
    }
    unless (-f $profiles_config_path_to_load)
    {
        die "Error: Default profiles config '$DEFAULT_PROFILES_CONFIG_FILE' not found in '$script_dir/etc/' or '$script_dir/'. Use --profiles-config.\n";
    }
}
print STDERR "Loading profile definitions from: $profiles_config_path_to_load\n";
if ($LOG_FH) { print {$LOG_FH} "  - Profiles Config File     : $profiles_config_path_to_load\n"; }
@profiles = load_profile_definitions($profiles_config_path_to_load);
if (scalar @profiles == 0)
{
    die "Error: No profiles loaded from '$profiles_config_path_to_load'.\n";
}
print STDERR "Loaded " . scalar(@profiles) . " profiles.\n";


# --- Locate and Load VM Configuration Data ---
# ... (This section is assumed to be correctly Allman styled from user's provided file) ...
my $vm_config_file_path = undef;
my $vm_config_found = 0;
my %vm_config_data;
my %vm_config_col_idx;
my $vm_config_header_count = 0;
if (defined $vm_config_file_arg)
{
    if (-f $vm_config_file_arg)
    {
        $vm_config_file_path = $vm_config_file_arg;
        $vm_config_found = 1;
        print STDERR "Using specified VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        die "Error: Specified VM configuration file (-config) not found: $vm_config_file_arg\n";
    }
}
else
{
    my $dp_etc = "$script_dir/etc/$DEFAULT_VM_CONFIG_FILE";
    my $dp_root = "$script_dir/$DEFAULT_VM_CONFIG_FILE";
    if (-f $dp_etc)
    {
        $vm_config_file_path = $dp_etc;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    elsif (-f $dp_root)
    {
        $vm_config_file_path = $dp_root;
        $vm_config_found = 1;
        print STDERR "Found default VM configuration file: $vm_config_file_path\n";
    }
    else
    {
        print STDERR "Info: Default VM configuration file '$DEFAULT_VM_CONFIG_FILE' not found. VM config/SMT/MaxCPU columns will be blank/default. RunQPressure_P90 logic will be impacted.\n";
    }
}
if ($LOG_FH) { print {$LOG_FH} "  - VM Config File           : " . ($vm_config_file_path // "Not Provided/Default Attempted") . "\n"; }

if ($vm_config_found)
{
    print STDERR "Loading VM configuration data (manual parse)...\n";
    open my $cfg_fh, '<:encoding(utf8)', $vm_config_file_path or die "Error: Cannot open VM config file '$vm_config_file_path': $!\n";
    my $hdr = <$cfg_fh>;
    unless (defined $hdr)
    {
        die "Error: Could not read header from VM config '$vm_config_file_path'\n";
    }
    chomp $hdr;
    $hdr =~ s/\r$//;
    $hdr =~ s/^\x{FEFF}//; # BOM
    my @rhdrs = split /,/, $hdr;
    $vm_config_header_count = scalar @rhdrs;
    my %hmap;
    for my $i (0 .. $#rhdrs)
    {
        my $cn = $rhdrs[$i];
        $cn =~ s/^\s*"?|"?\s*$//g;
        if ($cn ne '')
        {
            $hmap{lc($cn)} = $i;
        }
    }
    my @req_cols = qw(hostname serial systemtype procpool_name procpool_id entitledcpu maxcpu);
    my $has_smt_col = exists $hmap{'smt'};
    unless (exists $hmap{'maxcpu'})
    {
        warn "Warning: 'maxcpu' column not found in VM config. Final MaxCPU capping logic will be affected.\n";
    }
    if ($has_smt_col)
    {
        print STDERR "Found 'SMT' column in VM configuration file.\n";
    }
    else
    {
        print STDERR "Info: 'SMT' column not found in VM configuration file. Will use default SMT: $default_smt_arg for RunQ calculations.\n";
    }
    foreach my $rc (@req_cols)
    {
        unless (exists $hmap{$rc})
        {
            die "Error: Required column '$rc' not found in VM config file header '$vm_config_file_path'\n";
        }
        $vm_config_col_idx{$rc} = $hmap{$rc};
    }
    if ($has_smt_col)
    {
        $vm_config_col_idx{'smt'} = $hmap{'smt'};
    }
    while (my $ln = <$cfg_fh>)
    {
        chomp $ln;
        $ln =~ s/\r$//;
        next if $ln =~ /^\s*$/;
        my @rvals = ($ln =~ /"([^"]*)"/g); # Try to parse CSV with quotes
        if (scalar @rvals != $vm_config_header_count)
        {
            @rvals = split /,/, $ln; # Fallback to simple split
            if (scalar @rvals != $vm_config_header_count)
            {
                warn "Warning: Mismatched field count on VM config line $. Skipping: $ln\n";
                next;
            }
            $_ =~ s/^\s+|\s+$//g for @rvals; # Trim if simple split
        }
        my $hn = $rvals[ $vm_config_col_idx{'hostname'} ];
        if (defined $hn && $hn ne '')
        {
            my $smt_v = $default_smt_arg;
            if ($has_smt_col && defined $rvals[$vm_config_col_idx{'smt'}] && $rvals[$vm_config_col_idx{'smt'}] ne '')
            {
                my $sf = $rvals[$vm_config_col_idx{'smt'}];
                if ($sf =~ /(\d+)$/)
                {
                    $smt_v = $1;
                    if ($smt_v <= 0)
                    {
                        warn "Warning: Invalid SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                        $smt_v = $default_smt_arg;
                    }
                }
                else
                {
                    warn "Warning: Could not parse SMT '$sf' for '$hn'. Using default $default_smt_arg.\n";
                }
            }
            my $max_cpu_val = $rvals[$vm_config_col_idx{'maxcpu'}];
            unless (defined $max_cpu_val && $max_cpu_val =~ /^[0-9.]+$/ && ($max_cpu_val+0) > 0)
            {
                $max_cpu_val = 0;
            }
            $vm_config_data{$hn} = {
                serial => $rvals[$vm_config_col_idx{'serial'}],
                systemtype  => $rvals[$vm_config_col_idx{'systemtype'}],
                pool_name => $rvals[$vm_config_col_idx{'procpool_name'}],
                pool_id => $rvals[$vm_config_col_idx{'procpool_id'}],
                entitlement => $rvals[$vm_config_col_idx{'entitledcpu'}],
                maxcpu => ($max_cpu_val + 0),
                smt => $smt_v,
            };
        }
        else
        {
            warn "Warning: Missing hostname on VM config line $. Skipping.\n";
        }
    }
    close $cfg_fh;
    print STDERR "Finished loading VM config data for " . scalar(keys %vm_config_data) . " VMs.\n";
}
else
{
     print STDERR "Warning: VM configuration file not loaded. MaxCPU capping logic will be affected, and SMT will use default.\n";
}


# --- Construct Common Flags for nfit ---
my $common_nfit_flags_base = "-k --physc-data \"$physc_data_file\"";
if (defined $runq_data_file_arg)
{
    $common_nfit_flags_base .= " --runq-data \"$runq_data_file_arg\"";
    $common_nfit_flags_base .= " --runq-norm-perc \"$runq_norm_perc_list_str\"";
    $common_nfit_flags_base .= " --runq-abs-perc \"$runq_abs_perc_list_str\"";
    if (defined $nfit_runq_avg_method_str)
    {
        $common_nfit_flags_base .= " --runq-avg-method \"$nfit_runq_avg_method_str\"";
    }
}
if (defined $start_date_str)
{
    $common_nfit_flags_base .= " -s $start_date_str";
}

my $rounding_flags_for_nfit = "";
if (defined $round_arg)
{
    $rounding_flags_for_nfit .= " -r";
    if (length $round_arg && $round_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$round_arg";
    }
}
elsif (defined $roundup_arg)
{
    $rounding_flags_for_nfit .= " -u";
    if (length $roundup_arg && $roundup_arg !~ /^\s*$/)
    {
        $rounding_flags_for_nfit .= "=$roundup_arg";
    }
}
$common_nfit_flags_base .= $rounding_flags_for_nfit;

my $nfit_windowing_decay_flags = "";
if ($nfit_enable_windowed_decay)
{
    $nfit_windowing_decay_flags .= " --enable-windowed-decay";
    $nfit_windowing_decay_flags .= " --process-window-unit \"$nfit_window_unit_str\"";
    $nfit_windowing_decay_flags .= " --process-window-size $nfit_window_size_val";
    $nfit_windowing_decay_flags .= " --decay-half-life-days $nfit_decay_half_life_days_val";
    if (defined $nfit_analysis_reference_date_str)
    {
        $nfit_windowing_decay_flags .= " --analysis-reference-date \"$nfit_analysis_reference_date_str\"";
    }
}
$common_nfit_flags_base .= $nfit_windowing_decay_flags;

if ($LOG_FH) {
    print {$LOG_FH} "  - nfit Common Base Flags   : $common_nfit_flags_base\n";
    print {$LOG_FH} "  - nfit Windowed Decay Opts : " . ($nfit_windowing_decay_flags ne "" ? $nfit_windowing_decay_flags : "Not Enabled") . "\n";
    print {$LOG_FH} "  - nfit RunQ Avg Method     : $nfit_runq_avg_method_str\n";
    print {$LOG_FH} "  - Default SMT for Profile  : $default_smt_arg\n";
    print {$LOG_FH} "======================================================================\n\n";
    print {$LOG_FH} "===== Per-VM / Per-Profile RunQ Adjustment Details =====\n\n";
}


# --- Main Logic: Run nfit Profiles ---
my %results_table;
my @vm_order;
my %vm_seen;
my %primary_runq_metrics_captured_for_vm; # Key: vm_name, Value: hash {metric_key => 1}
my %source_profile_for_global_runq;       # Key: vm_name, Value: profile_name
my %per_profile_runq_metrics;             # Key: $vm{$profile}{$metric} = value

print STDERR "nfit-profile version $SCRIPT_VERSION\n";
print STDERR "Starting nfit profile runs...\n";

foreach my $profile (@profiles)
{
    my $profile_name = $profile->{name};
    my $profile_specific_flags = $profile->{flags};
    my $profile_runq_behavior = $profile->{runq_behavior} // 'default';

    print STDERR "Running profile: $profile_name ($profile_specific_flags";
    print STDERR " ; RunQBehavior: $profile_runq_behavior" if $profile_runq_behavior ne 'default';
    print STDERR ")...\n";
    
    my $nfit_smt_flag_for_current_run = "--smt $default_smt_arg";
    my $nfit_vm_flag_for_current_run = "";

    if (defined $target_vm_name)
    {
        $nfit_vm_flag_for_current_run = " -vm \"$target_vm_name\"";
        if ($vm_config_found && exists $vm_config_data{$target_vm_name} && defined $vm_config_data{$target_vm_name}{'smt'})
        {
            $nfit_smt_flag_for_current_run = "--smt " . $vm_config_data{$target_vm_name}{'smt'};
        }
    }
    
    my $command = "$nfit_script_path $common_nfit_flags_base $nfit_vm_flag_for_current_run $nfit_smt_flag_for_current_run $profile_specific_flags";
    my $output = `$command`;
    my $exit_status = $? >> 8;

    if ($exit_status != 0)
    {
        warn "Warning: '$nfit_script_path' cmd failed for profile '$profile_name' (exit $exit_status). Command was: $command. Output: $output. Skip.\n";
        if ($LOG_FH)
        {
             print {$LOG_FH} "ERROR: nfit.pl execution FAILED for profile '$profile_name' on VM(s) '". ($target_vm_name // "All") ."'.\n";
             print {$LOG_FH} "  Command: $command\n";
             print {$LOG_FH} "  Exit Status: $exit_status\n";
             my $short_output = substr($output, 0, 1000) . (length($output) > 1000 ? "..." : "");
             print {$LOG_FH} "  Output (first 1000 chars): $short_output\n";
        }
        next;
    }

    my @output_lines = split /\n/, $output;
    foreach my $line (@output_lines)
    {
        chomp $line;
        if ($line =~ /^(.+?):\s*(.*)$/)
        {
            my $vm_name_from_nfit = $1;
            my $metrics_str = $2;

            unless ($vm_seen{$vm_name_from_nfit}++)
            {
                push @vm_order, $vm_name_from_nfit;
            }
            
            $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit} //= {
                'NormRunQ_P50' => 0,
                'NormRunQ_P90' => 0,
                'AbsRunQ_P90'  => 0,
            };

            my ($profile_p_flag_val_num) = ($profile_specific_flags =~ /-p\s+([0-9.]+)/);
            if (defined $profile_p_flag_val_num)
            {
                my $expected_metric_key_base = sprintf("%.2f", $profile_p_flag_val_num);
                $expected_metric_key_base =~ s/\.?0+$//;
                $expected_metric_key_base = "0" if $expected_metric_key_base eq "" && abs($profile_p_flag_val_num - 0) < 0.001;
                my $expected_metric_key = "P$expected_metric_key_base";
                
                if ($metrics_str =~ /\Q$expected_metric_key\E=([0-9.NA\/ -]+?)(?:\s+|$)/)
                {
                    my $p_value_val = $1;
                    $p_value_val =~ s/^\s+|\s+$//g;
                    $results_table{$vm_name_from_nfit}{$profile_name} = $p_value_val;
                }
            }

            if ($metrics_str =~ /Peak=([0-9.NA\/ -]+?)(?:\s+|$)/)
            {
                my $peak_value = $1;
                $peak_value =~ s/^\s+|\s+$//g;
                $results_table{$vm_name_from_nfit}{$PEAK_PROFILE_NAME} = $peak_value;
            }

            my %first_capture_target_keys = (
                'NormRunQ_P50' => 1,
                'NormRunQ_P90' => 1,
                'AbsRunQ_P90'  => 1,
            );

            while ($metrics_str =~ /(NormRunQ_P\d+\.?\d*|AbsRunQ_P\d+\.?\d*)=([0-9.NA\/ -]+?)(?:\s+|$)/g)
            {
                my ($rq_metric_name, $rq_value) = ($1, $2);
                $rq_value =~ s/^\s+|\s+$//g;

                # Store ALL parsed RunQ metrics for THIS profile
                $per_profile_runq_metrics{$vm_name_from_nfit}{$profile_name}{$rq_metric_name} = $rq_value;

                # Additionally, store the primary ones if they are the first capture for this VM (for hint generation)
                if (exists $first_capture_target_keys{$rq_metric_name})
                {
                    if (!$primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name})
                    {
                        $results_table{$vm_name_from_nfit}{$rq_metric_name} = $rq_value; # For hint logic
                        $primary_runq_metrics_captured_for_vm{$vm_name_from_nfit}{$rq_metric_name} = 1;
                        $source_profile_for_global_runq{$vm_name_from_nfit} //= $profile_name;
                    }
                }
            }
        }
        elsif ($line ne '')
        {
            warn "Warning: Could not parse VM name from nfit output line for profile '$profile_name': $line\n";
        }
    }
}
print STDERR "Finished nfit profile runs. Generating CSV output and rationale log...\n";

# --- Generate CSV Output ---
my @output_header_cols_csv;
@output_header_cols_csv = (
    "VM", "TIER", "Hint", "Pattern", "Pressure", "PressureDetail", "SMT",
    "Serial", "SystemType", "Pool Name", "Pool ID", $PEAK_PROFILE_NAME
);
push @output_header_cols_csv, map { $_->{name} } @profiles;
push @output_header_cols_csv, ("Current_ENT", "NFIT_ENT_UserFormula", "NETT_UserFormula", "NETT_Perc_UserFormula");
print STDOUT join(",", map { quote_csv($_) } @output_header_cols_csv) . "\n";

foreach my $vm_name (@vm_order)
{
    my @data_row_csv;
    my $cfg_csv = $vm_config_data{$vm_name};
    my $smt_used_for_vm_csv = (defined $cfg_csv && defined $cfg_csv->{smt}) ? $cfg_csv->{smt} : $default_smt_arg;
    my $max_cpu_for_vm_csv  = (defined $cfg_csv && defined $cfg_csv->{maxcpu} && $cfg_csv->{maxcpu} > 0) ? $cfg_csv->{maxcpu} : 0;
    
    # "Global" RunQ metrics (from first profile) for hint generation
    my $hint_norm_runq_p50_str = $results_table{$vm_name}{'NormRunQ_P50'} // "N/A"; # Not used by hint, but captured
    my $hint_norm_runq_p90_str = $results_table{$vm_name}{'NormRunQ_P90'} // "N/A";
    my $hint_abs_runq_p90_str  = $results_table{$vm_name}{'AbsRunQ_P90'}  // "N/A";
    my $hint_runq_metrics_source_profile = $source_profile_for_global_runq{$vm_name} // "First Profile Processed";

    my ($hint_type_tier_csv, $hint_pattern_shape_csv, $hint_pressure_bool_csv, $pressure_detail_str_csv) =
        generate_sizing_hint(
            'results_ref'              => \%results_table, # Contains P-99W1 etc. for pattern
            'vm' => $vm_name,
            'config_ref' => $cfg_csv,
            'norm_runq_p90_for_vm_str' => $hint_norm_runq_p90_str, # Use first-profile sourced for hint
            'abs_runq_p90_for_vm_str'  => $hint_abs_runq_p90_str,  # Use first-profile sourced for hint
            'max_cpu_for_vm_numeric'   => $max_cpu_for_vm_csv,
            'smt_used_for_vm_numeric'  => $smt_used_for_vm_csv
        );
    my $pressure_bool_str_csv = $hint_pressure_bool_csv ? "True" : "False";
    
    push @data_row_csv, $vm_name, "", $hint_type_tier_csv, $hint_pattern_shape_csv, $pressure_bool_str_csv, $pressure_detail_str_csv, $smt_used_for_vm_csv;
    
    push @data_row_csv, (defined $cfg_csv ? $cfg_csv->{serial} : ""), (defined $cfg_csv ? $cfg_csv->{systemtype} : ""), (defined $cfg_csv ? $cfg_csv->{pool_name} : ""), (defined $cfg_csv ? $cfg_csv->{pool_id} : "");
    push @data_row_csv, ($results_table{$vm_name}{$PEAK_PROFILE_NAME} // "");
    
    foreach my $profile (@profiles)
    {
        my $profile_name_being_adjusted = $profile->{name};
        my $raw_physc_profile_value_str = $results_table{$vm_name}{$profile_name_being_adjusted};
        my $adjusted_value_str = "N/A";
        my $current_profile_runq_behavior = $profile->{runq_behavior} // 'default';
        my $debug_info_ref_profile_for_log;

        # Get THIS profile's specific RunQ metrics for its own additive calculation
        my $this_profile_norm_p50 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P50'} // "N/A";
        my $this_profile_norm_p90 = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'NormRunQ_P90'} // "N/A";
        my $this_profile_abs_p90  = $per_profile_runq_metrics{$vm_name}{$profile_name_being_adjusted}{'AbsRunQ_P90'}  // "N/A";

        if (defined $raw_physc_profile_value_str && $raw_physc_profile_value_str ne "N/A" && $raw_physc_profile_value_str =~ /^-?[0-9.]+$/)
        {
            my $raw_physc_profile_value = $raw_physc_profile_value_str + 0;
            my $is_non_default_pool = (defined $cfg_csv && defined $cfg_csv->{pool_name} && lc($cfg_csv->{pool_name}) ne 'defaultpool' && $cfg_csv->{pool_name} ne '');
            
            my ($runq_modified_physc_for_profile, $debug_info_ref) = calculate_runq_modified_physc(
                $raw_physc_profile_value,
                $this_profile_norm_p50,    # Use this profile's specific RunQ metrics
                $this_profile_norm_p90,
                $this_profile_abs_p90,
                $smt_used_for_vm_csv, (defined $cfg_csv ? $cfg_csv->{entitlement} : "0"), $max_cpu_for_vm_csv, $is_non_default_pool,
                $current_profile_runq_behavior
            );
            $debug_info_ref_profile_for_log = $debug_info_ref;
            
            my $current_profile_nfit_flags = $profile->{flags};
            my $current_profile_output_dp = get_nfit_output_dp_from_flags($rounding_flags_for_nfit . " " . $current_profile_nfit_flags);
            my $current_sprintf_format = "%." . $current_profile_output_dp . "f";
            $adjusted_value_str = sprintf($current_sprintf_format, $runq_modified_physc_for_profile);
        }
        else
        {
            $adjusted_value_str = $raw_physc_profile_value_str // "N/A";
            $debug_info_ref_profile_for_log = {
                 BasePhysC => $raw_physc_profile_value_str // "N/A",
                 ReasonForNoModification => "Base PhysC for profile '$profile_name_being_adjusted' was N/A or not numeric.",
                 FinalAdjustedPhysC => $adjusted_value_str,
            };
        }
        push @data_row_csv, $adjusted_value_str;

        if ($LOG_FH)
        {
            # For logging, Section A.2 needs to show which RunQ metrics were used for THIS profile's adjustment
            log_profile_rationale(
                $LOG_FH, $vm_name, $profile_name_being_adjusted,
                $raw_physc_profile_value_str, # Base PhysC of current profile
                $profile_name_being_adjusted, # Profile sourcing these RunQ metrics is itself
                $this_profile_abs_p90,        # This profile's AbsP90
                $this_profile_norm_p50,       # This profile's NormP50
                $this_profile_norm_p90,       # This profile's NormP90
                $cfg_csv, $smt_used_for_vm_csv, $max_cpu_for_vm_csv,
                $current_profile_runq_behavior,
                $debug_info_ref_profile_for_log,
                $adjusted_value_str
            );
        }
    }
    
    my $current_ent_display_csv_out = (defined $cfg_csv && defined $cfg_csv->{entitlement}) ? $cfg_csv->{entitlement} : "";
    if ($current_ent_display_csv_out ne "" && $current_ent_display_csv_out =~ /^-?[0-9.]+$/)
    {
        $current_ent_display_csv_out = sprintf("%.2f", $current_ent_display_csv_out);
    }
    push @data_row_csv, $current_ent_display_csv_out, "NFIT_Formula", "NETT_UserFormula", "NETT_Perc_UserFormula";
    
    print STDOUT join(",", map { quote_csv($_) } @data_row_csv) . "\n";
}

# ... (rest of the script: print STDERR CSV output generated, log footer, exit 0)
# ... (subroutines: log_profile_rationale, quote_csv, load_profile_definitions, calculate_runq_modified_physc,
#      generate_sizing_hint, parse_percentile_list_for_header, ensure_percentiles_requested,
#      get_nfit_output_dp_from_flags, get_decimal_places, usage_wrapper - ensure Allman style is maintained)

print STDERR "CSV output generated successfully.\n";
if ($nfit_enable_windowed_decay)
{
    print STDERR "Note: nfit was instructed to use internal windowed decay processing.\n";
}
if ($LOG_FH)
{
    my $PROFILE_SCRIPT_END_TIME_EPOCH = time();
    my $PROFILE_SCRIPT_END_TIME_STR = localtime($PROFILE_SCRIPT_END_TIME_EPOCH)->strftime("%Y-%m-%d %H:%M:%S %Z");
    my $PROFILE_SCRIPT_DURATION = $PROFILE_SCRIPT_END_TIME_EPOCH - $PROFILE_SCRIPT_START_TIME_EPOCH;

    print {$LOG_FH} "\n----------------------------------------------------------------------\n"; 
    print {$LOG_FH} "nfit-profile.pl Run Ended  : $PROFILE_SCRIPT_END_TIME_STR\n";
    print {$LOG_FH} "Total Duration             : $PROFILE_SCRIPT_DURATION seconds\n";
    print {$LOG_FH} "======================================================================\n";
    print {$LOG_FH} "End of Rationale Log.\n";
    print {$LOG_FH} "======================================================================\n";
    close $LOG_FH;
    print STDERR "Rationale log written to: $LOG_FILE_PATH\n";
}

exit 0;

# ==============================================================================
# Subroutines (Ensure Allman style for all, content as per user's file)
# ==============================================================================

sub log_profile_rationale # Updated signature and logic expected here
{
    my ($fh, $vm_name, $profile_being_adjusted,
        $raw_physc_for_profile,
        $runq_metrics_source_profile_name_for_this_calc, # This is now $profile_being_adjusted
        $absP90_for_this_calc, $normP50_for_this_calc, $normP90_for_this_calc,
        $vm_cfg_ref, $smt_val, $lpar_max_cpu_cfg_val,
        $profile_rq_behavior,
        $calc_debug_info_ref,
        $final_csv_value_for_profile
    ) = @_;

    return unless $fh; 

    my $na = 'N/A'; 

    print {$fh} "----------------------------------------------------------------------\n";
    print {$fh} "VM Name                 : $vm_name\n";
    print {$fh} "Profile Adjusted        : $profile_being_adjusted\n";
    print {$fh} "----------------------------------------------------------------------\n\n";

    print {$fh} "Section A: Inputs for RunQ Adjustment\n";
    printf {$fh} "  1. Base PhysC for this Profile : %s cores (Value from nfit for profile '%s')\n", ($raw_physc_for_profile // $na), $profile_being_adjusted;
    printf {$fh} "  2. RunQ Metrics for this Adjustment (sourced from this profile's ['%s'] nfit run):\n", $runq_metrics_source_profile_name_for_this_calc; # Now points to self
    printf {$fh} "     - AbsRunQ P90             : %s threads\n", ($absP90_for_this_calc // $na);
    printf {$fh} "     - NormRunQ P50            : %s\n", ($normP50_for_this_calc // $na);
    printf {$fh} "     - NormRunQ P90            : %s\n", ($normP90_for_this_calc // $na);
    print {$fh} "  3. VM Configuration:\n";
    printf {$fh} "     - SMT                     : %s\n", $smt_val;
    printf {$fh} "     - Current Entitlement     : %s cores\n", (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} ? $vm_cfg_ref->{entitlement} : $na);
    printf {$fh} "     - LPAR MaxCPU             : %s cores\n", ($lpar_max_cpu_cfg_val > 0 ? $lpar_max_cpu_cfg_val : $na);
    my $is_non_default_pool_log = (defined $vm_cfg_ref && defined $vm_cfg_ref->{pool_name} && lc($vm_cfg_ref->{pool_name}) ne 'defaultpool' && $vm_cfg_ref->{pool_name} ne '') ? "Yes" : "No";
    printf {$fh} "     - In Non-Default Pool     : %s\n", $is_non_default_pool_log;
    printf {$fh} "  4. Profile RunQ Behavior    : %s\n\n", $profile_rq_behavior;

    if (defined $calc_debug_info_ref->{'ReasonForNoModification'} && $calc_debug_info_ref->{'ReasonForNoModification'} ne '')
    {
        printf {$fh} "RunQ Modification Skipped: %s\n", $calc_debug_info_ref->{'ReasonForNoModification'};
        printf {$fh} "Final Value for Profile '%s': %s cores (same as Base PhysC due to skip)\n\n", $profile_being_adjusted, ($raw_physc_for_profile // $na);
        return;
    }

    print {$fh} "Section B: RunQ-Driven CPU Adjustment Calculation\n";
    print {$fh} "  1. Efficiency Adjustment:\n";
    my $eff_factor_log = $calc_debug_info_ref->{'EffFactor'} // $na;
    my $eff_reason_log = $calc_debug_info_ref->{'EffFactorReason'} // $na;
    printf {$fh} "     - Efficiency Factor       : %s (Reason: %s)\n", $eff_factor_log, $eff_reason_log;
    my $base_adj_physc_log = $calc_debug_info_ref->{'BaseAdjustedPhysC'} // $na;
    # Value from debug_info is already formatted or N/A
    printf {$fh} "     - PhysC after Efficiency  : %s cores\n\n", $base_adj_physc_log;

    print {$fh} "  2. Pressure Assessment (based on RunQ Metrics for profile '$profile_being_adjusted'):\n";
    my $runq_pressure_val_log = $calc_debug_info_ref->{'RunQPressure_P90_Val'} // $na;
    my $is_rq_pressure_log = $calc_debug_info_ref->{'IsRunQPressure'} // $na;
    my $is_wl_pressure_log = $calc_debug_info_ref->{'IsWorkloadPressure'} // $na;
    my $apply_additive = ($is_rq_pressure_log eq "True" || $is_wl_pressure_log eq "True");
    
    # Using values passed to this function for the calculation string ($absP90_for_this_calc, etc.)
    print {$fh} "     - RunQ Pressure Calculation: AbsRunQ P90 / (LPAR MaxCPU * SMT)\n";
    my $abs_p90_num_log = ($absP90_for_this_calc ne $na && $absP90_for_this_calc =~ /^-?[0-9.]+$/) ? ($absP90_for_this_calc + 0) : 0;
    my $max_cpu_num_log = ($lpar_max_cpu_cfg_val > 0) ? $lpar_max_cpu_cfg_val : 0;
    my $smt_num_log = ($smt_val > 0) ? $smt_val : 1;
    my $denominator_rp_log = $max_cpu_num_log * $smt_num_log;
    my $calc_detail_rp_log = ($denominator_rp_log > 0) 
                           ? sprintf("%.2f / (%.2f * %d) = %.4f", $abs_p90_num_log, $max_cpu_num_log, $smt_num_log, ($abs_p90_num_log / $denominator_rp_log)) 
                           : sprintf("%.2f / (Denominator_Zero_Or_Invalid)", $abs_p90_num_log);
    print {$fh} "                                : $calc_detail_rp_log\n";
    printf {$fh} "     - RunQ Pressure Value     : %s (Threshold: > %.2f) -> IsRunQPressure? %s\n", $runq_pressure_val_log, $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD, $is_rq_pressure_log;
    
    print {$fh} "     - Workload Pressure        : NormRunQ P90 (from this profile's nfit run)\n";
    printf {$fh} "     - Workload Pressure (NormP90): %s (Threshold: > %.2f) -> IsWorkloadPressure? %s\n", ($normP90_for_this_calc // $na), $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD, $is_wl_pressure_log;
    printf {$fh} "     - Workload Pressure Reason   : %s\n", ($calc_debug_info_ref->{'WorkloadPressureReason'} // $na);
    printf {$fh} "     >> Additive Logic Applies  : %s\n\n", ($apply_additive ? "Yes" : "No");

    my $final_additive_log_val = $calc_debug_info_ref->{'FinalAdditive'} // "0.0000";
    if ($apply_additive)
    {
        print {$fh} "  3. Additive CPU Calculation:\n";
        my $base_physc_for_add_log_val = $calc_debug_info_ref->{'BasePhysC'} // $na; # This is raw_physc_for_profile
        if ($base_physc_for_add_log_val ne $na && $base_physc_for_add_log_val =~ /^-?[0-9.]+$/)
        {
            printf {$fh} "     - Base PhysC for Additive : %.4f cores (Raw PhysC of profile '%s')\n", $base_physc_for_add_log_val, $profile_being_adjusted;
        }
        else
        {
            printf {$fh} "     - Base PhysC for Additive : %s (Raw PhysC of profile '%s')\n", $base_physc_for_add_log_val, $profile_being_adjusted;
        }

        printf {$fh} "     - Effective LCPUs for Base: %s threads (Base PhysC * SMT)\n", ($calc_debug_info_ref->{'EffectiveLCPUsAtBase'} // $na);
        printf {$fh} "     - Excess Threads          : %s threads (AbsRunQ P90 - Effective LCPUs)\n", ($calc_debug_info_ref->{'ExcessThreads'} // $na);
        printf {$fh} "     - Raw Additive CPU        : %s cores (Excess Threads / SMT)\n", ($calc_debug_info_ref->{'RawAdditive'} // $na);
        printf {$fh} "     - Max Additive Cap        : %s cores (Derived from Entitlement: %s)\n", ($calc_debug_info_ref->{'MaxAdditiveCap'} // $na), (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} ? $vm_cfg_ref->{entitlement} : $na);
        printf {$fh} "     - Capped Raw Additive     : %s cores (Min(Raw Additive, Max Cap))\n", ($calc_debug_info_ref->{'CappedRawAdditive'} // $na);
        printf {$fh} "     - Volatility Factor       : %s (Reason: %s)\n", ($calc_debug_info_ref->{'VoltFactor'} // $na), ($calc_debug_info_ref->{'VoltFactorReason'} // $na);
        printf {$fh} "     - Pool Factor             : %s\n", ($calc_debug_info_ref->{'PoolFactor'} // $na);
        printf {$fh} "     - Final Additive CPU      : %s cores\n\n", ($final_additive_log_val eq $na ? $na : sprintf "%.4f", $final_additive_log_val); # Ensure numeric formatting if not N/A
    }
    else
    {
        print {$fh} "  3. Additive CPU Calculation : Skipped (No significant pressure detected to trigger additive logic).\n\n";
        $final_additive_log_val = "0.0000"; # Reset for consistency if not applied
    }

    print {$fh} "  4. CPU Recommendation (Pre LPAR MaxCPU Cap):\n";
    my $pre_cap_rec_log_val = $calc_debug_info_ref->{'PreMaxCpuCapRec'} // $na;
    printf {$fh} "     - Pre-Cap Value           : %s cores (PhysC after Efficiency + Final Additive)\n\n", ($pre_cap_rec_log_val eq $na ? $na : sprintf "%.4f", $pre_cap_rec_log_val); # Ensure numeric formatting

    print {$fh} "Section C: LPAR MaxCPU Capping\n";
    my $lpar_max_display_log = ($lpar_max_cpu_cfg_val > 0) ? sprintf("%.2f", $lpar_max_cpu_cfg_val) : $na;
    printf {$fh} "  1. LPAR MaxCPU (from config)  : %s cores\n", $lpar_max_display_log;

    my $ent_for_forecast_log_val = (defined $vm_cfg_ref && defined $vm_cfg_ref->{entitlement} ? $vm_cfg_ref->{entitlement} : $na);
    printf {$fh} "  2. Entitlement (for multiplier): %s cores\n", $ent_for_forecast_log_val;

    my $fm_display_log_val = $calc_debug_info_ref->{'ForecastMultiplier'};
	 if (defined $fm_display_log_val && $fm_display_log_val ne $na && $fm_display_log_val =~ /^-?[0-9.]+$/) {
		 printf {$fh} "  3. Forecast Multiplier        : %.2f\n", $fm_display_log_val;
	 } else {
		 printf {$fh} "  3. Forecast Multiplier        : %s\n", ($fm_display_log_val // $na);
	 }

    my $eff_max_cap_log_val = $calc_debug_info_ref->{'EffectiveMaxCPUCap'} // $na;
    printf {$fh} "  4. Effective MaxCPU Cap       : %s cores (LPAR MaxCPU * Forecast Multiplier)\n", ($eff_max_cap_log_val eq $na ? $na : sprintf "%.4f", $eff_max_cap_log_val); # Ensure numeric formatting
    printf {$fh} "  5. Is Capped by MaxCPU?       : %s\n\n", ($calc_debug_info_ref->{'CappedByMaxCPU'} // $na);

    print {$fh} "Section D: Final Result for Profile '$profile_being_adjusted'\n";
    printf {$fh} "  - Final Adjusted Value      : %s cores\n", ($final_csv_value_for_profile // $na); # This is already formatted from CSV gen
    print {$fh} "\n";
}

sub quote_csv
{
    my ($field) = @_;
    if (!defined $field)
    {
        $field = '';
    }
    $field =~ s/"/""/g;
    return qq/"$field"/;
}

sub load_profile_definitions
{
    my ($filepath) = @_;
    my @loaded_profiles_list;
    my $current_section_name = undef;
    my $line_number = 0;

    open my $fh, '<:encoding(utf8)', $filepath or die "Error: Cannot open profiles config file '$filepath': $!\n";

    while (my $line = <$fh>)
    {
        $line_number++;
        chomp $line;
        $line =~ s/\s*#.*//;
        $line =~ s/\s*;.*//;
        $line =~ s/^\s+|\s+$//g;
        next if $line eq '';

        if ($line =~ /^\s*\[\s*([^\]]+?)\s*\]\s*$/)
        {
            if (defined $current_section_name && @loaded_profiles_list &&
                $loaded_profiles_list[-1]{name} eq $current_section_name &&
                !defined $loaded_profiles_list[-1]{flags} &&
                (!defined $loaded_profiles_list[-1]{runq_behavior} || $loaded_profiles_list[-1]{runq_behavior} eq 'default') )
            {
                 my $is_incomplete = 1;
                 if (defined $loaded_profiles_list[-1]{flags})
                 {
                    $is_incomplete = 0;
                 }
                 if ($is_incomplete)
                 {
                    warn "Warning: Profile section '[$current_section_name]' in '$filepath' (line $line_number) appears incomplete (missing nfit_flags). Skipping this potentially malformed entry.\n";
                    pop @loaded_profiles_list;
                 }
            }

            $current_section_name = $1;
            $current_section_name =~ s/^\s+|\s+$//g;
            if ($current_section_name eq '')
            {
                warn "Warning: Empty section name in '$filepath' at line $line_number. Skipping.\n";
                $current_section_name = undef;
                next;
            }
            push @loaded_profiles_list, { name => $current_section_name, flags => undef, runq_behavior => 'default' };
        }
        elsif (defined $current_section_name && $line =~ /^\s*([^=]+?)\s*=\s*(.+)$/)
        {
            my $key = lc($1);
            my $value = $2;
            $key =~ s/^\s+|\s+$//g;
            $value =~ s/^\s+|\s+$//g;

            if (@loaded_profiles_list && $loaded_profiles_list[-1]{name} eq $current_section_name)
            {
                if ($key eq 'nfit_flags')
                {
                    if (defined $loaded_profiles_list[-1]{flags})
                    {
                        warn "Warning: Duplicate 'nfit_flags' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    $loaded_profiles_list[-1]{flags} = $value;
                }
                elsif ($key eq 'runq_modifier_behavior')
                {
                     if (defined $loaded_profiles_list[-1]{runq_behavior} && $loaded_profiles_list[-1]{runq_behavior} ne 'default')
                    {
                        warn "Warning: Duplicate 'runq_modifier_behavior' for profile '[$current_section_name]' in '$filepath' (around line $line_number). Using last one.\n";
                    }
                    if ($value eq 'additive_only' || $value eq 'default')
                    {
                        $loaded_profiles_list[-1]{runq_behavior} = $value;
                    }
                    else
                    {
                        warn "Warning: Invalid value '$value' for 'runq_modifier_behavior' in profile '[$current_section_name]' (line $line_number). Using default. Allowed: additive_only, default.\n";
                        $loaded_profiles_list[-1]{runq_behavior} = 'default';
                    }
                }
            }
            else
            {
                 warn "Warning: Key-value pair '$key=$value' found for invalid or unexpected section '$current_section_name' in '$filepath' (line $line_number). Ensure section was defined correctly. Skipping.\n";
            }
        }
        elsif ($line ne '')
        {
            warn "Warning: Unparseable line $line_number in profiles config '$filepath': $line\n";
        }
    }
    close $fh;

    my @valid_profiles;
    foreach my $p_ref (@loaded_profiles_list)
    {
        if (defined $p_ref->{flags} && $p_ref->{flags} ne '')
        {
            $p_ref->{runq_behavior} //= 'default';
            push @valid_profiles, $p_ref;
        }
        else
        {
            warn "Warning: Profile '[" . $p_ref->{name} . "]' in '$filepath' missing mandatory 'nfit_flags'. Removing.\n";
        }
    }
    return @valid_profiles;
}

sub calculate_runq_modified_physc
{
    my ($selected_tier_physc_value_str, $norm_runq_p50_str, $norm_runq_p90_str, $abs_runq_p90_str,
        $smt_used, $current_entitlement_str, $max_cpu_config_str, $is_in_non_default_pool,
        $profile_runq_behavior_setting
    ) = @_;

    my %debug_info;
    my $na_str = "N/A"; # Local N/A string for clarity

    $debug_info{'BasePhysC'} = $selected_tier_physc_value_str // $na_str;
    $profile_runq_behavior_setting //= 'default';

    my $base_physc = ($selected_tier_physc_value_str ne $na_str && $selected_tier_physc_value_str =~ /^-?[0-9.]+$/) ? ($selected_tier_physc_value_str + 0) : undef;
    
    # Initialize debug fields to ensure they always exist in the hash
    $debug_info{'EffFactorReason'} = $na_str; $debug_info{'EffFactor'} = "1.00";
    $debug_info{'BaseAdjustedPhysC'} = defined($base_physc) ? sprintf("%.4f", $base_physc) : $na_str;
    $debug_info{'RunQPressure_P90_Val'} = $na_str; $debug_info{'IsRunQPressure'} = $na_str;
    $debug_info{'IsWorkloadPressure'} = $na_str;
    $debug_info{'WorkloadPressureReason'} = $na_str;
    $debug_info{'EffectiveLCPUsAtBase'} = $na_str; $debug_info{'ExcessThreads'} = $na_str;
    $debug_info{'RawAdditive'} = "0.0000"; $debug_info{'MaxAdditiveCap'} = "0.0000"; $debug_info{'CappedRawAdditive'} = "0.0000";
    $debug_info{'VoltFactorReason'} = $na_str; $debug_info{'VoltFactor'} = "1.00";
    $debug_info{'PoolFactor'} = "1.00";
    $debug_info{'FinalAdditive'} = "0.0000";
    $debug_info{'PreMaxCpuCapRec'} = defined($base_physc) ? sprintf("%.4f", $base_physc) : $na_str;
    $debug_info{'LPARMaxCPUConfig'} = ($max_cpu_config_str ne "" && $max_cpu_config_str =~ /^[0-9.]+$/ && ($max_cpu_config_str+0) > 0) ? ($max_cpu_config_str+0) : $na_str;
    $debug_info{'EntitlementForForecast'} = (defined $current_entitlement_str && $current_entitlement_str ne "" && $current_entitlement_str =~ /^-?[0-9.]+$/) ? ($current_entitlement_str + 0) : 0;
    $debug_info{'ForecastMultiplier'} = $na_str; $debug_info{'EffectiveMaxCPUCap'} = $na_str;
    $debug_info{'CappedByMaxCPU'} = $na_str;
    $debug_info{'FinalAdjustedPhysC'} = $debug_info{'BasePhysC'};

    unless (defined $base_physc)
    {
        $debug_info{'ReasonForNoModification'} = "BasePhysC for profile not numeric or N/A";
        $debug_info{'FinalAdjustedPhysC'} = $selected_tier_physc_value_str // $na_str; # Ensure it reflects input
        return ($selected_tier_physc_value_str // $na_str, \%debug_info);
    }

    my $norm_p50_numeric = ($norm_runq_p50_str ne $na_str && $norm_runq_p50_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p50_str + 0) : undef;
    my $norm_p90_numeric = ($norm_runq_p90_str ne $na_str && $norm_runq_p90_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_str + 0) : undef;
    my $abs_p90_numeric  = ($abs_runq_p90_str  ne $na_str && $abs_runq_p90_str  =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_str + 0)  : undef;
    my $curr_ent_numeric = $debug_info{'EntitlementForForecast'};
    my $max_cpu_for_lpar_numeric = ($debug_info{'LPARMaxCPUConfig'} ne $na_str) ? $debug_info{'LPARMaxCPUConfig'} : 0;
    
    unless (defined $abs_p90_numeric && $smt_used > 0 && (defined $norm_p90_numeric || $max_cpu_for_lpar_numeric > 0) )
    {
        $debug_info{'ReasonForNoModification'} = "Missing essential RunQ (AbsP90, SMT) or contextual metrics (NormP90 or LPAR MaxCPU) for modifier logic.";
        $debug_info{'EffFactorReason'} = "Skipped: " . $debug_info{'ReasonForNoModification'};
        $debug_info{'VoltFactorReason'} = "Skipped: " . $debug_info{'ReasonForNoModification'};
        $debug_info{'FinalAdjustedPhysC'} = sprintf("%.4f", $base_physc);
        return ($base_physc, \%debug_info);
    }

    my $runq_pressure_p90_val = 0;
    if ($max_cpu_for_lpar_numeric > 0 && $smt_used > 0) # abs_p90_numeric is already checked defined
    {
        $runq_pressure_p90_val = $abs_p90_numeric / ($max_cpu_for_lpar_numeric * $smt_used);
    }
    $debug_info{'RunQPressure_P90_Val'} = sprintf("%.4f", $runq_pressure_p90_val);
    my $is_runq_pressure = ($runq_pressure_p90_val > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD);
    $debug_info{'IsRunQPressure'} = $is_runq_pressure ? "True" : "False";

    # --- Workload Pressure Logic ---
    my $is_workload_pressure = 0; # Default to False
    my $workload_pressure_reason = "NormRunQ P90 is nominal.";

    # Define a new threshold at the top of nfit-profile.pl
    my $MIN_ABSRUNQ_FOR_WORKLOAD_PRESSURE_FACTOR = 1.0; # e.g., 1.0 * SMT
    my $MIN_ABSRUNQ_THRESHOLD_VALUE = $MIN_ABSRUNQ_FOR_WORKLOAD_PRESSURE_FACTOR * $smt_used;
    # For simplicity here, let's use smt_used directly as the threshold for AbsRunQ

    if (defined $norm_p90_numeric && $norm_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
    {
        if (defined $abs_p90_numeric && $abs_p90_numeric >= $MIN_ABSRUNQ_THRESHOLD_VALUE)
        {
            $is_workload_pressure = 1;
            $workload_pressure_reason = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f) AND AbsRunQ P90 (%.2f) >= SMT (%d)",
                                              $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                              $abs_p90_numeric, $smt_used);
        }
        else
        {
            $workload_pressure_reason = sprintf("NormRunQ P90 (%.2f) > threshold (%.2f), BUT AbsRunQ P90 (%.2f) < SMT (%d). Workload pressure condition not met due to low absolute queue.",
                                              $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD,
                                              $abs_p90_numeric // "N/A", $smt_used);
        }
    }
    else
    {
        $workload_pressure_reason = (defined $norm_p90_numeric) ? sprintf("NormRunQ P90 (%.2f) <= threshold (%.2f)", $norm_p90_numeric, $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD) : "NormRunQ P90 N/A";
    }
    $debug_info{'IsWorkloadPressure'} = $is_workload_pressure ? "True" : "False";
    $debug_info{'WorkloadPressureReason'} = $workload_pressure_reason;
    # --- End of NEW Logic ---


    my $apply_additive_logic = ($is_runq_pressure || $is_workload_pressure);

    # --- Start of Efficiency Factor Logic ---
    my $efficiency_factor = 1.00; # Default: no reduction
    my $efficiency_reason = "Default (NormRunQ P50 not low enough or other conditions apply)"; # Default reason

    # Define new thresholds and factors at the top of nfit-profile.pl or within the sub if preferred
    my $VOLATILITY_CAUTION_THRESHOLD = 2.5; # Example: P90 is 2.5x P50 - considered volatile
    my $P50_GRADUATED_THRESH_1 = 0.2;  my $FACTOR_GRAD_1 = 0.85; # Very low P50
    my $P50_GRADUATED_THRESH_2 = 0.35; my $FACTOR_GRAD_2 = 0.90; # Moderately low P50
    my $P50_GRADUATED_THRESH_3 = 0.5;  my $FACTOR_GRAD_3 = 0.95; # Slightly low P50 (current binary threshold)

    if ($profile_runq_behavior_setting eq 'additive_only')
    {
        $efficiency_factor = 1.00;
        $efficiency_reason = "Profile runq_behavior=additive_only, no efficiency factor applied.";
    }
    elsif (defined $norm_p50_numeric && defined $norm_p90_numeric) # Ensure both P50 and P90 are available for volatility
    {
        my $volatility_ratio = ($norm_p50_numeric > 0.01 && $norm_p90_numeric > 0.01) ? ($norm_p90_numeric / $norm_p50_numeric) : 1.0; # Avoid division by zero, default to non-volatile

        if ($volatility_ratio >= $VOLATILITY_CAUTION_THRESHOLD)
        {
            # If workload is volatile, be cautious: apply no reduction or a minimal one regardless of P50
            $efficiency_factor = 1.00; # Or perhaps a very mild 0.98 factor
            $efficiency_reason = sprintf("Workload volatile (NormP90/P50 ratio %.2f >= %.2f). Efficiency factor set to %.2f.",
                                         $volatility_ratio, $VOLATILITY_CAUTION_THRESHOLD, $efficiency_factor);
        }
        else # Not excessively volatile, apply graduated factor based on NormRunQ P50
        {
            if ($norm_p50_numeric < $P50_GRADUATED_THRESH_1)
            {
                $efficiency_factor = $FACTOR_GRAD_1;
                $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (and not volatile). Factor %.2f applied.",
                                             $norm_p50_numeric, $P50_GRADUATED_THRESH_1, $efficiency_factor);
            }
            elsif ($norm_p50_numeric < $P50_GRADUATED_THRESH_2)
            {
                $efficiency_factor = $FACTOR_GRAD_2;
                $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (and not volatile). Factor %.2f applied.",
                                             $norm_p50_numeric, $P50_GRADUATED_THRESH_2, $efficiency_factor);
            }
            elsif ($norm_p50_numeric < $P50_GRADUATED_THRESH_3)
            {
                $efficiency_factor = $FACTOR_GRAD_3;
                $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (and not volatile). Factor %.2f applied.",
                                             $norm_p50_numeric, $P50_GRADUATED_THRESH_3, $efficiency_factor);
            }
            else # NormRunQ P50 >= P50_GRADUATED_THRESH_3
            {
                $efficiency_factor = 1.00;
                $efficiency_reason = sprintf("NormRunQ P50 (%.2f) >= %.2f. No efficiency adjustment.",
                                             $norm_p50_numeric, $P50_GRADUATED_THRESH_3);
            }
        }
    }
    elsif (defined $norm_p50_numeric) # P90 not available, fallback to P50 only (graduated)
    {
        # Fallback to original graduated logic if P90 isn't available for volatility
        if ($norm_p50_numeric < $P50_GRADUATED_THRESH_1) {
            $efficiency_factor = $FACTOR_GRAD_1;
            $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (P90 N/A). Factor %.2f applied.", $norm_p50_numeric, $P50_GRADUATED_THRESH_1, $efficiency_factor);
        } elsif ($norm_p50_numeric < $P50_GRADUATED_THRESH_2) {
            $efficiency_factor = $FACTOR_GRAD_2;
            $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (P90 N/A). Factor %.2f applied.", $norm_p50_numeric, $P50_GRADUATED_THRESH_2, $efficiency_factor);
        } elsif ($norm_p50_numeric < $P50_GRADUATED_THRESH_3) {
            $efficiency_factor = $FACTOR_GRAD_3;
            $efficiency_reason = sprintf("NormRunQ P50 (%.2f) < %.2f (P90 N/A). Factor %.2f applied.", $norm_p50_numeric, $P50_GRADUATED_THRESH_3, $efficiency_factor);
        } else {
            $efficiency_reason = sprintf("NormRunQ P50 (%.2f) >= %.2f (P90 N/A). No efficiency adjustment.", $norm_p50_numeric, $P50_GRADUATED_THRESH_3);
        }
    }
    else # NormRunQ P50 is not defined
    {
        $efficiency_factor = 1.00;
        $efficiency_reason = "NormRunQ P50 N/A, no efficiency adjustment applied.";
    }

    # This part remains the same, using the newly determined $efficiency_factor and $efficiency_reason
    $debug_info{'EffFactor'} = sprintf("%.2f", $efficiency_factor);
    $debug_info{'EffFactorReason'} = $efficiency_reason;
    my $base_adjusted_physc = $base_physc * $efficiency_factor; # Apply the determined factor
    $debug_info{'BaseAdjustedPhysC'} = sprintf("%.4f", $base_adjusted_physc);
    # --- End of Efficiency Factor Logic ---
    
    my $additive_cpu = 0.0; # Ensure numeric for accumulation
    my $raw_additive_cpu = 0.0;
    my $max_additive_cap_sliding = 0.0;
    my $capped_raw_additive_val = 0.0;
    my $volatility_confidence_factor = 1.0;
    my $pool_confidence_factor = 1.0;
    $debug_info{'VoltFactorReason'} = "Default (no overriding condition met or additive not applied)"; # Default reason

    if ($apply_additive_logic) # $abs_p90_numeric and $smt_used already checked
    {
        my $effective_lcpus_at_base = $base_physc * $smt_used; # Use original base_physc for this specific calculation step
        $debug_info{'EffectiveLCPUsAtBase'} = sprintf("%.4f", $effective_lcpus_at_base);
        my $excess_threads = $abs_p90_numeric - $effective_lcpus_at_base;
        
        if ($excess_threads > 0)
        {
            $debug_info{'ExcessThreads'} = sprintf("%.4f", $excess_threads);
            $raw_additive_cpu = $excess_threads / $smt_used;
            if ($curr_ent_numeric < $MAX_ADD_ENT_THRESH1) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH2) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL2; }
            elsif ($curr_ent_numeric < $MAX_ADD_ENT_THRESH3) { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL3; }
            else { $max_additive_cap_sliding = $curr_ent_numeric * $MAX_ADD_PERC_VAL_ELSE; }
            if ($curr_ent_numeric == 0 && $max_additive_cap_sliding == 0) { $max_additive_cap_sliding = $MAX_ADD_ABS_VAL1; }
            
            $capped_raw_additive_val = ($raw_additive_cpu < $max_additive_cap_sliding) ? $raw_additive_cpu : $max_additive_cap_sliding;
            
            if ($is_runq_pressure)
            {
                $volatility_confidence_factor = $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR;
                $debug_info{'VoltFactorReason'} = sprintf("RunQPressure Saturation (Factor set to %.2f)", $RUNQ_PRESSURE_SATURATION_CONFIDENCE_FACTOR);
            }
            elsif ($is_workload_pressure && defined $norm_p50_numeric && defined $norm_p90_numeric && $norm_p90_numeric > 0.01)
            {
                my $volatility_ratio = $norm_p50_numeric / $norm_p90_numeric;
                if ($volatility_ratio < $VOLATILITY_SPIKY_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_SPIKY_FACTOR; }
                elsif ($volatility_ratio < $VOLATILITY_MODERATE_THRESHOLD) { $volatility_confidence_factor = $VOLATILITY_MODERATE_FACTOR; }
                else { $volatility_confidence_factor = 1.0; } # Not spiky or moderate, use full factor
                $debug_info{'VoltFactorReason'} = sprintf("Calculated (NormRQ P50/P90 ratio %.2f for WorkloadPressure -> Factor %.2f)", $volatility_ratio, $volatility_confidence_factor);
            }
            else
            {
                 $debug_info{'VoltFactorReason'} = "Additive conditions met but NormP50/P90 not usable for Volatility Factor calc, or WorkloadPressure was False.";
            }
            $additive_cpu = $capped_raw_additive_val * $volatility_confidence_factor;
            if ($is_in_non_default_pool && $additive_cpu > 0)
            {
                $pool_confidence_factor = $POOL_CONSTRAINT_CONFIDENCE_FACTOR;
                $additive_cpu *= $pool_confidence_factor;
            }
        }
        else
        {
            $debug_info{'ExcessThreads'} = "0.0000 (No excess)";
        }
    }
    $debug_info{'RawAdditive'} = sprintf("%.4f", $raw_additive_cpu);
    $debug_info{'MaxAdditiveCap'} = sprintf("%.4f", $max_additive_cap_sliding);
    $debug_info{'CappedRawAdditive'} = sprintf("%.4f", $capped_raw_additive_val);
    $debug_info{'VoltFactor'} = sprintf("%.2f", $volatility_confidence_factor);
    $debug_info{'PoolFactor'} = sprintf("%.2f", $pool_confidence_factor);
    $debug_info{'FinalAdditive'} = sprintf("%.4f", $additive_cpu);
    
    my $calculated_demand = $base_adjusted_physc + $additive_cpu;
    my $runq_modified_rec = $calculated_demand;
    $debug_info{'PreMaxCpuCapRec'} = sprintf("%.4f", $runq_modified_rec);

    my $forecast_multiplier_val = 1.25;
    if ($curr_ent_numeric < 0.5) { $forecast_multiplier_val = 2.5; }
    elsif ($curr_ent_numeric < 1.0) { $forecast_multiplier_val = 2.0; }
    elsif ($curr_ent_numeric < 2.0) { $forecast_multiplier_val = 1.75; }
    elsif ($curr_ent_numeric < 4.0) { $forecast_multiplier_val = 1.5; }
    $debug_info{'ForecastMultiplier'} = $forecast_multiplier_val;

    my $effective_max_cpu_cap_val = ($max_cpu_for_lpar_numeric > 0) ? ($max_cpu_for_lpar_numeric * $forecast_multiplier_val) : undef;
    $debug_info{'EffectiveMaxCPUCap'} = defined($effective_max_cpu_cap_val) ? sprintf("%.4f", $effective_max_cpu_cap_val) : $na_str;
    
    if (defined $effective_max_cpu_cap_val && $calculated_demand > $effective_max_cpu_cap_val)
    {
        $runq_modified_rec = $effective_max_cpu_cap_val;
        $debug_info{'CappedByMaxCPU'} = "True";
    }
    else
    {
      $debug_info{'CappedByMaxCPU'} = (defined $effective_max_cpu_cap_val) ? "False" : "N/A (No LPAR MaxCPU for cap check)";
    }

    if ($runq_modified_rec < 0) { $runq_modified_rec = 0; }
    $debug_info{'FinalAdjustedPhysC'} = sprintf("%.4f", $runq_modified_rec);

    return ($runq_modified_rec, \%debug_info);
}

sub generate_sizing_hint
{
    my %args = @_;
    my $results_ref = $args{'results_ref'};
    my $vm = $args{'vm'};
    my $config_ref = $args{'config_ref'};
    my $norm_runq_p90_for_vm_str = $args{'norm_runq_p90_for_vm_str'};
    my $abs_runq_p90_for_vm_str  = $args{'abs_runq_p90_for_vm_str'};
    my $max_cpu_for_vm_numeric   = $args{'max_cpu_for_vm_numeric'};
    my $smt_used_for_vm_numeric  = $args{'smt_used_for_vm_numeric'};

    if (defined $config_ref && defined $config_ref->{'systemtype'} && $config_ref->{'systemtype'} =~ /VIO Server/i)
    {
        return ("P", "VIO Server", 0, "");
    }
    
    my $o3_val = $results_ref->{$vm}{'O3-95W15'} // "0"; $o3_val = "0" unless ($o3_val =~ /^-?[0-9.]+\z/ && $o3_val ne "N/A"); $o3_val += 0;
    my $b3_val = $results_ref->{$vm}{'B3-95W15'} // "0"; $b3_val = "0" unless ($b3_val =~ /^-?[0-9.]+\z/ && $b3_val ne "N/A"); $b3_val += 0;
    my $g3_val = $results_ref->{$vm}{'G3-95W15'} // "0"; $g3_val = "0" unless ($g3_val =~ /^-?[0-9.]+\z/ && $g3_val ne "N/A"); $g3_val += 0;
    my $p99w1_val = $results_ref->{$vm}{'P-99W1'} // "0"; $p99w1_val = "0" unless ($p99w1_val =~ /^-?[0-9.]+\z/ && $p99w1_val ne "N/A"); $p99w1_val += 0;
    
    my $suggested_pattern = "G";
    if ($b3_val > 0.01 && $o3_val > ($b3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "O";
    }
    elsif ($o3_val > 0.01 && $b3_val > ($o3_val * $PATTERN_RATIO_THRESHOLD))
    {
        $suggested_pattern = "B";
    }
    
    my $peakiness_ratio = 0;
    if ($g3_val > 0.01)
    {
        $peakiness_ratio = ($p99w1_val / $g3_val);
    }
    
    my $shape_descriptor = "Steady";
    if ($peakiness_ratio >= $HIGH_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Very Peaky";
    }
    elsif ($peakiness_ratio >= $LOW_PEAK_RATIO_THRESHOLD)
    {
        $shape_descriptor = "Moderately Peaky";
    }
    
    my $pressure_detected_maxcpu_limit = 0;
    my $pressure_detected_runq_pressure = 0;
    my $pressure_detected_workload_pressure = 0;
    my $pressure_detail_str = "";
    
    my $maxcpu_val_from_config = (defined $config_ref && defined $config_ref->{'maxcpu'} && $config_ref->{'maxcpu'} =~ /^[0-9.]+$/ && ($config_ref->{'maxcpu'}+0) > 0) ? ($config_ref->{'maxcpu'}+0) : undef;
    if (defined $maxcpu_val_from_config && $p99w1_val >= ($maxcpu_val_from_config * $LIMIT_THRESHOLD_PERC))
    {
        $pressure_detected_maxcpu_limit = 1;
    }
    
    my $abs_runq_p90_numeric = ($abs_runq_p90_for_vm_str ne "N/A" && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;
    my $runq_pressure_p90_calculated_value = 0;
    if (defined $abs_runq_p90_numeric && defined $max_cpu_for_vm_numeric && $max_cpu_for_vm_numeric > 0 && defined $smt_used_for_vm_numeric && $smt_used_for_vm_numeric > 0)
    {
        $runq_pressure_p90_calculated_value = $abs_runq_p90_numeric / ($max_cpu_for_vm_numeric * $smt_used_for_vm_numeric);
    }
    if ($runq_pressure_p90_calculated_value > $RUNQ_PRESSURE_P90_SATURATION_THRESHOLD)
    {
        $pressure_detected_runq_pressure = 1;
    }
    
    my $norm_runq_p90_numeric = ($norm_runq_p90_for_vm_str ne "N/A" && $norm_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($norm_runq_p90_for_vm_str + 0) : undef;
    my $abs_runq_p90_for_hint_numeric = ($abs_runq_p90_for_vm_str ne "N/A" && $abs_runq_p90_for_vm_str =~ /^-?[0-9.]+$/) ? ($abs_runq_p90_for_vm_str + 0) : undef;

    # Threshold for AbsRunQ P90 to consider NormRunQ P90 for workload pressure
    # Consistent with the logic being added to calculate_runq_modified_physc
    my $min_absrunq_threshold_for_hint = $smt_used_for_vm_numeric; # Requires AbsRunQ P90 >= SMT threads

    if (defined $norm_runq_p90_numeric && $norm_runq_p90_numeric > $WORKLOAD_PRESSURE_NORM_P90_TRIGGER_THRESHOLD)
    {
        if (defined $abs_runq_p90_for_hint_numeric && $abs_runq_p90_for_hint_numeric >= $min_absrunq_threshold_for_hint)
        {
            $pressure_detected_workload_pressure = 1;
        }
    }
    
    my $overall_pressure_detected = $pressure_detected_maxcpu_limit || $pressure_detected_runq_pressure || $pressure_detected_workload_pressure;
    if ($overall_pressure_detected)
    {
        my @pressure_points;
        if ($pressure_detected_maxcpu_limit) { push @pressure_points, "MaxCPU"; }
        if ($pressure_detected_runq_pressure) { push @pressure_points, "RunQPressure(P90=" . sprintf("%.2f", $runq_pressure_p90_calculated_value) . ")"; }
        if ($pressure_detected_workload_pressure) { push @pressure_points, "Workload(NormP90=" . sprintf("%.2f", $norm_runq_p90_numeric) . ")"; }
        if (defined $config_ref && defined $config_ref->{'pool_name'} && lc($config_ref->{'pool_name'}) ne 'defaultpool' && $config_ref->{'pool_name'} ne '')
        {
            push @pressure_points, "Pool(" . $config_ref->{'pool_name'} . ")?";
        }
        $pressure_detail_str = join(", ", @pressure_points);
    }
    
    my $initial_tier_range_str = "3/4";
    if ($shape_descriptor eq "Very Peaky")
    {
        $initial_tier_range_str = "1/2";
    }
    elsif ($shape_descriptor eq "Moderately Peaky")
    {
        $initial_tier_range_str = "2/3";
    }
    
    my $adjusted_tier_str = $initial_tier_range_str;
    if ($overall_pressure_detected)
    {
        if ($initial_tier_range_str eq "3/4") { $adjusted_tier_str = "3"; }
        elsif ($initial_tier_range_str eq "2/3") { $adjusted_tier_str = "2"; }
        elsif ($initial_tier_range_str eq "1/2") { $adjusted_tier_str = "1"; }
    }
    
    my $pattern_tier_string = $suggested_pattern . $adjusted_tier_str;
    return ($pattern_tier_string, $shape_descriptor, $overall_pressure_detected, $pressure_detail_str);
}

sub parse_percentile_list_for_header
{
    my ($perc_str, $clean_zeros) = @_;
    $clean_zeros = 1 if !defined $clean_zeros;
    my @percentiles_cleaned;
    if (defined $perc_str && $perc_str ne '')
    {
        my @raw_percentiles = split /,\s*/, $perc_str;
        foreach my $p (@raw_percentiles)
        {
            if ($p =~ /^[0-9]+(?:\.[0-9]+)?$/ && $p >= 0 && $p <= 100)
            {
                my $p_label = $p;
                if ($clean_zeros)
                {
                    $p_label = sprintf("%.2f", $p);
                    $p_label =~ s/\.?0+$//;
                    $p_label = "0" if $p_label eq "" && ($p eq "0" || $p eq "0.00");
                }
                push @percentiles_cleaned, $p_label;
            }
            else
            {
                die "Error: Invalid percentile value '$p' found in list '$perc_str'. Must be numeric between 0 and 100.\n";
            }
        }
    }
    return \@percentiles_cleaned;
}

sub ensure_percentiles_requested
{
    my ($perc_list_str, @required_percs) = @_;
    return 1 unless defined $perc_list_str && $perc_list_str ne '';
    my $parsed_percs_ref = parse_percentile_list_for_header($perc_list_str, 0);
    my %present_map = map { $_ => 1 } @{$parsed_percs_ref};
    foreach my $req_p (@required_percs)
    {
        unless (exists $present_map{$req_p})
        {
            return 0;
        }
    }
    return 1;
}

sub get_nfit_output_dp_from_flags
{
    my ($nfit_flags_str_for_this_run) = @_;
    if ($nfit_flags_str_for_this_run =~ /-r(?:=(\d*\.\d+))?|-u(?:=(\d*\.\d+))?/)
    {
        my $increment_val = $1 // $2;
        if (!(defined $increment_val && $increment_val ne ""))
        {
            $increment_val = $DEFAULT_ROUND_INCREMENT;
        }
        return get_decimal_places($increment_val);
    }
    return 4;
}

sub get_decimal_places
{
    my ($number) = @_;
    $number = sprintf("%.15f", $number) if ($number =~ /e/i);
    if ($number =~ /\.(\d+)$/)
    {
        return length($1);
    }
    else
    {
        return 0;
    }
}

sub usage_wrapper
{
    my $script_name = $0;
    $script_name =~ s{.*/}{};
    return <<END_USAGE;
Usage: $script_name --physc-data <pc_file> [options]

Runs 'nfit' for multiple profiles. Applies RunQ modifiers and generates hints.
The RunQ modifier behavior (standard vs. additive-only) can be controlled
per profile via the 'runq_modifier_behavior' attribute in nfit.profiles.cfg.
Optionally passes flags to nfit for its internal windowed decay processing.
A detailed rationale log is written to /tmp/nfit-profile-rationale.log.

Core Input:
  --physc-data, -pc <file> : Path to NMON PhysC data CSV (required).
  --runq-data, -rq <file>  : Optional. Path to NMON RunQ data CSV.
  --default-smt, --smt <N> : Optional. Default SMT level (Default: $DEFAULT_SMT_VALUE_PROFILE).

RunQ Metric Configuration (for nfit calls):
  --runq-norm-percentiles <list> : For Normalised RunQ (Default: "$DEFAULT_RUNQ_NORM_PERCS").
  --runq-abs-percentiles <list>  : For Absolute RunQ (Default: "$DEFAULT_RUNQ_ABS_PERCS").

Configuration Files:
  -config <vm_cfg_csv>       : Optional. VM configuration CSV file.
  --profiles-config <path>   : Optional. Profiles definition file (INI format).
                               Can contain 'runq_modifier_behavior = additive_only' per profile.

Filtering (Global or passed to nfit):
  -s, --startdate <YYYY-MM-DD> : Optional. Global start date for analysis (passed to nfit).
  -vm, --lpar <name>         : Optional. Analyse only the specified VM/LPAR name (passed to nfit).

Control nfit's Internal Windowed Recency Decay (Optional):
  --nfit-enable-windowed-decay    : Enable nfit's internal windowed processing.
                                    (Requires nfit v2.28.0.4+ for full RunQ decay support)
  --nfit-process-window-unit <days|weeks> : Unit for nfit's window size (Default: $DEFAULT_PROCESS_WINDOW_UNIT_FOR_NFIT).
  --nfit-process-window-size <N>  : Size of nfit's window in units (Default: $DEFAULT_PROCESS_WINDOW_SIZE_FOR_NFIT).
  --nfit-decay-half-life-days <N> : Half-life for nfit's recency weighting (Default: $DEFAULT_DECAY_HALF_LIFE_DAYS_FOR_NFIT).
  --nfit-analysis-reference-date <YYYY-MM-DD> : "Current" date for nfit's recency calculation
                                    (Default: nfit uses date of last record in its filtered NMON data).
  --nfit-runq-avg-method <none|sma|ema> : Averaging method for RunQ data within nfit before percentile.
                                          (Default: $DEFAULT_NFIT_RUNQ_AVG_METHOD). Uses main -w/--decay/--runq-decay from profile.

Rounding (Passed to nfit for its output):
  -r[=increment]             : Optional. nfit rounds results to NEAREST increment.
  -u[=increment]             : Optional. nfit rounds results UP to nearest increment.
                               (Default increment: $DEFAULT_ROUND_INCREMENT)
Other:
  --nfit-path <path>         : Optional. Path to the 'nfit' script.
  -h, --help                 : Display this help message.
  -v, --version              : Display script version and nfit version used.

Output CSV Columns (Illustrative):
  VM,TIER,Hint,Pattern,Pressure,PressureDetail,SMT,
  Serial,SystemType,Pool Name,Pool ID,Peak,
  [Profile Names (values are potentially recency-weighted by nfit & RunQ-modified by nfit-profile)...],
  Current_ENT,NFIT_ENT_UserFormula,NETT_UserFormula,NETT_Perc_UserFormula

END_USAGE
}
